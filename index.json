[{"authors":["admin"],"categories":null,"content":"万祚全，常用网名Visors，大三本科生，现就读于中南民族大学，校ACM队负责人。忙时在攻算法竞赛，闲时在梦游。对于我熟悉的领域或我组织的相关事宜，欢迎邮件或电报交流。\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1603821264,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://visors.github.io/author/%E4%B8%87%E7%A5%9A%E5%85%A8/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/%E4%B8%87%E7%A5%9A%E5%85%A8/","section":"authors","summary":"万祚全，常用网名Visors，大三本科生，现就读于中南民族大","tags":null,"title":"万祚全","type":"authors"},{"authors":["Visors"],"categories":["Unity"],"content":"using System.Collections; using System.Collections.Generic; using UnityEngine; public class PlayerMove : MonoBehaviour { public Rigidbody2D rb; public float speed; public float jumpforce; // Start is called before the first frame update void Start() { } void FixedUpdate() { Movement(); } // Update is called once per frame void Update() { if (Input.GetButtonDown(\u0026quot;Jump\u0026quot;)) rb.velocity = new Vector2(rb.velocity.x, jumpforce); } void Movement() { float flag = Input.GetAxis(\u0026quot;Horizontal\u0026quot;); float facedirection = Input.GetAxisRaw(\u0026quot;Horizontal\u0026quot;); rb.velocity = new Vector2(flag * speed, rb.velocity.y); if (facedirection != 0) transform.localScale = new Vector3(facedirection, 1, 1); } }  一些记录 GetAxis(axisName)返回由 axisName 标识的虚拟轴的值。对于键盘和游戏杆输入设备，该值将处于 $-1\\dots 1$ 的范围内。\nGetAxisRaw(axisName)返回由 axisName 标识的虚拟轴的值（未应用平滑过滤）。对于键盘和游戏杆输入，该值将处于 $-1\\dots 1$ 的范围内。 由于未对输入进行平滑处理，键盘输入将始终为 $-1$、$0$ 或 $1$。\n一开始看见localScale的修改时，我下意识敲了rb.localScale，但实际上是transform.localScale，因为Scale是transform下的一个参数，而transform和script都同属于一个object下，所以不需要别的额外的范围限定。\nUpdate是逐帧执行，FixedUpdate等时间间隔执行。\n程序在不同的设备上运行时，受限于设备性能，渲染出的帧数可能不相同，这导致Update单位时间内在不同设备上的执行次数不同，可能造成实际画面效果不一致。所以推荐使用FixedUpdate保证效果一致。\n但在编写跳跃动作时，若采用FixedUpdate，可能导致按键不响应，改回Update后解决。问题原因可参考这篇博客Unity3D系列2：Input.GetButtonDown没有正确响应\n一些讨论 不明原理 ","date":1642169990,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1642169990,"objectID":"f8c74f70a5c3fef5936d9097c1f6affa","permalink":"https://visors.github.io/post/unity2d%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%E8%BD%AC%E5%90%91%E4%B8%8E%E8%B7%B3%E8%B7%83/","publishdate":"2022-01-14T22:19:50+08:00","relpermalink":"/post/unity2d%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%E8%BD%AC%E5%90%91%E4%B8%8E%E8%B7%B3%E8%B7%83/","section":"post","summary":"关于简单角色移动的踩坑经验","tags":["Unity2D"],"title":"Unity2D角色移动转向与跳跃","type":"post"},{"authors":["Visors"],"categories":["Codeforces","Solution Report"],"content":"A - Tit for Tat 这题贪心就行了。要使字典序尽可能小，当然是从首至尾贪心，只要可以操作且还有操作次数，都是是当前数字减小，末尾数字增加。这样得到的字典序一定是最小的。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int T; int n, k; vector\u0026lt;int\u0026gt; v; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; v.resize(n); for (int \u0026amp;it:v) cin \u0026gt;\u0026gt; it; for (int i = 0; i \u0026lt; n - 1; i++) { int delta = min(v[i], k); v[i] -= delta; v.back() += delta; k -= delta; if (k == 0) break; } for (int i = 0; i \u0026lt; n - 1; i++) cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; ' '; cout \u0026lt;\u0026lt; v.back() \u0026lt;\u0026lt; endl; } return 0; }  B - AGAGA XOOORRR 这题其实只需要运用一点位运算的知识。\n一开始我以为想出正解了，结果是把题目读错了（大错特错），那时候正好拿外卖吃饭，就找LYH交流了手，发现自己病情严重……\n由于异或的特性，偶数个相同的数异或和等于$0$，例如$a\\oplus a = 0$，奇数个相同的数异或和等于其本身，例如$a\\oplus a\\oplus a = a$。\n那么，若我们一开始求出所有数的异或和为$ans$，如果$ans=0$，意味着序列可以被划分为两段，这两段异或和相同；如果$ans\u0026gt;0$，我们应检查序列能被分为几段异或和为$ans$的部分，且这个部分数一定为奇数。\n按照题意，$ans=0$意味着YES，$ans\u0026gt;0$时如果只能被分为完整的一段为NO，其余为YES。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int T, n; vector\u0026lt;int\u0026gt; v; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n; v.resize(n); int ans = 0; for (int \u0026amp;it:v) { cin \u0026gt;\u0026gt; it; ans ^= it; } if (ans == 0) { cout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot;; continue; } int tmp = 0, cnt = 0; for (int it:v) { tmp ^= it; if (tmp == ans) { cnt++; tmp = 0; } } if (cnt \u0026gt; 1) cout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot;; else cout \u0026lt;\u0026lt; \u0026quot;NO\\n\u0026quot;; } return 0; }  C - Baby Ehab Partitions Again 题目大意是给定一个序列，让你删除尽可能少的数，使得删除后的序列不能够被完全划分成两个和相同的部分。\n所有首先要做的肯定是判断这个序列不删的时候能不能被划分成两个和相同的部分，判断的方法和《kkksc03考前临时抱佛脚》那题一样，可以用01背包求出两部分中和最小的最大值，如果这个最大值为sum/2，那么就不需要找数删，否则不用删数就已经满足要求了，输出0.\n","date":1619360130,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1619360130,"objectID":"960a489ce6974acf843c9b9766280182","permalink":"https://visors.github.io/post/codeforces-round-717-div.2/","publishdate":"2021-04-25T22:15:30+08:00","relpermalink":"/post/codeforces-round-717-div.2/","section":"post","summary":"LYH带我上大分……","tags":["Codeforces","Solution Report"],"title":"Codeforces Round 717 Div.2","type":"post"},{"authors":["Visors"],"categories":["Codeforces","Solution Report"],"content":"已经连着两场掉分了，麻了麻了……\n这场开的比较早，在寝室里打的，九点多的时候还比较闹，有点难静下心来思考。加之前一晚喝了酒，感觉脑子里一片混沌——这大概是发挥不好的一点场外原因，还是希望下一场能上大分。\n近期还有一个问题是出题出的比较慢，以往我前两题出的都是非常快的，但最近越来越慢，可能要到四五十分钟才能出完，浩元学长这时候C都已经出思路了……\nA - Perfectly Imperfect Array 题目大意就是给定一个数组，问能不能从中取出一个子序列，使得其中所有数的乘积为一个完全平方数。如果可以输出NO，不可以输出YES。\n对于任意个完全平方数的乘积$a^2b^2\\cdotsc^2 = (ab*\\cdots *c)^2$，也一定是完全平方数。所以只要有数组中有非完全平方数，那么取该数为子序列就为YES，否则数组中元素全为完全平方数，任意个组合结果仍是完全平方数，为NO。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int T, n; vector\u0026lt;int\u0026gt; v; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n; v.resize(n); for (int \u0026amp;it:v) cin \u0026gt;\u0026gt; it; bool flag = true; for (int it:v) { if (it == 1) continue; int tmp = sqrt(it); if (tmp * tmp != it) { flag = false; break; } } if (!flag) cout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot;; else cout \u0026lt;\u0026lt; \u0026quot;NO\\n\u0026quot;; } return 0; }  B - AND 0, Sum Big 一开始读掉了这一条件：\n the sum of its elements is as large as possible. 所有元素的和尽可能大。  事实上这条就是解题的关键。首先要满足所有数按位与结果为$0$，其实就是要所有数的同位数字中至少出现一个$0$。我们又知道，即使是二进制下我们也可以仿照十进制进行竖式运算，所以要同时让按位与结果为$0$，还要所有元素的和尽可能大，一定是在所有数的同位数字中有且仅出现一个$0$，这样得到的元素和为$(n-1)*(2^k-1)$。\n那很容易就能得知本题的答案，即每位共$n$个数字，从中选一个作为$0$，其它的作为$1$，总共选$k$位，根据乘法原理答案就是$n^k$。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll MOD = 1e9 + 7; int T; ll n, k; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; ll ans = 1; for (int i = 1; i \u0026lt;= k; i++) ans = (ans * n) % MOD; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }  C - Product 1 Modulo N 写这题时，我先用下面代码打了个表：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); for (n = 1; n \u0026lt;= 20; n++) { vector\u0026lt;int\u0026gt; ans; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; (n - 1)); i++) { int tmp = i; int cnt = 1, mul = 1; vector\u0026lt;int\u0026gt; v; while (tmp) { if (tmp \u0026amp; 1) { mul *= cnt; v.push_back(cnt); } cnt++; tmp \u0026gt;\u0026gt;= 1; } if (mul % n == 1 \u0026amp;\u0026amp; v.size() \u0026gt; ans.size()) ans = v; } cout \u0026lt;\u0026lt; \u0026quot;n = \u0026quot; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026quot;: \\n\u0026quot;; cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; for (int it:ans) cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; ' '; cout \u0026lt;\u0026lt; endl; } return 0; }  观察了一下$1\\leq n\\leq 20$下的结果：\nn = 1: 0 n = 2: 1 1 n = 3: 1 1 n = 4: 1 1 n = 5: 3 1 2 3 n = 6: 1 1 n = 7: 5 1 2 3 4 5 n = 8: 4 1 3 5 7 n = 9: 5 1 2 4 5 7 n = 10: 3 1 3 7 n = 11: 9 1 2 3 4 5 6 7 8 9 n = 12: 4 1 5 7 11 n = 13: 11 1 2 3 4 5 6 7 8 9 10 11 n = 14: 5 1 3 5 9 11 n = 15: 8 1 2 4 7 8 11 13 14 n = 16: 8 1 3 5 7 9 11 13 15 n = 17: 15 1 2 3 4 5 6 7 8 10 11 12 13 14 15 16 n = 18: 5 1 5 7 11 13 n = 19: 16 1 2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 n = 20: 8 1 3 7 9 11 13 17 19  然后开始找规律，发现首先$n$为偶数时，答案中只有奇数。其次，$n$为奇数时，答案都是从$1\\sim n-1$删去几个数构成的。\n当天有点迷糊，觉得肯定有进一步的规律，但没想出来是什么，就去求助了下学长。发现学长很早之前就已经给了个思路（那时我甚至不知道他说的是C题）——去掉所有与$n$不互素的数，然后特判$n=4k+2$的情况，这种时候要额外去掉$n-1$。我按这个标准核验了下表，发现似乎确实如此，于是码了下面的代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; vector\u0026lt;int\u0026gt; prime, ans; bool check(int k) { int len = sqrt(k); for (int i = 2; i \u0026lt;= len; i++) if (k % i == 0) return false; return true; } int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; n; if (n \u0026lt; 5) return cout \u0026lt;\u0026lt; \u0026quot;1\\n1\\n\u0026quot;, 0; if (check(n)) { cout \u0026lt;\u0026lt; n - 2 \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt; n - 2; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; ' '; cout \u0026lt;\u0026lt; n - 2 \u0026lt;\u0026lt; endl; return 0; } int tmp = n; while (tmp \u0026gt; 1) { for (int i = 2; i \u0026lt;= n; i++) if (tmp % i == 0) { tmp /= i; prime.emplace_back(i); break; } } for (int i = 1; i \u0026lt; n; i++) { bool flag = true; for (int it:prime) { if (i % it == 0) { flag = false; break; } } if (flag) ans.emplace_back(i); } if ((n - 2) % 4 == 0 \u0026amp;\u0026amp; ans.back() == n - 1) ans.pop_back(); cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; ans.size() - 1; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; ' '; cout \u0026lt;\u0026lt; ans.back() \u0026lt;\u0026lt; endl; return 0; }  最后几秒钟没提交上去，当时还小伤心了会儿。结果最后等System Test结束后补交一发WA了，说明上面的贪心处理策略还是有问题的。\n不过研究互素的方向是正确的。\n首先我们假定选定的序列包含$a$，且其它数乘积为$x$（模$n$），那么有$x$是$a$的逆元，$a$就满足$\\gcd(a,n)=1$，否则不能入选。\n我们把所有该选的$a$边累乘边取模，可以得到一个小于$n$的数$mul$，$mul$肯定与$n$互质，所以$mul$一定是在前面取过的，如果$mul\\neq 1$，就不取这个数。\n我不太擅长数论题，只能一知半解借助Tutorial和网络资源理解理解，代码如下：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int n; vector\u0026lt;int\u0026gt; v; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; n; ll mul = 1; for (int i = 1; i \u0026lt; n; i++) if (__gcd(i, n) == 1) { mul = mul * i % n; v.emplace_back(i); } mul %= n; if (mul != 1) for (auto it = v.begin(); it != v.end(); it++) if (*it == mul) { v.erase(it); break; } cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; v.size() - 1; i++) cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; ' '; cout \u0026lt;\u0026lt; v.back() \u0026lt;\u0026lt; endl; return 0; }  ","date":1618889494,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1618889494,"objectID":"640b6af2657d843e5a2d4f92fba984dc","permalink":"https://visors.github.io/post/codeforces-round-716-div.2/","publishdate":"2021-04-20T11:31:34+08:00","relpermalink":"/post/codeforces-round-716-div.2/","section":"post","summary":"又双叒叕掉分了……","tags":["Codeforces","Solution Report"],"title":"Codeforces Round 716 Div.2","type":"post"},{"authors":["Visors"],"categories":["Solution Report","Bipartite Graph","Think Twice"],"content":"One of Each 题目传送门\n讲道理这道题应该可做，不过当时太饿了急着吃饭就没心去想了。\n用一个栈维护当前解，线性扫描整个序列，对于未取到的数字，我们先检查其是否能在当前解中“上浮”。先说做法，再说原因——检查栈顶元素是否比当前要取数字大，如果大，那么让该数字上浮（当前待取数字最终会压入栈顶，每次检查出栈顶，在所有上浮检查结束后压入栈顶就行），显然字典序最小，重复此操作直至栈为空或栈顶元素不满足上浮条件。上浮的条件除了数字本身的大小关系外，还要看这个栈顶元素在后面是否还会再出现（不然不能让该数字在答案序列中出现在栈顶元素前）。判断后面会不会出现很简单，一开始预处理每个数字出现的个数，线性扫描时不断让对应数字个数减少，即能动态维护当前值后所有数字出现的个数。\n如果明白了上述过程，一般就能理解其正确性，不过还是稍作解释：\n我们的解一定是在一个子区间中选出来的，那么当我们的区间向右扩大时，若该数字出现过，不用讨论，因为该数字即使在该处取，也没有在之前取到的地方取好（后面能接的数是之前的子集）；若该数字没出现过，那么我们要考虑该数字能否在追求字典序最小的情况下优化当前解。根据字典序，当然是越小的数越出现在前面越好，所以我们可以对当前解从后往前检查，如果该数字比后端数字小，那么将它放在该位置显然会使字典序最小，但放的时候也要考虑后面会不会有机会再把这个后端元素取回来，如果取不回来，解最终就凑不齐$k$个了。当我们上浮至无法上浮的位置时，就接着去考虑下一个数的加入就行了。因为我们每次上浮都保证了去掉的后端元素存在于后面未取数字中，所以一次线性扫描一定能恰巧取出字典序最小的$k$个元素形成的序列。\n之前听说stack的实现都是基于vector的，推荐直接用vector替代stack，那就用vector吧。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, k; vector\u0026lt;int\u0026gt; v, cnt, ans; vector\u0026lt;bool\u0026gt; book; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; v.resize(n), cnt.resize(k + 1), book.resize(k + 1); for (int \u0026amp;it:v) { cin \u0026gt;\u0026gt; it; cnt[it]++; } for (int i = 0; i \u0026lt; n; i++) { cnt[v[i]]--; if (!book[v[i]]) { book[v[i]] = true; while (!ans.empty() \u0026amp;\u0026amp; cnt[ans.back()] \u0026gt; 0 \u0026amp;\u0026amp; ans.back() \u0026gt; v[i]) book[ans.back()] = false, ans.pop_back(); ans.push_back(v[i]); } } for (int i = 0; i \u0026lt; k - 1; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; ' '; cout \u0026lt;\u0026lt; ans.back() \u0026lt;\u0026lt; endl; return 0; }  Swap Free 题目传送门\n初看题目，这道题有个很裸的图论模型，即可以单词为点，为互不可一步转换的词之间建无向边，则题目待求即可转换为最大完全子图的节点数（最大团问题）。\n不过写的时候我没接触过最大团问题，甚至都没听说过“最大团”这个词，想来惭愧……\n不过脑补一下，还是能想到最大团的一个求法。当时想的是二分最大团的节点数，然后把度数不足节点数的“枝叶”删掉，但很快就被我想反例，不过这其中删枝叶的思想还是有一定意义的。\n这里需要用到补图的思想——既然在原图中团的点之间两两连边，那么在补图中他们两两不连边，成一个独立集。那么补图的最大独立集即对应原图的最大团（这么一想可能我在接触最大独立集时就没有研究清楚）。\n那么考虑本问题的补图是什么——以单词为点，为互相可转换的词之间建无向边。这个图有一个特别的性质，若存在边$(a,b)$和边$(a,c)$，则必定不会存在边$(b,c)$，具体来解释，其实每条边之间都有一个隐形的边权，即两串相互转换对应的字母下标对。那么设$(a,b)$权值为$(p_1,p_2)$，$(a,c)$权值为$(p_3,p_4)$，$(b,c)$权值为$(p_5,p_6)$。这也进一步意味着$a[p_1]=b[p_2]$，$a[p_3]=c[p_4]$，假设存在边$(b,c)$，则有$b[p_5]=c[p_6]$。写到这里，读者可能认为这些式子间毫无关系，但注意本题有一个隐含条件，即对于有边相连的两个单词，除了这些错位不相同的字母对，其它部分应是位置一一对应的相等字符，即有$a[p_5]=b[p_5]=c[p_6]$，对下标的相等情况稍作讨论，即可得出假设矛盾。\n清楚了这样一个性质，该图即为一个二分图，本来在一般图中求最大独立集很复杂，但在二分图中就非常简单了。在二分图中，最大独立集=点数-最大匹配数，最大匹配数可以使用匈牙利算法解决。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; Edge; int n; vector\u0026lt;string\u0026gt; words; vector\u0026lt;Edge\u0026gt; edges; vector\u0026lt;int\u0026gt; heads; vector\u0026lt;bool\u0026gt; vis; vector\u0026lt;int\u0026gt; match; inline bool check(const string \u0026amp;s1, const string \u0026amp;s2) { // 如果两串恰好有两位置不同，即需连边 int cnt = 0; for (int i = 0; i \u0026lt; s1.size(); i++) { if (s1[i] != s2[i]) { cnt++; if (cnt \u0026gt; 2) return false; } } return cnt != 0; } inline void addEdge(int u, int v) { edges.emplace_back(v, heads[u]); heads[u] = edges.size() - 1; } bool dfs(int u) { for (int i = heads[u], v; ~i; i = edges[i].second) { if (!vis[v = edges[i].first]) { vis[v] = true; if (!match[v] || dfs(match[v])) { match[v] = u; return true; } } } return false; } int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; n; heads.resize(n, -1); vis.resize(n); match.resize(n); words.resize(n); for (string \u0026amp;s:words) cin \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; n; i++) for (int j = i + 1; j \u0026lt; n; j++) if (check(words[i], words[j])) addEdge(i, j), addEdge(j, i); int max_match = 0; for (int i = 0; i \u0026lt; words.size(); i++) { fill(vis.begin(), vis.end(), false); vis[i] = true; if (dfs(i)) max_match++; } cout \u0026lt;\u0026lt; n - max_match / 2 \u0026lt;\u0026lt; endl; // 对所有点dfs，结果要除2 return 0; }  ","date":1617731428,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1617731428,"objectID":"41076e7df1dd8f8db2eff14097438c2c","permalink":"https://visors.github.io/post/upc%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98/","publishdate":"2021-04-07T01:50:28+08:00","relpermalink":"/post/upc%E7%BB%84%E9%98%9F%E8%AE%AD%E7%BB%83%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98/","section":"post","summary":"建议自己做一个没有感情的补题机器。","tags":["Solution Report","Bipartite Graph","Think Twice"],"title":"UPC组队训练第十二场补题","type":"post"},{"authors":[],"categories":[],"content":"Girl you gotta love your man Take him by the hand Make him understand The world on you depends Our life will never end ——The Doors《Riders On The Storm》\n jump to content\n因为做第六届的时候对第三方评测产生了怀疑，所以准备先做官网能评测的真题。第十届和第九届的真题在官网上找不到，第八届能找到，先写第八届。\n36进制 题目描述 对于16进制，我们使用字母A-F来表示10及以上的数字。\n如法炮制，一直用到字母Z，就可以表示36进制。\n36进制中，A表示10，Z表示35，AA表示370\n你能算出 MANY 表示的数字用10进制表示是多少吗?\n分析 直接让电脑算吧\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; inline int getNum(char c) { return 10 + c - 'A'; } int main() { cout \u0026lt;\u0026lt; 36 * 36 * 36 * getNum('M') + 36 * 36 * getNum('A') + 36 * getNum('N') + getNum('Y') \u0026lt;\u0026lt; endl; return 0; }  结果是1040254\n瓷砖样式 题目描述 小明家的一面装饰墙原来是 3*10 的小方格。\n现在手头有一批刚好能盖住2个小方格的长方形瓷砖。\n瓷砖只有两种颜色：黄色和橙色。\n小明想知道，对于这么简陋的原料，可以贴出多少种不同的花样来。\n小明有个小小的强迫症：忍受不了任何2*2的小格子是同一种颜色。\n（瓷砖不能切割，不能重叠，也不能只铺一部分。另外，只考虑组合图案，请忽略瓷砖的拼缝）\n显然，对于 2*3 个小格子来说，口算都可以知道：一共10种贴法，如【p1.png所示】\n但对于 3*10 的格子呢？肯定是个不小的数目，请你利用计算机的威力算出该数字。\n分析 题面明示“请你利用计算机的威力算出该数”，暴搜即可。\n注意搜出来的解可能有重复，去重方法是把整个图视为一个字符串，set去重一下即可。\n// // Created by Visors on 2020/11/12. // // 题目名：TODO // 题目来源：TODO // 题目链接：TODO // 算法：CiZhuanYangShi.cpp // 用途：TODO // 时间复杂度：O(TODO) // #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; long long ans = 0; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; G; // 0 empty, 1 yellow, 2 orange bool isOK() { for (int i = 0; i \u0026lt; n - 1; i++) for (int j = 0; j \u0026lt; m - 1; j++) if (G[i][j] == G[i + 1][j] \u0026amp;\u0026amp; G[i][j] == G[i][j + 1] \u0026amp;\u0026amp; G[i][j] == G[i + 1][j + 1]) return false; // for (const auto \u0026amp;i:G) { // for (auto j:i) // cout \u0026lt;\u0026lt; j; // cout \u0026lt;\u0026lt; endl; // } return true; } void dfs(int x, int y) { // cout \u0026lt;\u0026lt; \u0026quot;---------------\\n\u0026quot;; // cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; // 贴黄色 // 横着贴 if (y + 1 \u0026lt; m \u0026amp;\u0026amp; G[x][y + 1] == 0) { G[x][y] = G[x][y + 1] = 1; bool okay = true; for (int i = 0; i \u0026lt; n; i++) { bool flag = false; for (int j = 0; j \u0026lt; m; j++) { if (G[i][j] == 0) { dfs(i, j); okay = false; flag = true; break; } } if (flag) break; } if (okay \u0026amp;\u0026amp; isOK()) ans++; G[x][y] = G[x][y + 1] = 0; } // 竖着贴 if (x + 1 \u0026lt; n \u0026amp;\u0026amp; G[x + 1][y] == 0) { G[x][y] = G[x + 1][y] = 1; bool okay = true; for (int i = 0; i \u0026lt; n; i++) { bool flag = false; for (int j = 0; j \u0026lt; m; j++) { if (G[i][j] == 0) { dfs(i, j); flag = true; okay = false; break; } } if (flag) break; } if (okay \u0026amp;\u0026amp; isOK()) ans++; G[x][y] = G[x + 1][y] = 0; } // 贴橙色 // 横着贴 if (y + 1 \u0026lt; m \u0026amp;\u0026amp; G[x][y + 1] == 0) { G[x][y] = G[x][y + 1] = 2; bool okay = true; for (int i = 0; i \u0026lt; n; i++) { bool flag = false; for (int j = 0; j \u0026lt; m; j++) { if (G[i][j] == 0) { dfs(i, j); flag = true; okay = false; break; } } if (flag) break; } if (okay \u0026amp;\u0026amp; isOK()) ans++; G[x][y] = G[x][y + 1] = 0; } // 竖着贴 if (x + 1 \u0026lt; n \u0026amp;\u0026amp; G[x + 1][y] == 0) { G[x][y] = G[x + 1][y] = 2; bool okay = true; for (int i = 0; i \u0026lt; n; i++) { bool flag = false; for (int j = 0; j \u0026lt; m; j++) { if (G[i][j] == 0) { dfs(i, j); flag = true; okay = false; break; } } if (flag) break; } if (okay \u0026amp;\u0026amp; isOK()) ans++; G[x][y] = G[x + 1][y] = 0; } } int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; G.resize(n, vector\u0026lt;int\u0026gt;(m, 0)); dfs(0, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  不去重结果是105760，正确的去重后的结果是101466，几十秒内应该能跑出来。\n希尔伯特曲线 题目描述 希尔伯特曲线是以下一系列分形曲线 Hn 的极限。我们可以把 Hn 看作一条覆盖 2^n × 2^n 方格矩阵的曲线，曲线上一共有 2^n × 2^n 个顶点(包括左下角起点和右下角终点)，恰好覆盖每个方格一次。\nHn(n \u0026gt; 1)可以通过如下方法构造：\n 将 Hn-1 顺时针旋转90度放在左下角 将 Hn-1 逆时针旋转90度放在右下角 将2个 Hn-1 分别放在左上角和右上角 用3条单位线段把4部分连接起来  对于 Hn 上每一个顶点 p ，我们定义 p 的坐标是它覆盖的小方格在矩阵中的坐标(左下角是(1, 1)，右上角是(2^n, 2^n)，从左到右是X轴正方向，从下到上是Y轴正方向)，定义 p 的序号是它在曲线上从起点开始数第几个顶点(从1开始计数)。\n以下程序对于给定的n(n \u0026lt;= 30)和p点坐标(x, y)，输出p点的序号。请仔细阅读分析源码，填写划线部分缺失的内容。\n#include \u0026lt;stdio.h\u0026gt; long long f(int n, int x, int y) { if (n == 0) return 1; int m = 1 \u0026lt;\u0026lt; (n - 1); if (x \u0026lt;= m \u0026amp;\u0026amp; y \u0026lt;= m) { return f(n - 1, y, x); } if (x \u0026gt; m \u0026amp;\u0026amp; y \u0026lt;= m) { return 3LL * m * m + f(n - 1, ________________ , m * 2 - x + 1); // 填空 } if (x \u0026lt;= m \u0026amp;\u0026amp; y \u0026gt; m) { return 1LL * m * m + f(n - 1, x, y - m); } if (x \u0026gt; m \u0026amp;\u0026amp; y \u0026gt; m) { return 2LL * m * m + f(n - 1, x - m, y - m); } } int main() { int n, x, y; scanf(\u0026quot;%d %d %d\u0026quot;, \u0026amp;n, \u0026amp;x, \u0026amp;y); printf(\u0026quot;%lld\u0026quot;, f(n, x, y)); return 0; }  分析 无论是什么级别的图，横竖对半分成四半后，都满足编号左下\u0026lt;左上\u0026lt;右上\u0026lt;右下，很容易想到分治处理本题。\n读罢代码，可知m表示四分之一区域的边长。第一个if处理的是左下角，第二个if处理的是右下角，那么右下角的编号，显然只需要在已知三个四分之一区域的编号和（$3m^2$）再加上分治求解的部分即可。\n由于右下角的部分是逆时针旋转了90度的结果，传入坐标时我们也变换一下方向。横线处应填m-y+1。\n吐槽 分形之城？？\n发现环 题目描述 小明的实验室有N台电脑，编号1~N。原本这N台电脑之间有N-1条数据链接相连，恰好构成一个树形网络。在树形网络上，任意两台电脑之间有唯一的路径相连。\n不过在最近一次维护网络时，管理员误操作使得某两台电脑之间增加了一条数据链接，于是网络中出现了环路。环路上的电脑由于两两之间不再是只有一条路径，使得这些电脑上的数据传输出现了BUG。\n为了恢复正常传输。小明需要找到所有在环路上的电脑，你能帮助他吗？\n输入 第一行包含一个整数N。\n以下N行每行两个整数a和b，表示a和b之间有一条数据链接相连。\n对于30%的数据，1 \u0026lt;= N \u0026lt;= 1000\n对于100%的数据, 1 \u0026lt;= N \u0026lt;= 100000， 1 \u0026lt;= a, b \u0026lt;= N\n输入保证合法。\n输出 按从小到大的顺序输出在环路上的电脑的编号，中间由一个空格分隔。\n样例输入 5 1 2 3 1 2 4 2 5 5 3  样例输出 1 2 3 5  资源约定 峰值内存消耗 \u0026lt; 256M\nCPU消耗 \u0026lt; 1000ms\n分析 图论水题，记录每个点来时的点，当搜到一个点的非来时点的邻点被访问过时，则出现环，沿着来时点把环记录下来即可。\n参考代码 // // Created by Visors on 2020/11/12. // // 题目名：发现环 // 题目来源：第八届蓝桥杯国赛 // 题目链接：http://lx.lanqiao.cn/problem.page?gpid=T453 // 算法：DFS // 用途：找唯一环 // 时间复杂度：O(n+m) // #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; Edge; vector\u0026lt;Edge\u0026gt; edges; vector\u0026lt;int\u0026gt; heads; vector\u0026lt;int\u0026gt; paths; vector\u0026lt;bool\u0026gt; vis; vector\u0026lt;int\u0026gt; ans; inline void addEdge(int u, int v) { edges.emplace_back(v, heads[u]); heads[u] = edges.size() - 1; } bool flag = false; void dfs(int u) { vis[u] = true; for (int i = heads[u]; ~i; i = edges[i].second) { if (flag) return; int \u0026amp;v = edges[i].first; if (vis[v]) { if (v != paths[u]) { ans.push_back(u); for (int j = paths[u]; j != v; j = paths[j]) ans.push_back(j); ans.push_back(v); flag = true; break; } } else { paths[v] = u; dfs(v); } } } int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; heads.resize(n); vis.resize(n); paths.resize(n); fill(heads.begin(), heads.end(), -1); for (int i = 1, u, v; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--, v--; addEdge(u, v); addEdge(v, u); } dfs(0); sort(ans.begin(), ans.end()); cout \u0026lt;\u0026lt; ans[0] + 1; for (int i = 1; i \u0026lt; ans.size(); i++) cout \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; ans[i] + 1; cout \u0026lt;\u0026lt; endl; return 0; }  对局匹配 题目描述 小明喜欢在一个围棋网站上找别人在线对弈。这个网站上所有注册用户都有一个积分，代表他的围棋水平。\n小明发现网站的自动对局系统在匹配对手时，只会将积分差恰好是K的两名用户匹配在一起。如果两人分差小于或大于K，系统都不会将他们匹配。\n现在小明知道这个网站总共有N名用户，以及他们的积分分别是A1, A2, \u0026hellip; AN。\n小明想了解最多可能有多少名用户同时在线寻找对手，但是系统却一场对局都匹配不起来(任意两名用户积分差不等于K)？\n输入 第一行包含两个个整数N和K。\n第二行包含N个整数A1, A2, \u0026hellip; AN。\n对于30%的数据，1 \u0026lt;= N \u0026lt;= 10\n对于100%的数据，1 \u0026lt;= N \u0026lt;= 100000, 0 \u0026lt;= Ai \u0026lt;= 100000, 0 \u0026lt;= K \u0026lt;= 100000\n输出 一个整数，代表答案。\n样例输入 10 0 1 4 2 8 5 7 1 4 2 8  样例输出 6  再比如，样例输入：\n10 1 2 1 1 1 1 4 4 3 4 4  样例输出：\n8  资源约定 峰值内存消耗 \u0026lt; 256M\nCPU消耗 \u0026lt; 1000ms\n分析 看了下题，想了个解法，觉得复杂度不够，上网看了下题解，没看懂题解和题目之间意思的共通之处，遂放弃。时间不多，先整理几个很久没用的算法和数据结构。\nTable of Contents  36进制  题目描述 分析   瓷砖样式  题目描述 分析   希尔伯特曲线  题目描述 分析 吐槽   发现环  题目描述 分析 参考代码   对局匹配  题目描述 分析     ","date":1605114350,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605114350,"objectID":"302aca386089bdaf240e823226237ad6","permalink":"https://visors.github.io/post/%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","publishdate":"2020-11-12T01:05:50+08:00","relpermalink":"/post/%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","section":"post","summary":"Girl you gotta love your man Take him by the hand Make him understand The world on you depends Our life will never end ——The D","tags":[],"title":"第八届蓝桥杯国赛解题报告","type":"post"},{"authors":["Visors"],"categories":["lanqiao","Solution Report"],"content":"你是太阳 每个人都敬仰 围著你 我变得不一样 彩色希望 燃烧璨亮 我的混沌找到方向 我是冥王 每个人都遗忘 抱著你 我发现我的光 忘掉重量 感情漫长 我的脆弱有你分享 那么坚强 ——林奕匡《冥王星》\n jump to content 最近身体状况不太好，导致干事的热情和效率不是很高，今天突然被告知周末就是蓝桥国赛了，惊地赶紧加班加点做做真题、复习一些知识。虽然今年的省赛让我感觉做往年真题的意义不大（难度不是一个等级的），但是做总比不做要好，就当是一个自我检查，同时严格要求自己不能套板子，必须能按照自己的理解独立写出来。\n积分之谜 问题描述 小明开了个网上商店，卖风铃。共有3个品牌：A，B，C。\n为了促销，每件商品都会返固定的积分。\n小明开业第一天收到了三笔订单：\n第一笔：3个A + 7个B + 1个C，共返积分：315\n第二笔：4个A + 10个B + 1个C，共返积分：420\n第三笔：A + B + C，共返积分\u0026hellip;.\n你能算出第三笔订单需要返积分多少吗？\n请提交该整数，不要填写任何多余的内容。\n分析 这就是个很简单的三元一次方程组，已知两方程，求另一方程的问题。\n设A返积分为$x$，B返积分为$y$，C返积分为$z$，由题意： $$ \\begin{cases} 3x+7y+z=315\\\\\n4x+10y+z=420 \\end{cases}\\Rightarrow x+3y=105\\\n$$ 正好，待求式子： $$ x+y+z=(4x+10y+z)-3(x+3y)=420-3*105=105 $$\n发散 对于线性方程组，还需回顾高斯消元这一知识。可以参考Alex_McAvoy的博客《线性代数 —— 高斯消元法》\n完美正方形 问题描述 如果一些边长互不相同的正方形，可以恰好拼出一个更大的正方形，则称其为完美正方形。\n历史上，人们花了很久才找到了若干完美正方形。比如：如下边长的22个正方形\n2 3 4 6 7 8 12 13 14 15 16 17 18 21 22 23 24 26 27 28 50 60\n如【图1.png】那样组合，就是一种解法。此时，\n紧贴上边沿的是：60 50\n紧贴下边沿的是：26 28 17 21 18\n22阶完美正方形一共有8种。下面的组合是另一种：\n2 5 9 11 16 17 19 21 22 24 26 30 31 33 35 36 41 46 47 50 52 61\n如果告诉你该方案紧贴着上边沿的是从左到右依次为：47 46 61，\n你能计算出紧贴着下边沿的是哪几个正方形吗？\n请提交紧贴着下边沿的正方形的边长，从左到右，用空格分开。\n不要填写任何多余的内容或说明文字。\n分析 开始时试图手玩，然后试着按这种思想操作了一下：\n 边长小的大概率在中间补空 直接挑边界，挑出来的边界应该满足左边和为107，右边和为83，下面的和为154  但是画了会，觉得这样无法确定是否是可行解，而且能够满足上述条件的构造方法也不唯一，就算我得到了下面一行的数，我还是需要判断是否可行，才能确定这几个数的顺序，遂放弃。\n事实上对于填空题而言，能出结果是第一，算法运行效率是其次，只要不慢到出不了结果，最后填上去，都是一样的。那么我们不妨直接暴力解决。\n如果从线段长度（区间来考虑）会很复杂，我们不妨简单点，就把整个图案看成点阵，这样的话，题目中给出的上边沿的正方形的边长是47 46 61这一条件，就可以被解读为我们要对一个154*154的正方形点阵做覆盖，其中上边沿已经覆盖了三个正方形。\n由于最后所有点都会被覆盖，所以我们可以简单的考虑，对任意一个未覆盖的点搜索，依次尝试每一种覆盖情况，最终找到一组合法的解即可。写的时候，完全没必要为了效率而想一些高级方法，比如判断当前位置能不能放特定正方形，只需要两个for遍历检查一下就行了，最大程度减少代码量并避免出错——一旦出错，耗费的Debug时间可不是一会儿半会儿。\n参考代码 // // Created by Visors on 2020/11/10. // // 题目名：完美正方形 // 题目来源：第六届蓝桥杯国赛 // 题目链接：TODO // 算法：WanMeiZhengFangXing.cpp // 用途：TODO // 时间复杂度：O(TODO) // #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int G[154][154]; // 这里的顺序基于我的贪心思想，如果小的正方形放在前面，则搜索树前几层宽度会很大 vector\u0026lt;int\u0026gt; squares{22, 24, 26, 30, 31, 33, 35, 36, 41, 50, 52, 2, 5, 9, 11, 16, 17, 19, 21}; vector\u0026lt;bool\u0026gt; used; // 记录正方形是否被使用过 vector\u0026lt;int\u0026gt; ans; // 记录最后一行答案 bool getAns = false; // 是否找到解 bool checkFill(int x, int y, int len) { // 填进去越界了，肯定不行 if (x + len \u0026gt; 154 || y + len \u0026gt; 154) return false; // 填的正方形位置里有一个被填都不行 for (int i = 0; i \u0026lt; len; i++) for (int j = 0; j \u0026lt; len; j++) if (G[x + i][y + j]) return false; return true; } void dfs(int x, int y) { // cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; if (getAns) return; // 找到答案立即停止搜索 for (int i = 0; i \u0026lt; squares.size(); i++) { if (getAns) break; // 找到答案立即停止搜索 if (!used[i]) { int \u0026amp;len = squares[i]; if (checkFill(x, y, len)) { // 填上 used[i] = true; for (int j = 0; j \u0026lt; len; j++) for (int k = 0; k \u0026lt; len; k++) G[x + j][y + k] = len; // 如果填的最后一行是下沿，丢进ans if (x + len == 154) ans.push_back(len); // 找下一个填的起始位置（从上到下，从左到右） // 直接暴力找，不用优化 bool completed = true, flag = false; for (int j = 0; j \u0026lt; 154; j++) { for (int k = 0; k \u0026lt; 154; k++) if (!G[j][k]) { dfs(j, k); completed = false; flag = true; break; // 别忘了这个break只会跳出内层循环，用下面的flag处理下 } if (flag) break; } if (completed) { getAns = true; break; } if (getAns) break; // 回溯，撤回决策 used[i] = false; for (int j = 0; j \u0026lt; len; j++) for (int k = 0; k \u0026lt; len; k++) G[x + j][y + k] = 0; if (x + len == 154) ans.pop_back(); } } } } int main() { // ios_base::sync_with_stdio(false); // cin.tie(nullptr), cout.tie(nullptr); freopen(\u0026quot;ans.out\u0026quot;, \u0026quot;w\u0026quot;, stdout); used.resize(squares.size()); for (int i = 0; i \u0026lt; 47; i++) for (int j = 0; j \u0026lt; 47; j++) G[i][j] = 47; for (int i = 0; i \u0026lt; 46; i++) for (int j = 47; j \u0026lt; 93; j++) G[i][j] = 46; for (int i = 0; i \u0026lt; 61; i++) for (int j = 93; j \u0026lt; 154; j++) G[i][j] = 61; dfs(46, 47); for (int it:ans) cout \u0026lt;\u0026lt; it \u0026lt;\u0026lt; ' '; cout \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 154; i++) { for (int j = 0; j \u0026lt; 154; j++) printf(\u0026quot;%3d\u0026quot;, G[i][j]); printf(\u0026quot;\\n\u0026quot;); } fclose(stdout); return 0; }  发散 上述代码中，我求得答案为“50 41 33 30”，我在网上看到另一篇博客中给出的答案是“50 33 30 41”，于是加了个文件输出看了一下，我的答案大约的确是对的，也就是说本题可能有多种合法答案。验证这句话有个简单的方法，就是改改我代码里squares中元素的顺序，而不用去严格证明，不过我就懒得去试了。\n这里有高人Lonverce加了线段树优化的版本《( 题解 )第六届蓝桥杯决赛试题 \u0026ndash; 完美正方形 (线段树 + 深搜)》\n关联账户 问题描述 为增大反腐力度，某地警方专门支队，对若干银行账户展开调查。\n如果两个账户间发生过转账，则认为有关联。如果a,b间有关联, b,c间有关联，则认为a,c间也有关联。\n对于调查范围内的n个账户（编号0到n-1），警方已知道m条因转账引起的直接关联。\n现在希望知道任意给定的两个账户，求出它们间是否有关联。有关联的输出1，没有关联输出0\n小明给出了如下的解决方案：\n#include \u0026lt;stdio.h\u0026gt; #define N 100 int connected(int* m, int p, int q) { return m[p]==m[q]? 1 : 0; } void link(int* m, int p, int q) { int i; if(connected(m,p,q)) return; int pID = m[p]; int qID = m[q]; for(i=0; i\u0026lt;N; i++) _____________________________________; //填空位置 } int main() { int m[N]; int i; for(i=0; i\u0026lt;N; i++) m[i] = i; //初始状态，每个节点自成一个连通域 link(m,0,1); //添加两个账户间的转账关联 link(m,1,2); link(m,3,4); link(m,5,6); link(m,6,7); link(m,8,9); link(m,3,7); printf(\u0026quot;%d \u0026quot;, connected(m,4,7)); printf(\u0026quot;%d \u0026quot;, connected(m,4,5)); printf(\u0026quot;%d \u0026quot;, connected(m,7,9)); printf(\u0026quot;%d \u0026quot;, connected(m,9,2)); return 0; }  请分析源代码，并提交划线部分缺少的代码。不要填写已有代码或任何多余内容。\n分析 这个问题拿到手，当然一眼出并查集啦！不过出题人非要给你个思路，让你在上面做文章，那我们先分析下代码中例子的情况：\ngraph LR 0 --- 1 1 --- 2 3 --- 4 5 --- 6 6 --- 7 8 --- 9 3 --- 7  所以首先，我们把代码copy到本地，填完空后，我们输出的结果必须是“1 1 0 0”（填对了一定是这个答案，是这个答案不一定填对了）。\n我们再分析下题目给出的算法，emmm这就是传说中的$O(n)$合并？？对于该算法，每次合并时将所有同集合元素的m更新为相同值，这样查询时只需要$O(1)$判断下两者m值是否相同即可。算法正确性可用归纳法证明。\n按照上述意思，补全的代码应该是if (connected(m, pID, i) m[i] = qID\n密文搜索 问题描述 福尔摩斯从X星收到一份资料，全部是小写字母组成。\n他的助手提供了另一份资料：许多长度为8的密码列表。\n福尔摩斯发现，这些密码是被打乱后隐藏在先前那份资料中的。\n请你编写一个程序，从第一份资料中搜索可能隐藏密码的位置。要考虑密码的所有排列可能性。\n数据格式 输入第一行：一个字符串s，全部由小写字母组成，长度小于1024*1024\n紧接着一行是一个整数n,表示以下有n行密码，1\u0026lt;=n\u0026lt;=1000\n紧接着是n行字符串，都是小写字母组成，长度都为8\n要求输出 一个整数, 表示每行密码的所有排列在s中匹配次数的总和。\n例如 用户输入：\naaaabbbbaabbcccc 2 aaaabbbb abcabccc  则程序应该输出：\n4  这是因为：第一个密码匹配了3次，第二个密码匹配了1次，一共4次。\n资源约定 峰值内存消耗 \u0026lt; 512M\nCPU消耗 \u0026lt; 3000ms\n分析 讲实在话，这题看了半天没看懂意思，第一个密码怎么匹配了3次？“要考虑密码的所有排列可能性”是什么意思？可能语文不好不配打蓝桥= =\n在网上看了下别人的代码，才知道原来意思是对于s中任意长度为8的子串，判断其排列后能得到给定密码的数目和（这tm……我直接迷惑）。\n法一 Brute Force 我们可以枚举s中每一个长度为8的子串，然后统计串中各字符出现次数。对于任意密码，逐一检查密码中的字符个数与子串字符个数是否匹配，匹配答案就+1。这样的复杂度是$O(n*s.length)$，显然会T一些点。\n因为BF很不优雅还不能把分拿满，这里就不写了。\n法二 算术基本定理+Hash 根据算术基本定理，任何一个大于1的自然数都能被分为有限个质数之积（或者它本身就是质数），且这个分解是唯一的。\n根据这一定理，我们很容易想到，如果让每个字母表示不同的质数，那么整个字符串就能被Hash为其质数积，这样的Hash方法是不会有冲突的，因为分解是唯一的，所以不会有两个不一样的串Hash值相同。\n那么我们就设\u0026rsquo;a'\u0026lsquo;b'\u0026lsquo;c\u0026rsquo;等字符为前26个质数，然后对原串s中所有的长度为8的子串Hash后记录在map里。然后每度入一个密码，累加改Hash值出现的次数即可，算法复杂度为$O(s.length*\\log(s.legnth)+nlog(s.length))$。子串长度只有8，所以Hash值也不会爆long long（第26个素数是101）。\n参考代码 // // Created by Visors on 2020/11/11. // // 题目名：密文搜索 // 题目来源：第六届蓝桥杯国赛 // 题目链接：https://www.dotcpp.com/oj/problem1828.html // 算法：算术基本定理+Hash // 用途：TODO // 时间复杂度：$O(s.length*\\log(s.legnth)+nlog(s.length))$ // #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; value{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101}; unordered_map\u0026lt;long long, int\u0026gt; book; string s, t; int n, ans = 0; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; s; // 题目没有明说s长度范围，所以特判一下 if (s.length() \u0026gt;= 8) { long long mul = 1; for (int i = 0; i \u0026lt; 8; i++) mul *= value[s[i] - 'a']; book[mul]++; for (int i = 8; i \u0026lt; s.length(); i++) { // 一除一乘，优化常数 mul /= value[s[i - 8] - 'a']; mul *= value[s[i] - 'a']; book[mul]++; } } cin \u0026gt;\u0026gt; n; while (n--) { cin \u0026gt;\u0026gt; t; if (s.length() \u0026lt; 8) continue; long long mul = 1; for (char c:t) mul *= value[c - 'a']; ans += book[mul]; } if (s.length() \u0026lt; 8) cout \u0026lt;\u0026lt; \u0026quot;0\\n\u0026quot;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  吐槽 这个题面真的神了，“这些密码是被打乱后隐藏在先前那份资料中的”让我以为这题是对给出的所有密码找到最大不冲突匹配数。\n然后这个乱序到底是取子串还是子序列，也没有说明白。我觉得既然都打乱了应该就是子序列吧，结果博客里面都是直接当作子串写的，莽一发直接过了。\n可能是五年前蓝桥题目质量还不够好吧……\n居民集会 题目描述 蓝桥村的居民都生活在一条公路的边上，公路的长度为L，每户家庭的位置都用这户家庭到公路的起点的距离来计算，第i户家庭距起点的距离为di。\n每年，蓝桥村都要举行一次集会。今年，由于村里的人口太多，村委会决定要在4个地方举行集会，其中3个位于公路中间，1个位最公路的终点。\n已知每户家庭都会向着远离公路起点的方向去参加集会，参加集会的路程开销为家庭内的人数ti与距离的乘积。\n给定每户家庭的位置di和人数ti，请为村委会寻找最好的集会举办地：p1, p2, p3, p4 (p1\u0026lt;=p2\u0026lt;=p3\u0026lt;=p4=L),使得村内所有人的路程开销和最小。\n输入格式 输入的第一行包含两个整数n, L，分别表示蓝桥村的家庭数和公路长度。\n接下来n行，每行两个整数di, ti，分别表示第i户家庭距离公路起点的距离和家庭中的人数。\n输出格式 输出一行，包含一个整数，表示村内所有人路程的开销和。\n样例输入 6 10 1 3 2 2 4 5 5 20 6 5 8 7  样例输出 18  样例说明 在距起点2, 5, 8, 10这4个地方集会，6个家庭需要的走的距离分别为1, 0, 1, 0, 2, 0，总的路程开销为1*3+0*2+1*5+0*20+2*5+0*7=18。\n数据规模与约定 对于10%的评测数据，1\u0026lt;=n\u0026lt;=300。\n对于30%的评测数据，1\u0026lt;=n\u0026lt;=2000，1\u0026lt;=L\u0026lt;=10000，0\u0026lt;=di\u0026lt;=L，di\u0026lt;=di+1，0\u0026lt;=ti\u0026lt;=20。\n对于100%的评测数据，1\u0026lt;=n\u0026lt;=100000，1\u0026lt;=L\u0026lt;=1000000，0\u0026lt;=di\u0026lt;=L，di\u0026lt;=di+1，0\u0026lt;=ti\u0026lt;=1000000。\n资源约定 峰值内存消耗 \u0026lt; 512M\nCPU消耗 \u0026lt; 5000ms\n分析 显然，题目中的p1,p2,p3应在三个不同的家庭处，那么BF枚举三个点的位置再加上前缀和优化，就能$O(n^3)$求解，但这个复杂度太差了。\n前缀和如何优化？如果你把居民从家走到集会点看成从家走到p4，再减去p4到其集会点的距离，则对于划分出的一个区间，其减去的值的和应为区间内的人数（前缀和处理）*l-集会点距起点的距离。\n因着这个，我跟队友讨论了下，莽了个假算法：先枚举p2，然后在左右区间分别三分找p1和p2。交了一下WA了，似乎两遍区间内函数并不是单峰函数，这个算法有问题，不过可以过部分点。不过由于不是官方评测，可能数据有问题，毕竟过的人数只有个位数……\n参考代码 // // Created by Visors on 2020/11/11. // // 题目名：居民集会 // 题目来源：第六届蓝桥杯国赛 // 题目链接：https://www.dotcpp.com/oj/problem1829.html // 算法：JuMinJiHui.cpp // 用途：TODO // 时间复杂度：O(TODO) // #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n, l; set\u0026lt;int\u0026gt; s; vector\u0026lt;pii\u0026gt; families; vector\u0026lt;ll\u0026gt; preSum; int p1, p2, p3; inline ll getPreSum(int left, int right) { return preSum[right + 1] - preSum[left]; } inline ll f1(int x) { return getPreSum(0, x) * (l - families[x].first) + getPreSum(x + 1, p2) * (l - families[p2].first); } inline ll f2(int x) { return getPreSum(p2 + 1, x) * (l - families[x].first); } int sanfen1(int left, int right) { while (left \u0026lt; right - 1) { int mid1 = (left + right) / 2, mid2 = (mid1 + right) / 2; if (f1(mid1) \u0026gt; f1(mid2)) right = mid2; else left = mid1; } return f1(left) \u0026gt; f1(right) ? left : right; } int sanfen2(int left, int right) { while (left \u0026lt; right - 1) { int mid1 = (left + right) / 2, mid2 = (mid1 + right) / 2; if (f2(mid1) \u0026gt; f2(mid2)) right = mid2; else left = mid1; } return f2(left) \u0026gt; f2(right) ? left : right; } int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; l; families.resize(n); preSum.resize(n + 1); for (pii \u0026amp;it:families) { cin \u0026gt;\u0026gt; it.first \u0026gt;\u0026gt; it.second; s.insert(it.first); } if (s.size() \u0026lt;= 3) { cout \u0026lt;\u0026lt; \u0026quot;0\\n\u0026quot;; return 0; } sort(families.begin(), families.end()); preSum[0] = 0; for (int i = 1; i \u0026lt;= n; i++) preSum[i] = preSum[i - 1] + families[i - 1].second; ll Sum = 0; for (pii it:families) Sum += (l - it.first) * it.second; ll ans = 0x3f3f3f3f3f3f3f3f; for (int i = 1; i \u0026lt; n - 1; i++) { p2 = i; p1 = sanfen1(0, p2 - 1); p3 = sanfen2(p2 + 1, n - 1); ans = min(ans, Sum - f1(p1) - f2(p3)); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  发散 更好的写法是DP，这个DP并不难想，不过不知道为什么当初讨论着讨论着就开始三分了，可能是因为我们都想把分拿满吧。经过前缀和优化后，DP可以$O(n^2)$出解，有大佬指出该DP可以斜率优化，不过我不懂……\n名道《15年国赛 居民集会》\n模型染色 题目描述 在电影《超能陆战队》中，小宏可以使用他的微型机器人组合成各种各样的形状。\n现在他用他的微型机器人拼成了一个大玩具给小朋友们玩。为了更加美观，他决定给玩具染色。\n小宏的玩具由n个球型的端点和m段连接这些端点之间的边组成。下图给出了一个由5个球型端点和4条边组成的玩具，看上去很像一个分子的球棍模型。\n由于小宏的微型机器人很灵活，这些球型端点可以在空间中任意移动，同时连接相邻两个球型端点的边可以任意的伸缩，这样一个玩具可以变换出不同的形状。在变换的过程中，边不会增加，也不会减少。\n小宏想给他的玩具染上不超过k种颜色，这样玩具看上去会不一样。如果通过变换可以使得玩具变成完全相同的颜色模式，则认为是本质相同的染色。现在小宏想知道，可能有多少种本质不同的染色。\n输入格式 输入的第一行包含三个整数n, m, k，\n分别表示小宏的玩具上的端点数、边数和小宏可能使用的颜色数。端点从1到n编号。\n接下来m行每行两个整数a, b，表示第a个端点和第b个端点之间有一条边。输入保证不会出现两条相同的边。\n输出格式 输出一行，表示本质不同的染色的方案数。由于方案数可能很多，请输入方案数除10007的余数。\n样例输入 3 2 2 1 2 3 2  样例输出 6  样例说明 令(a, b, c)表示第一个端点染成a，第二个端点染成b，第三个端点染成c，则下面6种本质不同的染色：(1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 2, 2), (2, 1, 2), (2, 2, 2)。\n而(2, 1, 1)与(1, 1, 2)是本质相同的，(2, 2, 1)与(2, 1, 2)是本质相同的。\n数据规模与约定 对于20%的评测数据，1\u0026lt;=n\u0026lt;=5， 1\u0026lt;=k\u0026lt;=2。\n对于50%的评测数据，1\u0026lt;=n\u0026lt;=10, 1\u0026lt;=k\u0026lt;=8。\n对于100%的评测数据，1\u0026lt;=n\u0026lt;=10, 1\u0026lt;=m\u0026lt;=45, 1\u0026lt;=k\u0026lt;=30。\n资源约定 峰值内存消耗 \u0026lt; 512M\nCPU消耗 \u0026lt; 5000ms\n分析 我只会暴力……大佬说用Polya定理，虽然以前接触过，不过已经忘干净了……\n名道《15年国赛 模型染色》\n后记 这么看上去国赛大题想拿满分并不简单，不知道到时候同台竞技的人水平如何，突然有一点小虚。\nTable of Contents  积分之谜  问题描述 分析 发散   完美正方形  问题描述 分析 参考代码 发散   关联账户  问题描述 分析   密文搜索  问题描述 分析 参考代码 吐槽   居民集会  题目描述 分析 参考代码 发散   模型染色  题目描述 分析   后记   ","date":1605009211,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1605009211,"objectID":"77dea68e4b1014ebb0a5f92ff671feff","permalink":"https://visors.github.io/post/%E7%AC%AC%E5%85%AD%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","publishdate":"2020-11-10T19:53:31+08:00","relpermalink":"/post/%E7%AC%AC%E5%85%AD%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","section":"post","summary":"你是太阳 每个人都敬仰 围著你 我变得不一样 彩色希望 燃烧璨亮 我的混","tags":["lanqiao","Solution Report"],"title":"第六届蓝桥杯国赛解题报告","type":"post"},{"authors":["Visors"],"categories":["Graph Theory"],"content":"我知 一雙手 只要握成拳頭 能捱下去 哪怕我 面容極蒼白 拒絕疲累 追 追不到 也得追 成就最渺小的壯舉 一雙手 可以不求人 頑強面對 這世界 絕情又刻薄 照樣無懼 當 天開眼 暖風吹 雲霧會散開 給我堡壘 ——林奕匡《壹雙手》\n 状态与图 一个小插曲 学习动态规划时，我们一定会接触到一个概念——状态。\n","date":1604926194,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604926194,"objectID":"4cf1ac116f9750232f9f5c78890c0919","permalink":"https://visors.github.io/post/%E5%88%86%E5%B1%82%E5%9B%BE%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/","publishdate":"2020-11-09T20:49:54+08:00","relpermalink":"/post/%E5%88%86%E5%B1%82%E5%9B%BE%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/","section":"post","summary":"我知 一雙手 只要握成拳頭 能捱下去 哪怕我 面容極蒼白 拒絕疲累 追 追不","tags":["Graph Theory"],"title":"分层图思想及其处理方法","type":"post"},{"authors":["Visors"],"categories":["Graph Theory"],"content":"ただ ひたすらなその思い 孤独な闇をいつか 照らすだろう ——《3びきのくま》\n Tarjan求割点的方法已经在《Tarjan求无向图割点》中介绍了，不清楚的读者可以先行阅读那部分内容，这里直接分析求割点所割连通分量数的方法。\n 前面介绍Tarjan算法时，我们介绍了无向图的搜索树的概念。那时，我们从形状的角度感性认识了Tarjan算法的正确性，事实上，对于$low$的实际意义，我们可以更进一步地思考一下，首先回顾下$low$的求法：\n考虑这样的点：\n 存在非搜索树上的边$(u,v)$的$v$点 在回溯前能访问到的最早的点，即搜索树中以$u$为根的子树上的点能访问到的最早的点  找出这些点中的最小的时间戳，即为我们能追溯到的最早节点，我们称之为追溯值$low$。\n注意上述定义中，对于点$u$，在考虑第一种点时，我们只需考虑其$dfn$即可，而对于第二种点，我们需要在递归过程中考虑其子节点的$low$才行。对于该子树上一叶子$a$，显然其无子节点，若要更新其$low$，必然有非搜索树上的边$(a,b)$，使得$low[a] = dfn[b]$，否则$low[a]=dfn[a]$。继续向上考虑，若一个节点在回溯前每个点都无非搜索树上的边，则其$low = dfn$。换言之，一旦一个节点的$low\\neq dfn$，则其子树上必有一点存在不在搜索树上的边。顺着这个思路往下想，由于这是一个递归过程，所以当递归回溯到$u$的邻点$v$时，$low[v]$应当为其子树中所有节点最小的$low$，亦即能追溯到的最早的点。若$low[v]\\neq dfn[v]$，则一定存在某个子节点有一条连向时间戳为$low[v]$的点，那么形状准确来说应该类似下图：\ngraph LR A((A)) B((B)) C((C)) D((D)) E((E)) F((F)) A --- B B === C C --- D D --- E D --- F F -.- C  上图是一个缩略的图模型，意思指C的子树中有最早能追溯到C的点F，同时B点到C点间所有的点都仅为一条链。此时B到C上任意一点都为割点，删去其中任意一个点都将使其后搜索树上的子图成为一个新的连通子图。\n这里直接给出我们在删去割点的时候的判断标准：\n对于一个非搜索树根节点$u$，其有$k$个满足$dfn[u]\\leq low[v]$的搜索树上的子节点$v$，则删去$u$后将生成$k+1$个互不连通的子图。\n这个道理很简单，删去割点，每个满足$dfn[u]\\leq low[v]$的节点所在的子树自成一个个连通子图，$u$祖先方向的节点自成一个连通子图。\n换言之，每有一个满足$dfn[u]\\leq low[v]$的子节点$v$，则删去$u$后会使连通子图数$+1$.为什么这些满足$dfn[u]\\leq low[v]$的点对新生成互不连通子图的贡献不会重复呢？可以这么证明：\n若存在$u$的邻点$a$和$b$，满足$dfn[u]\\leq low[a]$和$dfn[u]\\leq low[b]$，可以假设$a$、$b$连通，那么删去$u$后，$a$和$b$同属一个连通子图，答案只增加1。但事实上，在上述假设情况下，当我们递归访问$a$（假设优先遍历$a$）时，就会遍历到$b$，并为其打上时间戳、求出回溯值，他们在搜索树上属于祖先和后代的关系，那么删去根$u$，显然只会产生多个互不连通的子图，但同时$b$并非$u$邻点，这与假设相悖。所以上述结论得证。\n但有一个特殊的情况需要注意，如果删除的$u$是整个搜索树的树根，则其没有祖先方向的节点，这样就会少一个连通子图。总结一下就是：\n对于点$u$：\n $u$不是割点，则删去它不会增加互不连通子图的数目。 $u$是割点，假设其满足$dfn[u]\\leq low[v]$的邻点$v$有$k$个：  若$u$是搜索树根，则删去$u$后，互不连通子图数目增加$k-1$。 若$u$不是搜索树根，则删去$u$后，互不连通子图数目增加$k$。    参考实现 // // Created by Visors on 2020/10/25. // // 题目名：Router Mesh // 题目来源：2020ICPC·小米 网络选拔赛第一场 // 题目链接：https://ac.nowcoder.com/acm/contest/7501/D // 算法：Tarjan // 用途：求割点所割连通分量数 // 时间复杂度：O(n+m) // #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int block = 0; struct Tarjan { struct Edge { int to, next; Edge() = default; Edge(int to, int next) : to(to), next(next) {} }; int vertexNum{}, edgeNum{}; int cnt{}; // 当前时间戳 int root{}; // 保存当前搜索树根 vector\u0026lt;Edge\u0026gt; edges; vector\u0026lt;int\u0026gt; heads; vector\u0026lt;int\u0026gt; dfn; // 时间戳 vector\u0026lt;int\u0026gt; low; // 最早追溯时间 vector\u0026lt;bool\u0026gt; isCut; // 割点 vector\u0026lt;int\u0026gt; branches; // 分支数 void init(int n, int m) { cnt = 0; vertexNum = n; edgeNum = m; heads.resize(vertexNum); fill(heads.begin(), heads.end(), -1); dfn.resize(vertexNum); low.resize(vertexNum); isCut.resize(vertexNum); branches.resize(vertexNum); } void addEdge(int u, int v) { edges.emplace_back(v, heads[u]); heads[u] = edges.size() - 1; } void dfs(int u) { dfn[u] = low[u] = ++cnt; int tot = 0; for (int i = heads[u]; ~i; i = edges[i].next) { int \u0026amp;v = edges[i].to; if (!dfn[v]) { dfs(v); low[u] = min(low[u], low[v]); if (low[v] \u0026gt;= dfn[u]) { tot++; if (u != root || tot \u0026gt; 1) isCut[u] = true; // 对树根特判 } } else low[u] = min(low[u], dfn[v]); } if (u != root) tot++; branches[u] = tot; } void run() { for (int i = 0; i \u0026lt; vertexNum; i++) if (!dfn[i]) { root = i; block++; dfs(i); } } } tarjan; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; tarjan.init(n, m); for (int i = 1, u, v; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--, v--; tarjan.addEdge(u, v); tarjan.addEdge(v, u); } tarjan.run(); cout \u0026lt;\u0026lt; block + tarjan.branches[0] - 1; for (int i = 1; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; block + tarjan.branches[i] - 1; cout \u0026lt;\u0026lt; endl; return 0; }  后记 比赛的时候不知道从哪看的找值不同的$low$数目是真的煞笔，然后煞笔的我就真的按这个思路交了十发，全WA。\n","date":1604112886,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604112886,"objectID":"fed1e28f187917dcd49bf3e79ee5cd1f","permalink":"https://visors.github.io/post/tarjan%E6%B1%82%E5%89%B2%E7%82%B9%E6%89%80%E5%89%B2%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E6%95%B0/","publishdate":"2020-10-31T10:54:46+08:00","relpermalink":"/post/tarjan%E6%B1%82%E5%89%B2%E7%82%B9%E6%89%80%E5%89%B2%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E6%95%B0/","section":"post","summary":"Tarjan求割点的方法已经在《Tarjan求无向图割点》中介绍了，不清楚的读者可以先行阅读那部分内容，这里直接分析求割点所割连通分量数的方法。","tags":["Graph Theory","Tarjan"],"title":"Tarjan求割点所割连通分量数","type":"post"},{"authors":["Visors"],"categories":["Graph Theory"],"content":"さざ波のラインダンス 時間だけこわれてく まなざしのボルテージ 熱くしながら 君に胸キュン 夏の印画紙 太陽だけ焼きつけて 君に胸キュン ぼくはと言えば 柄にもなくプラトニック 心の距離を計る 罪つくりな潮風 眼を伏せた一瞬の せつなさがいい ——YMO《君に、胸キュン。-浮気なヴァカンス-》\n Tarjan算法的核心思想已经在《Tarjan求无向图割边》中介绍了，不清楚的读者可以先行阅读那部分内容，这里直接从介绍割点开始。\n无向图的割点及判定 .\n对于无向连通图$G(V,E)$，若删去点$v\\in V$及其邻边$\\forall u\\in {V-v}, (v,u)\\in E$后，$G$被分为两个或更多互不连通的子图，则称$v$为割点或割顶。\n根据上面$dfn$和$low$，很容易能想出割边的方法——无向边$(u,v)$是割边，当且仅当搜索树上存在$u$的一个子节点$v$，满足：\n$$dfn[u]\\leq low[v]$$\n如果不明白上式，可以参考之前文章中抽象的三种图形。当$dfn[u]=low[v]$时，两条链合起来状似闭环，此时无割边，但两条链$dfn$最小的咬合点显然是割点。\n特别的，对于我们搜索的起点，上述判定方法还需限定条件，先来看一个反例：\ngraph LR A((1/1)) B((2/1)) C((3/1)) D((4/1)) A === B B === C C === D D --- A  上图中，有唯一满足$dfn[u]\\leq low[v]$的$(1,2)$，但去掉$1$后，剩余图为：\ngraph LR B((2)) C((3)) D((4)) B --- C C --- D  并没有被分为两个或以上的互不连通子图，所以这里搜索起点$1$尽管满足上面的判别式，但并不是割点。\n是不是所有的搜索起点都不是割点呢？提出这个问题固然在思考，但细想却很好笑——任意点都能作为搜索起点，如果这句话成立，则任意点都不是割点。\n对搜索起点的处理 如果搜索起点有两个以上的子树，则意味着在搜索树上，根结点出度为二或以上。根据树的性质，如果我们删去根节点及其邻边，则原树将裂解成子树个数个互不连通的树。若不明白，任意找几棵树观察便知。\n要在代码中实现上述判断，可记录从根节点出发的邻点调用的DFS次数即可，伪代码如下：\nint children = 0; for (int v: G[u]) { if (!vis[v]) { children++; dfs(v); } } if (children \u0026gt;= 2) u是割点  对重边的处理 对割点问题而言，删去割点将会将所有相邻的重边删去，所以割点问题并不受重边影响。\n参考实现 // // Created by Visors on 2020/10/29. // // 题目名：P3388 【模板】割点（割顶） // 题目来源：luogu // 题目链接：https://www.luogu.com.cn/problem/P3388 // 算法：Tarjan // 用途：无向图割点 // 时间复杂度：O(n+m) // #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Tarjan { struct Edge { int to, next; Edge() = default; Edge(int to, int next) : to(to), next(next) {} }; int vertexNum{}, edgeNum{}; int cnt{}; // 当前时间戳 int root{}; // 保存当前搜索树根 vector\u0026lt;Edge\u0026gt; edges; vector\u0026lt;int\u0026gt; heads; vector\u0026lt;int\u0026gt; dfn; // 时间戳 vector\u0026lt;int\u0026gt; low; // 最早追溯时间 set\u0026lt;int\u0026gt; cuts; // 割点编号集 void init(int n, int m) { cnt = 0; vertexNum = n; edgeNum = m; heads.resize(vertexNum); fill(heads.begin(), heads.end(), -1); dfn.resize(vertexNum); low.resize(vertexNum); cuts.clear(); } void addEdge(int u, int v) { edges.emplace_back(v, heads[u]); heads[u] = edges.size() - 1; } void dfs(int u) { dfn[u] = low[u] = ++cnt; int tot = 0; for (int i = heads[u]; ~i; i = edges[i].next) { int \u0026amp;v = edges[i].to; if (!dfn[v]) { dfs(v); low[u] = min(low[u], low[v]); if (low[v] \u0026gt;= dfn[u]) { tot++; if (u != root || tot \u0026gt; 1) cuts.insert(u); // 对树根特判 } } else low[u] = min(low[u], dfn[v]); } } void run() { for (int i = 0; i \u0026lt; vertexNum; i++) if (!dfn[i]) { root = i; dfs(i); } } } tarjan; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; tarjan.init(n, m); for (int i = 1, u, v; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (u == v) continue; u--, v--; tarjan.addEdge(u, v); tarjan.addEdge(v, u); } tarjan.run(); cout \u0026lt;\u0026lt; tarjan.cuts.size() \u0026lt;\u0026lt; endl; bool first = true; for (int it:tarjan.cuts) if (first) { cout \u0026lt;\u0026lt; it + 1; first = false; } else cout \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; it + 1; cout \u0026lt;\u0026lt; endl; return 0; }  ","date":1603938498,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603938498,"objectID":"4904f4d6dbc2c43cf303877361d779a7","permalink":"https://visors.github.io/post/tarjan%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E7%82%B9/","publishdate":"2020-10-29T10:28:18+08:00","relpermalink":"/post/tarjan%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E7%82%B9/","section":"post","summary":"Tarjan算法的核心思想已经在《Tarjan求无向图割边》中介绍了，不清楚的读者可以先行阅读那部分内容，这里直接从介绍割点开始。","tags":["Graph Theory","Tarjan"],"title":"Tarjan求无向图割点","type":"post"},{"authors":["Visors"],"categories":["Graph Theory"],"content":"There's nothing in your eyes That marks where you cried All is blank all is blind Dead inside the inner mind ——YMO《Behind The Mask》\n Tarjan算法 不得不说Robert Tarjan真的是大师，发个网站大家感受一下——论文索引。\n这里要说的Tarjan算法用于解决无向图的连通性，学习之前，先了解两个概念。\n无向连通图的搜索树 当我们遍历一个无向连通图时，显然一个点只会被访问一次，而访问一个点的方法是从一个当前已访问的点$u$，沿着它的邻边走向未访问过的点$v$，则对于任意非遍历起点，其都唯一对应一条边$(u,v)$，这些边恰巧构成一棵树（深究其证明，可考虑将$(u,v)$视为有向边，则非起点入度为$1$，起点入度为$0$），我们称之为无向连通图的搜索树。\n由于DFS序不唯一，所以搜索树也不唯一。若按节点编号顺序遍历图，则搜索树如下图中加粗部分：\ngraph LR A((A)) B((B)) C((C)) D((D)) E((E)) A === B A --- C B === C B --- D C === D C === E  时间戳dfn 按照DFS的先后顺序，我们可以为每个节点定义一个访问时间，其为该点在DFS序中的下标，我们称之为时间戳。对于上图，DFS序为$ABCDE$，则若从$1$开始标记时间，则各点时间戳为：\ngraph LR A((1)) B((2)) C((3)) D((4)) E((5)) A === B A --- C B === C B --- D C === D C === E  追溯值low 当DFS序不同时，我们对节点标记的$dfn$也不尽相同，例如上图稍加改变，即可得到：\ngraph LR A((1)) B((2)) C((4)) D((3)) E((5)) A === B A --- C B --- C B === D C === D C === E  所以单纯考虑dfn似乎没什么意义。\n我们考虑这样一个事实：若一个点$u$存在非搜索树上的邻边$(u,v)$，且$dfn(u)\u0026gt;dfn(v)$，则显然遍历到点$v$（先于$u$）时，如果我们先走$(u,v)$，那么$dfn(u)$将减小为$dfn(v)+1$。\n 更准确地说，若一个点$u$存在不在搜索树上的邻边$(u,v)$，则必然有$dfn(u)\u0026gt;dfn(v)$，读者可以思考下为什么。\n 那么，对任一点而言，我们将所有可优化的边枚举出来，则其中存在一个最小的优化值，但这个值是我们可以优化到的最小时间戳吗？并非如此，我们对上图稍作改动：\ngraph LR A((1)) B((3)) C((5)) D((4)) E((6)) F((2)) A === F F === B A --- E B --- C B === D C === D C === E  可以发现，当我们DFS到$6$时，我们有非搜索树上的邻边指向$1$，则$6$的$dfn$事实上可以被优化为$2$，当回溯到$5$时，我们发现$5$有非搜索树上的邻边指向$3$，则$5$的$dfn$可被优化为$4$。但由于我们是从$6$开始回溯的，既然$6$能被优化为$2$，那么$5$肯定能被优化到$3$。\n但这样还是无法避免因为DFS序不同产生的不唯一性问题，不过上述思考给我们指明了一个方向——我们不妨试着找到任意点能回溯到的最早的点的时间戳。与上面过程类似，对于任意点$u$，我们只需考虑这样的点：\n 存在非搜索树上的边$(u,v)$的$v$点 在回溯前能访问到的最早的点，即搜索树中以$u$为根的子树上的点能访问到的最早的点  找出这些点中的最小的时间戳，即为我们能追溯到的最早节点，我们称之为追溯值$low$。则依上述定义，我们可求得上图追溯值（A/B表示时间戳为A，追溯值为B）：\ngraph LR A((1/1)) B((3/1)) C((5/1)) D((4/1)) E((6/1)) F((2/1)) A === F F === B A --- E B --- C B === D C === D C === E  我们发现上图各点都能追溯到$1$，若变换下例子：\ngraph TB 1((1/1)) 2((2/1)) 3((3/1)) 4((4/1)) 5((5/1)) 6((6/6)) 7((7/7)) 8((8/6)) 9((9/6)) 1 === 2 2 === 3 3 === 4 4 === 5 2 --- 5 1 --- 5 1 -.- 6 6 -.- 7 6 === 8 6 --- 9 8 === 9  无向图的割边及判定 对于无向连通图$G(V,E)$，若删去边$e\\in E$后，$G$被分为两个不连通的子图，则称$e$为割边或桥。\n根据上面$dfn$和$low$，很容易能想出割边的方法——无向边$(u,v)$是割边，当且仅当搜索树上存在$u$的一个子节点$v$，满足：\n$$dfn[u]\u0026lt;low[v]$$\n如果不明白上式，可以想象，$dfn[u]$指代了一条从起点到$u$的搜索树链，而$low[v]$代表了一条从$v$到$low[v]$对应的点的回溯链。那么若$dfn[u]\u0026lt;low[v]$，则这两条链相连状似一条穿起来的皮带（加粗部分），那么删掉皮带多出来的那一截中的任意一条边，都能使将原图分为两个不连通的子图（后面的点都无法追溯到$u$）：\ngraph LR s((s)) a((a)) b((b)) u((u)) v((v)) s --- u u === v v === a a === b b === v  若$dfn[u]=low[v]$，则状似闭环：\ngraph LR s((s)) a((a)) u((u)) v((v)) s --- u u === v v === a a === u  若$dfn[u]\u0026gt;low[v]$，则状似未穿起的皮带：\ngraph LR s((s)) a((a)) b((b)) u((u)) v((v)) s --- u u === v v === a a === b b === s  是不是形象了很多？当然，这只是个辅助记忆的可爱的例子，因为如果从递归的最远的节点开始，存在无非搜索树上邻边的点，则上图两条链应当在某些部分重合。但在割边附近，都能形成状似上面三种情况的图形，单链除外：\ngraph LR s((s)) u((u)) a((a)) b((b)) v((v)) t((t)) s --- u u --- a a --- b b --- v v --- t  上图中显然任意一条边都为割边。\n对重边的处理 显然，当图中存在重边时，我们上面的$low$值求法存在问题，若仅考虑符合条件的两种点，即使存在重边，求得的$low$也不会变化，然而显然下图并不存在割边：\ngraph LR A((A)) B((B)) C((C)) D((D)) A --- B A --- B B --- C C --- D D --- B  若不做一些处理，则会得到存在割边$(A,B)$的错误答案。\n一个可行的方法是——每个点的访问情况仅用于控制不重复遍历点，更新$low$值时转而考虑每条边是否访问过，如果存在未访问过的非搜索树上的边，更新其$low$即可。\n这里有必要对每条边做标记处理吗？显然不用。\n由于我们搜索时形成的是一棵树，那么我们在从节点$u$搜得邻点$v$时，纵使$(u,v)$可能不唯一，但真正访问的$(u,v)$有且仅有一条，当我们回溯时，仅需避开这条边的反向边（^1）即可。因此，我们可以在DFS函数中加一参数，用于记录走到当前节点来时的边的编号。\n参考实现 // // Created by Visors on 2020/10/27. // // 题目名：T103481 【模板】割边 // 题目来源：luogu // 题目链接：https://www.luogu.com.cn/problem/T103481 // 算法：Tarjan // 用途：无向图割边 // 时间复杂度：O(n+m) // #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Tarjan { struct Edge { int to, next; Edge() = default; Edge(int to, int next) : to(to), next(next) {} }; int vertexNum{}, edgeNum{}; int cnt{}; // 当前时间戳 vector\u0026lt;Edge\u0026gt; edges; vector\u0026lt;int\u0026gt; heads; vector\u0026lt;int\u0026gt; dfn; // 时间戳 vector\u0026lt;int\u0026gt; low; // 最早追溯时间 vector\u0026lt;int\u0026gt; bridges; // 桥边编号集 void init(int n, int m) { cnt = 0; vertexNum = n; edgeNum = m; heads.resize(vertexNum); fill(heads.begin(), heads.end(), -1); dfn.resize(vertexNum); low.resize(vertexNum); bridges.clear(); } void addEdge(int u, int v) { edges.emplace_back(v, heads[u]); heads[u] = edges.size() - 1; } void dfs(int u, int inEdge) { dfn[u] = low[u] = ++cnt; for (int i = heads[u]; ~i; i = edges[i].next) { int \u0026amp;v = edges[i].to; if (!dfn[v]) { dfs(v, i); low[u] = min(low[u], low[v]); if (low[v] \u0026gt; dfn[u]) bridges.push_back(i); } else if (i != (inEdge ^ 1)) low[u] = min(low[u], dfn[v]); } } void run() { for (int i = 0; i \u0026lt; vertexNum; i++) if (!dfn[i]) dfs(i, -1); } } tarjan; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; tarjan.init(n, m); for (int i = 1, u, v; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--, v--; tarjan.addEdge(u, v); tarjan.addEdge(v, u); } tarjan.run(); cout \u0026lt;\u0026lt; tarjan.bridges.size() \u0026lt;\u0026lt; endl; // for (int it:tarjan.bridges) // cout \u0026lt;\u0026lt; tarjan.edges[it ^ 1].to \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; tarjan.edges[it].to \u0026lt;\u0026lt; endl; return 0; }   还是觉得Wowchemy的代码块样式好看！\n ","date":1603799683,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603799683,"objectID":"92dc7e619ee96b5bd600a376c1c32c19","permalink":"https://visors.github.io/post/tarjan%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E8%BE%B9/","publishdate":"2020-10-27T19:54:43+08:00","relpermalink":"/post/tarjan%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E8%BE%B9/","section":"post","summary":"开始了吗？确实开始了。","tags":["Graph Theory","Tarjan"],"title":"Tarjan求无向图割边","type":"post"},{"authors":["Visors"],"categories":["Free Talk"],"content":"换电脑了之后不知道怎么把博客的本地环境搬到新Mac上，所以本博客就一直没有更新，为避免麻烦就在CSDN的博客上发了些内容（择日搬运过来）。这期间我经历了从大二升到大三、以及实验室位置的变动（还有无数场被吊打的比赛），连生成这网站的Academic都改名成了Wowchemy……半年的时间转瞬即逝，谁也不知道明天又会发生什么。\n由于前些日子想法太多（甚至码了本书），现在复归平静，决心调整下状态，便准备从重启本博客开刀。之前怕转过来网站和git需要重新配置，没想到直接copy文件夹过来就行了，于是乎在感叹于跨平台的便捷性的同时，本站重启……\n最近听了不少歌，有些过于小众，想同人分享却又怕不受待见，发空间指不定会被当成小众优越🐶，思来想去也只有这个人网站可以容我自在发言，又偶尔有人能看见，便决定以后每发一篇博客，都在前面简短安利一首歌，若读者遇上喜欢的，欢迎与我交流。也许某天也能遇到那么一个人，会一边听着我安利的歌，一边读着我的文章，那便是荣幸之至了。\n","date":1603798226,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603798226,"objectID":"dc5351cef5c33cd95f8dea3470d5ba45","permalink":"https://visors.github.io/post/%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%9A%84%E5%90%90%E6%A7%BD/","publishdate":"2020-10-27T19:30:26+08:00","relpermalink":"/post/%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%9A%84%E5%90%90%E6%A7%BD/","section":"post","summary":"换电脑了之后不知道怎么把hugo环境搬到Mac上，今天试了下原来直接copy过来就行了，于是乎本站重启……","tags":["Free Talk"],"title":"重启博客后的吐槽","type":"post"},{"authors":["Visors"],"categories":["Java"],"content":"我们的教材虽然在前言中声明使用的是Java8，但一些Java8比较重要的新特性并没有出现在教材中，此处略作补充。\nLambda表达式 Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。\n什么是闭包？  没错这个词很熟悉，离散数学中讲过，不过这里我们以编程的角度来介绍它\n 闭包又称词法闭包，最早定义为一种包含环境成分和控制成分的实体。\n解释一：闭包是引用了自由变量的函数，这个被引用的变量将和这个函数一同存在。\n解释二：闭包是函数和相关引用环境组成的实体。\n 自由变量：除了局部变量的其他变量\n 简单理解：闭包能够将一个方法作为一个变量去存储，这个方法有能力去访问所在类的自由变量。\n我们来看一个 Getter\npublic class Closure {\rprivate int x = 1;\rpublic int getX() {\rreturn x; // return this.x\r}\r}\r 在这段代码中，虽然我们是直接return x，但其实它是省略的return this.x，也就是说 Getter 捕获了外部作用域（环境）中的变量 x （自由变量），因此形成了闭包。 Getter 已经是非常常见的方法了，可想而知一个大点的工程项目里会有多少个闭包。但是如果闭包都像这里的 Getter 一样，把自由变量写在环境里，显然这样的代码连续性是很差的，而且我们并不一定希望自由变量永远的存在于环境里（可能会造成全局变量污染等），这时候就需要使用 Lambda 表达式（通常需要结合函数式接口，后面会讲解）来解决这一问题。\n Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。\n使用 Lambda 表达式可以使代码变的更加简洁紧凑（可能很多时候更重要）。\n语法 (parameters) -\u0026gt; expression\r(parameters) -\u0026gt; { statements; }\r 以下是lambda表达式的重要特征:\n **可选类型声明：**不需要声明参数类型，编译器可以统一识别参数值。 **可选的参数圆括号：**一个参数无需定义（显式书写）圆括号，但多个参数需要定义圆括号。 **可选的大括号：**如果主体只包含了一个语句（expression），就不需要使用大括号。 **可选的返回关键字：**如果主体只有一个表达式返回值则编译器会自动返回值（不用显式书写 return），大括号需要指明表达式返回值。  实例 // 1. 不需要参数,返回值为 5 () -\u0026gt; 5 // 此处无参数，但仍要保留括号，避免语法缺省（在Kotlin中甚至可以简写成5）\r// 2. 接收一个参数(数字类型),返回其2倍的值 x -\u0026gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -\u0026gt; x – y // 得益于Java8对泛型的类型推导，类型推导在Java10中得到了进一步进化\r// 4. 接收2个int型整数,返回他们的和 (int x, int y) -\u0026gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -\u0026gt; System.out.print(s)\r 虚拟扩展方法 接口的封装和可复用性是接口的主要优点，但如果出现这样的设计，类只需要实现接口的部分方法时，提供所有接口方法的方法实现就会显得十分冗余。虽然这一问题可以通过设计来获得解决，但 Java8 提供了虚拟扩展方法来解决这一问题。\n虚拟扩展方法是接口中具有默认实现的方法。如果实现类不提供方法的实现，则使用默认的实现。实现类可以重写默认实现，或提供新的默认实现。\n虚拟扩展方法中的默认实现是用 default 关键字提供的。由于虚拟扩展方法提供默认实现，因此不能是抽象方法。\ninterface Formula {\rdouble calculate(int a);\rdefault double sqrt(int a) {\rreturn Math.sqrt(a);\r}\r}\rpublic class Default {\rpublic static void main(String[] args) {\rFormula formula = new Formula() { // 这个意思可不是声明了一个接口实例\r@Override\rpublic double calculate(int a) {\rreturn sqrt(a * 100);\r}\r// @Override\r// public double sqrt(int a) {\r// return 0;\r// }\r};\rSystem.out.println(formula.calculate(100)); // 100.0\rSystem.out.println(formula.sqrt(16)); // 4.0\r}\r}\r 函数式接口 Lambda 表达式是如何在 Java 的类型系统中表示的呢？每一个 Lambda 表达式都对应一个类型，通常是接口类型。而函数式接口是指仅仅只包含一个抽象方法的接口，每一个该类型的 Lambda 表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。\n我们可以将 Lambda 表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加@FunctionalInterface注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的（类似的还有@override等）。\n我们可以来看一个函数式接口的使用例子\n/**\r* @Project innovation\r* @Filename Seller\r* @Author Visors\r* @Date 2020/6/1 17:27\r* @Version 1.0\r* @Description TODO\r**/\rclass Seller1 implements Runnable {\rprivate int ticket;\rpublic Seller1(int ticket) {\rthis.ticket = ticket;\r}\r@Override\rpublic void run() {\rwhile (ticket \u0026gt; 0) {\rticket--;\rSystem.out.println(\u0026quot;剩余\u0026quot; + ticket + \u0026quot;张票\u0026quot;);\r}\r}\r}\r@FunctionalInterface\rinterface Seller2 {\rvoid run(int ticket);\r}\rpublic class Functional {\rpublic static void main(String[] args) {\rSystem.out.println(\u0026quot;开始卖票！\u0026quot;);\r// new Seller1(10).run();\r// new Thread(new Seller1(100)).start();\r// new Thread(new Seller1(20)).start();\rnew Seller2() {\r@Override\rpublic void run(int ticket) {\rwhile (ticket \u0026gt; 0) {\rticket--;\rSystem.out.println(\u0026quot;剩余\u0026quot; + ticket + \u0026quot;张票\u0026quot;);\r}\r}\r}.run(10);\r// 没有自由变量\r((Seller2) ticket -\u0026gt; {\rwhile (ticket \u0026lt; 10) {\rticket++;\rSystem.out.println(\u0026quot;补充到\u0026quot; + ticket + \u0026quot;张票\u0026quot;);\r}\r}).run(0);\r}\r}\r 函数式接口的一个重要作用是实现行为参数化，即将（模板）方法中可变部分设计成该方法的参数，使得该方法具有通用性。详情可见另一个例子，代码较长，不适合贴在这里。\n后记 编写本文时，我发现很多概念的解释是众说纷纭，相对模糊的，为了尽量解释的合理，我广泛参阅了 StackOverflow 上的一些问答以及国内一些大牛的博客，结合我自己的理解进行了如上的整理，决不能算作是官方的，甚至还会有错误，希望发现错误的读者可以与我一起讨论更正。\n","date":1590977367,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590977367,"objectID":"9c8414621860abe8826da4f5bf56c3d8","permalink":"https://visors.github.io/post/java8%E6%96%B0%E7%89%B9%E6%80%A7/","publishdate":"2020-06-01T10:09:27+08:00","relpermalink":"/post/java8%E6%96%B0%E7%89%B9%E6%80%A7/","section":"post","summary":"我们的教材虽然在前言中声明使用的是Java8，但一些Java8比较重要的新特性并没有出现在教材中，此处略作补充。","tags":["Java"],"title":"Java8新特性","type":"post"},{"authors":["Visors"],"categories":["Codeforces","Solution Report"],"content":"这场div本来应该在5月3日举办，结果因为数据库问题被挪到了5月6日。没想到当天，CF又挂了！！！漫长的队列导致一次提交可能要在半个小时甚至多个小时之后才能看到结果，于是这场比赛变成了unrated。不过这对我来说是个好事（明明是必须这样好吗），因为我的B题在提交后半个小时才返回WA结果，然后我检查代码发现打表打小了……于是又补交了一发，直到比赛结束的时候我都没有看见评测结果，第二天醒来才看见AC……总之这是一次体验糟糕的比赛。\n 另B被人用暴力水过了……\n C - Hilbert\u0026rsquo;s Hotel 这题其实非常简单，比赛的时候想到了正解，不过不知道怎么验证。第二天YGL告诉我这样写就OK，我就认真想了下，好像确实是这么一回事。\n虽然考虑的整数是无穷的，但是我们可以人为的把它划分成长度为$n$的周期，题目其实就是对一个周期中的数按照$a[]$的值进行偏移。那么什么时候会空出房间呢？显然是两个不同不同的数在偏移过后得到了相同的结果呗。用数学的方式来表示，那就是\n$$ i+nk_i+a_i=j+nk_j+a_j $$\n其中$i,j\\in[0,n-1]$，$k$则是它们各自所在的周期位置，那么$i+nk_i$就是其对应的初始数字，然后我们再加上它的偏移量$a_i$，得到的就是偏移后的心的位置，对于$j$也是如此。\n那么很显然，上述式子仍然具有周期性，我们可以对等式两边取模\n$i+nk_i+a_i=j+nk_j+a_j$\n$(i+nk_i+a_i)\\% n=(j+nk_j+a_j)\\% n$\n$(i+a_i)\\% n=(j+a_j)\\% n$\n也就是说我们只需要判断一个周期$[0,n-1]$的重叠情况就可以了。\n当然这里存在一点细节，由于C/Java使用的是$Truncate$除法，所以如果负数对正数取模时，得到的结果可能是负数，实际编写时，为了防止下标越界，我们应该进一步处理\n$(i+a_i)\\% n=(j+a_j)\\% n$\n$((i+a_i)\\% n+n)\\% n=((j+a_j)\\% n+n)\\% n$\n取模在不同语言下得到的结果可能不同，这取决于语言遵循的取整方式，详细内容可以参考《负数取模怎么算》\n/** * @Project Codeforces_Round__639__Div__2_ * @Filename Hilberts_Hotel * @Author Visors * @Date 2020/5/8 11:26 * @Version 1.0 * @Description TODO **/ #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int T, n; int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v(n); vector\u0026lt;bool\u0026gt; book(n, false); for (auto \u0026amp;it:v) cin \u0026gt;\u0026gt; it; for (int i = 0, tmp; i \u0026lt; n; i++) { tmp = (((v[i] + i) % n) + n) % n; //避免%出负数 if (!book[tmp]) book[tmp] = true; else { cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; endl; goto over; } } cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; endl; over:; } return 0; }  ","date":1588911192,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603781543,"objectID":"5b68c04881fa2bbbc68475e33c9b0ada","permalink":"https://visors.github.io/post/codeforces-round-639-div.2/","publishdate":"2020-05-08T12:13:12+08:00","relpermalink":"/post/codeforces-round-639-div.2/","section":"post","summary":"体验不太好的一次比赛，数据也很弱……","tags":["Codeforces","Solution Report"],"title":"Codeforces Round 639 Div.2","type":"post"},{"authors":["Visors"],"categories":["Kotlin","Experience"],"content":"Kotlin虽然基于Java语言，但很多语言特性都与Java不一样。这里记录了我学习Kotlin面向对象时的一些见解。\n我们首先来看这样一段代码：\nclass Person {\rvar name = \u0026quot;\u0026quot;\rvar age = 0\rfun eat() {\rprintln(\u0026quot;$name is eating. He is $age years old.\u0026quot;)\r}\r}\r 这是一个基本的类声明，我们创建了两个字段，并且编写了一个类函数。此时，如果我们想要编写其子类，比如Student，并写下了如下代码：\nclass Student : Person() {\rvar sno = \u0026quot;\u0026quot;\rvar grade = 0\r}\r 我们会发现出现了编译错误——Person类是final的，无法被继承。\n这是因为Kotlin默认类是无法被继承的，如果想要允许类被继承，需要使用open关键字开放对某类的继承，即像这样：\nopen class Person {\rvar name = \u0026quot;\u0026quot;\rvar age = 0\rfun eat() {\rprintln(\u0026quot;$name is eating. He is $age years old.\u0026quot;)\r}\r}\r 可能你会疑惑，类被允许继承不是理所应当的吗？为何要多此一举手动开放继承权限呢？\n这里涉及到了Kotlin语言的设计思想，《Effective Java》中曾经指出——如果一个类不是专门为继承而设计的，那么就应该主动将它加上final声明，禁止它可以被继承。这样可以避免一些未知的风险，而Kotlin则是贯彻这一理念，强制coder遵循这一思想。其实这也是一种安全性的体现。\n 还有一些关于主次构造函数的辨析内容，写起来可能比较多，后续再进行补充。\n","date":1588250949,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588250949,"objectID":"1db63e1939f9934b17b3a358da2855a4","permalink":"https://visors.github.io/post/kotlin%E7%B1%BB%E8%AF%AD%E6%B3%95%E5%8F%8A%E9%81%BF%E9%9B%B7/","publishdate":"2020-04-30T20:49:09+08:00","relpermalink":"/post/kotlin%E7%B1%BB%E8%AF%AD%E6%B3%95%E5%8F%8A%E9%81%BF%E9%9B%B7/","section":"post","summary":"想学好Kotlin，真的要先学好Java才行😂","tags":["Kotlin"],"title":"Kotlin类语法及避雷","type":"post"},{"authors":["Visors"],"categories":["Guide"],"content":"Hack The Box\n在YGL那里看到这个，听说是拿来训练CTF竞赛的。看上去比较高大上，就先蹭进去再说。\n 一开始进去应该是这样一个页面\n遇事不决F12，然后发现一个大大的骷髅头，上面写着让你冷静下来，hack它\n然后我们再检查元素，发现一个跳到脸上来的api，好像生怕我们找不到它\n检查inviteapi.min.js，可以发现一个疑似生成邀请码的方法\n于是我们在控制台调用一下这个方法\n能够看出这是一段BASE64加密码，百度一个解码工具\n大白话，使用hackbar POST一下\n又得到一串加密码，估摸着又是BASE64邀请码到手注册进入\n看着就很高级，不过这不是我现在要弄的，也许日后见？\n","date":1587951795,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587951795,"objectID":"ae1145e90bde19ea4aa30e2321d26ac0","permalink":"https://visors.github.io/post/hack-the-box%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95/","publishdate":"2020-04-27T09:43:15+08:00","relpermalink":"/post/hack-the-box%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95/","section":"post","summary":" ","tags":["CTF","Guide"],"title":"Hack The Box注册方法","type":"post"},{"authors":["Visors"],"categories":["Guide"],"content":"  确保设备上已安装好Java编译环境（可以在命令行通过指令编译运行）\n  在vscode上安装插件Java Extension Pack  在vscode上安装插件Code Runner  在设置内找到并勾选在终端内运行（否则无法输入） 勾选运行前保存（也可以不勾选手动ctrl+s保存）\n  在工作文件夹下新建\u0026quot;.vscode\u0026quot;文件夹，新建设置文件\u0026quot;settings.json\u0026quot;，拷贝下面的代码，并作本地化修改（大部分设置已有注释，部分是cpp的设置，可自行修改）\n  {\r\u0026quot;files.defaultLanguage\u0026quot;: \u0026quot;java\u0026quot;, // ctrl+N新建文件后默认的语言\r\u0026quot;editor.formatOnType\u0026quot;: true, // （对于C/C++）输入分号后自动格式化当前这一行的代码\r\u0026quot;editor.suggest.snippetsPreventQuickSuggestions\u0026quot;: false, // clangd的snippets有很多的跳转点，不用这个就必须手动触发Intellisense了\r\u0026quot;editor.acceptSuggestionOnEnter\u0026quot;: \u0026quot;off\u0026quot;, // 我个人的习惯，按回车时一定是真正的换行，只有tab才会接受Intellisense\r// \u0026quot;editor.snippetSuggestions\u0026quot;: \u0026quot;top\u0026quot;, // （可选）snippets显示在补全列表顶端，默认是inline\r\u0026quot;code-runner.runInTerminal\u0026quot;: true, // 设置成false会在“输出”中输出，无法输入\r\u0026quot;code-runner.executorMap\u0026quot;: {\r\u0026quot;java\u0026quot;: \u0026quot;cd $dir \u0026amp;\u0026amp; javac -encoding utf-8 $fileName \u0026amp;\u0026amp; java $fileNameWithoutExt\u0026quot;,//这步非常重要，简单来说是指定了一键编译时发送给终端的命令的形式，默认是没有-encoding utf-8的，这样会导致中文乱码，手动添加可解决这一问题\r}, // 控制Code Runner命令；未注释的仅适用于PowerShell（Win10默认），文件名中有空格也可以编译运行；注释掉的适用于cmd（win7默认），也适用于PS，文件名中有空格时无法运行\r\u0026quot;code-runner.saveFileBeforeRun\u0026quot;: true, // run code前保存\r\u0026quot;code-runner.preserveFocus\u0026quot;: true, // 若为false，run code后光标会聚焦到终端上。如果需要频繁输入数据可设为false\r\u0026quot;code-runner.clearPreviousOutput\u0026quot;: false, // 每次run code前清空属于code runner的终端消息，默认false\r\u0026quot;code-runner.ignoreSelection\u0026quot;: false, // 默认为false，效果是鼠标选中一块代码后可以单独执行\r}\r 在代码页右键Run Code或使用快捷键ctrl+alt+N运行。   如果run code报错，在main函数下面也有个run/debug。尝试使用那里的run\n ","date":1587866370,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587866370,"objectID":"4d6730dab89079d6b3c117a3208ee126","permalink":"https://visors.github.io/post/%E4%BD%BF%E7%94%A8vscode%E4%B8%80%E9%94%AE%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cjava%E4%BB%A3%E7%A0%81/","publishdate":"2020-04-26T09:59:30+08:00","relpermalink":"/post/%E4%BD%BF%E7%94%A8vscode%E4%B8%80%E9%94%AE%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cjava%E4%BB%A3%E7%A0%81/","section":"post","summary":"很多Java IDE都需要建立项目才能编译运行文件，一旦新创建一份需要运行代码，也需要同时新建一个项目才行，这点非常繁琐。使用这一配置，你可以在vscode中直接编译单个Java文件，也可以编译运行项目。","tags":["Java","vscode","Guide"],"title":"使用vscode一键编译运行Java代码","type":"post"},{"authors":["Visors"],"categories":["lanqiao","Solution Report"],"content":"填空题 对于填空题，其实很多时候枚举啊之类的就完事了。但是作为整理，我认为认真的态度是把它当成独立的可以用编程解决的普适的问题来分析，所以下面我会写上每道题的题目改编及思路。\n 问题描述 将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。 请问，总共能排列如多少个不同的单词。\n答案 $2520$\n改编 给定一个字符串，求可以得到的排列数。\n戏说 根据组合数学原理，统计不同的字符数$n$，以及不同字符出现的个数$tot[i]$，那么结果即为$\\frac{n!}{\\prod_{i=1}^n{tot[i]!}}$\n 问题描述 一个包含有2019个结点的无向连通图，最少包含多少条边？\n答案 $2018$\n改编一 一个包含有$n$个结点的无向连通图，最少包含多少条边？\n戏说 该图应为一条链，边数为$n-1$\n改编二 一个包含有$n$个结点的无向连通图，最多包含多少条边？\n戏说 该图应为完全图，边数为$\\frac{(1+(n-1))(n-1)}{2} = \\frac{n(n-1)}{2}$\n 问题描述 在计算机存储中，12.5MB是多少字节？\n答案 $13107200$\n戏说 $1\\text{MB}=1024\\text{KB}=1024*1024\\text{B}$\n 问题描述 由1对括号，可以组成一种合法括号序列：()。 由2对括号，可以组成两种合法括号序列：()()、(())。 由4对括号组成的合法括号序列一共有多少种？\n答案 $14$\n改编 由$n$对括号组成的合法括号序列一共有多少种？\n戏说 这题作为填空题肯定是手动枚举一下就行了。\n这里深度为1的序列有一种为：()()()()，深度为2的有7种:(())()()、()(())()、()()(())、(()()())、(()())()、()(()())、(())(())，深度为3的有5种：((()))()、()((()))、((())())、(()(()))、((()()))，深度为4的有1种:(((())))\n我知道你一定觉得这中间有什么规律，但是一时半会儿想不出来。注意，规律不是$2^{n-1}$，我一开始枚举漏了，差点写成8。\n实际上，这是一个卡特兰$Catalan$数问题。\n这里直接给出卡特兰数的定义，即卡特兰数\n$Catalan(n+1)=Catalan(0)*Catalan(n)+Catalan(1)*Catalan(n-1)+\u0026hellip;+Catalan(n)*Catalan(0)$\n其中，$Catalan(0)=1$\n带入一下是不是可以算出：\n$Catalan(1)=1$\n$Catalan(2)=2$\n$Catalan(3)=5$\n$Catalan(4)=14$\n这里便可以用来解决一部分问题了，但这种递推的求法对于$n$较大的情况还是很难处理，即使交给计算机，也容易超时，是否有更好的解法呢？我们可以尝试推一推卡特兰数的通项公式，以这个问题为例：\n  考虑$n$对括号，共有$n$个(和$n$个)。显然其全排列的个数为$2n\\choose n$\n  考虑减法原理，计算非法个数。\n  观察非法排列的特性，我们假设(为$1$，)为$-1$，那么对于任意一个非法排列$a_1,a_2,\u0026hellip;,a_n$ ，一定存在一个$k$,使得$a_1+a_2+\u0026hellip;+a_k\u0026lt;0$，即$1\\sim k$中，)个数比(个数多\n  考虑一个$n=3$时具体的排列$1,-1,1,-1-1,1$，在$k=5$时，出现了非法情况。我们将$1\\sim 5$的每个元素元素翻转，那么该序列就变成了$-1,1,-1,1,1,1$\n翻转过后，一共有$n+1$个$1$，$n-1$个$-1$，共有$2n\\choose n+1$种。\n也就是说，对于一个含$n$个$1$，$n$个$-1$的非法排列，总是存在一个最小的$k$，使得我们对第$1$个到第$k$个元素翻转，就能变成含$n+1$个$1$，$n-1$个$-1$的非法排列。同样，对于含$n+1$个$1$，$n-1$个$-1$的非法排列，也总是存在一个最小的$pos$，使得我们对第$1$个到第$pos$个元素翻转，就能变成含$n$个$1$，$n$个$-1$的非法排列。比如对于非法排列$-1,1,1,1,1,-1$，存在$pos=3$，使得翻转后序列变为$1,-1,-1,1,1,-1$。\n  这意味着所有的含$n+1$个$1$，$n-1$个$-1$的非法排列和含$n$个$1$，$n$个$-1$的非法排列建立了一一对应的关系，所以可以推得，非法排列的个数为$2n\\choose n+1$\n  那么对于$n$对括号，合法的排列共有${2n\\choose n} - {2n\\choose n+1}=\\frac{(2n)!}{(n+1)!n!}=\\frac{2n\\choose n}{n+1}$种\n  而卡特兰数的通项公式正好对应上述结果，即$Catalan(n)=\\frac{2n\\choose n}{n+1}$\n改编不是乱编，戏说不是胡说。\n 程序设计题 凯撒密码 问题描述 给定一个单词，请使用凯撒密码将这个单词加密。\n凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，\u0026hellip;，w变为z，x变为a，y变为b，z变为c。\n例如，lanqiao会变成odqtldr。\n输入格式 输入一行，包含一个单词，单词中只包含小写英文字母。\n输出格式 输出一行，表示加密后的密文。\n样例输入 lanqiao\n样例输出 odqtldr\n评测用例规模与约定 对于所有评测用例，单词中的字母个数不超过100。\n思路与代码 利用ASCII值进行变换，注意处理x,y,z，直接给出代码\n/** * @Project lanqiao_provincial_simulation * @Filename 5 * @Author Visors * @Date 2020/4/25 8:48 * @Version 1.0 * @Description 凯撒密码 **/ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; string s; int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; s; int len = s.length(); for (int i = 0; i \u0026lt; len; i++) s[i] = (s[i] + 3 - 'a') % 26 + 'a'; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; }  不用写很多if，一个公式就可以解决了。\n本题的一个好的测试方法是，输入abcdefghijklmnopqrstuvwxyz，看看结果是否为defghijklmnopqrstuvwxyzabc\n 反倍数 问题描述 给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。\n请问在 1 至 n 中有多少个反倍数。\n输入格式 输入的第一行包含一个整数 n。\n第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。\n输出格式 输出一行包含一个整数，表示答案。\n样例输入 30 2 3 6  样例输出 10\n样例说明 以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。\n评测用例规模与约定 对于 40% 的评测用例，1 \u0026lt;= n \u0026lt;= 10000。\n对于 80% 的评测用例，1 \u0026lt;= n \u0026lt;= 100000。\n对于所有评测用例，1 \u0026lt;= n \u0026lt;= 1000000，1 \u0026lt;= a \u0026lt;= n，1 \u0026lt;= b \u0026lt;= n，1 \u0026lt;= c \u0026lt;= n。\n思路与代码 就这个范围，暴力应该就可以了，不过我还是敲了个筛法。最关键的地方是，不要重复统计！\n/** * @Project lanqiao_provincial_simulation * @Filename 6 * @Author Visors * @Date 2020/4/25 8:53 * @Version 1.0 * @Description 反倍数 **/ #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e6 + 5; int n; bool book[N]; //记录非反倍数 int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v(3); for (auto \u0026amp;it:v) cin \u0026gt;\u0026gt; it; sort(v.begin(), v.end()); //对题目的a,b,c从小到大排序，至于为什么，见后面 long long a, b, c; //因为要乘所以开long long，不然如果题目给个1和1000000 // 我的程序就会1000000*1000000导致int溢出 int tot = 0; //统计非反倍数个数 for (int i = 1; i \u0026lt;= n; i++) { //枚举倍数 a = v[0] * i; b = v[1] * i; c = v[2] * i; //cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; b \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; if (a \u0026gt; n) break; //最小数的倍数都比n大，其它数肯定也大，直接结束 if (a \u0026lt;= n \u0026amp;\u0026amp; !book[a]) { //a*i没超界且该数没被记录过（去重） book[a] = true; //记录 tot++; //非反倍数+1 } if (b \u0026lt;= n \u0026amp;\u0026amp; !book[b]) { book[b] = true; tot++; } if (c \u0026lt;= n \u0026amp;\u0026amp; !book[c]) { book[c] = true; tot++; } } cout \u0026lt;\u0026lt; n - tot \u0026lt;\u0026lt; endl; //总个数-非反倍数个数=反倍数个数 return 0; }  有点小题大做不是……\n 螺旋矩阵 问题描述 对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。\n例如，一个 4 行 5 列的螺旋矩阵如下：\n1 2 3 4 5 14 15 16 17 6 13 20 19 18 7 12 11 10 9 8  输入格式 输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。\n第二行包含两个整数 r, c，表示要求的行号和列号。\n输出格式 输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。\n样例输入 4 5 2 2  样例输出 15\n评测用例规模与约定 对于 30% 的评测用例，2 \u0026lt;= n, m \u0026lt;= 20。\n对于 70% 的评测用例，2 \u0026lt;= n, m \u0026lt;= 100。\n对于所有评测用例，2 \u0026lt;= n, m \u0026lt;= 1000，1 \u0026lt;= r \u0026lt;= n，1 \u0026lt;= c \u0026lt;= m。\n思路与代码 这题数据范围太小，四个while暴力一个一个填数，填到$r$行$c$列即可，下面是随便找的代码（网上博客里面填蛇形矩阵的，如果没记错估计是copy的紫书的）\ntot = a[x = 0][y = 0] = 1; while (tot\u0026lt;n*m) { while (y + 1\u0026lt;n\u0026amp;\u0026amp;!a[x][y + 1])a[x][++y] = ++tot; while (x + 1\u0026lt;m\u0026amp;\u0026amp;!a[x + 1][y])a[++x][y] = ++tot; while (y - 1 \u0026gt;= 0 \u0026amp;\u0026amp; !a[x][y - 1])a[x][--y] = ++tot; while (x - 1 \u0026gt;= 0 \u0026amp;\u0026amp; !a[x - 1][y])a[--x][y] = ++tot; }  这里只放了核心代码，对于初学者来说可能不太容易懂。我初接触算法竞赛时，看到紫书上这个代码，也有点迷糊（刘汝佳代码都比较精炼）。如果不懂，建议纸上跟着画一画，或者在Excel里面填着看。\n不过我还是得整点活，上述代码时间复杂度肯定是$O(nm)$，数据范围再大点呢？显然容易超时。有没有公式可以让我们快速求解呢？\n若用$rect[i][j]$表示螺旋矩阵$i$行$j$列的数字，那么对于$n$行$m$列的螺旋矩阵的最外圈，我们可以发现其遵循下面公式：\n $rect[1][j]=j$ $rect[i][m]=m+i-1$ $rect[n][j]=n+2*m-2-j+1$ $rect[i][1]=2*(n+m)-4-i+2$  这只是最外圈的公式，还要不要继续推下去呢？再推太麻烦了，其实一个矩阵可以被拆成$(n+1)/2$个外圈，分治即可。\n/** * @Project lanqiao_provincial_simulation * @Filename 7 * @Author Visors * @Date 2020/4/25 9:14 * @Version 1.0 * @Description 螺旋矩阵 **/ #include \u0026lt;iostream\u0026gt; using namespace std; int n, m, r, c; int calc(int row, int col, int i, int j) { //如果在当前矩阵最外圈，直接公式求解 if (i == 1) return j; if (j == col) return col + i - 1; if (i == row) return row + 2 * col - 2 - j + 1; if (j == 1) return 2 * (row + col) - 4 - i + 2; //带着数字进入子矩阵求解 return calc(row - 2, col - 2, i - 1, j - 1) + 2 * (row + col) - 4; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c; cout \u0026lt;\u0026lt; calc(n, m, r, c) \u0026lt;\u0026lt; endl; return 0; }   摆动序列 问题描述 如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]\u0026lt;a[2i-1], a[2i+1]\u0026gt;a[2i]。\n小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。\n输入格式 输入一行包含两个整数 m，n。\n输出格式 输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。\n样例输入 3 4\n样例输出 14\n样例说明 以下是符合要求的摆动序列：\n2 1 2 2 1 3 2 1 4 3 1 2 3 1 3 3 1 4 3 2 3 3 2 4 4 1 2 4 1 3 4 1 4 4 2 3 4 2 4 4 3 4  评测用例规模与约定 对于 20% 的评测用例，1 \u0026lt;= n, m \u0026lt;= 5；\n对于 50% 的评测用例，1 \u0026lt;= n, m \u0026lt;= 10；\n对于 80% 的评测用例，1 \u0026lt;= n, m \u0026lt;= 100；\n对于所有评测用例，1 \u0026lt;= n, m \u0026lt;= 1000。\n思路与代码 这题很多人都说是DP，其实也算不上是DP吧，因为递推就可以了，没有什么“决策”可言。\n若令$f[m][n]$为长度为$m$，以$n$结尾的方案数，那么有\n$f[i][j]=\\sum{f[i-1][t]},(t\u0026lt;j)$\n对这个式子不理解？看下后面的代码应该就明白了。\n很明显我们需要枚举$i$和$j$，并且还要计算$\\sum$值，这样做的时间复杂度是$O(mn^2)$，显然超出的范围限制（终于？？）。但无需惊慌，对于连续求和，我们可以用前缀和优化一下，时间复杂度即降到$O(mn)$\n/** * @Project lanqiao_provincial_simulation * @Filename 8 * @Author Visors * @Date 2020/4/25 9:27 * @Version 1.0 * @Description 摆动序列 **/ #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000 + 5, MOD = 10000; int m, n, ans = 0; int f[N][N]; //f[i][j]为长度为i，以j结尾的方案数 int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) f[1][i] = 1; //长度为1，以谁结尾都是一种方案，递推起点 for (int i = 2; i \u0026lt;= m; i++) { int sum = 0; if (i \u0026amp; 1) { //奇数与1得1 //奇数项，从前开始 for (int j = 1; j \u0026lt;= n; j++) { //前缀和优化 f[i][j] += sum; f[i][j] %= MOD; sum += f[i - 1][j]; sum %= MOD; } } else { //偶数项，从后开始 for (int j = n; j \u0026gt;= 1; j--) { //前缀和优化 f[i][j] += sum; f[i][j] %= MOD; sum += f[i - 1][j]; sum %= MOD; } } } for (int i = 1; i \u0026lt;= n; i++) { ans += f[m][i]; ans %= MOD; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  这题是NOIP2013花匠的弱化版，有兴趣可以深入了解一下。\n 户户通电 问题描述 2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。\n这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。\n现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。\n小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为\n$$\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(h_1-h_2)^2}$$\n在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。\n由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。\n输入格式 输入的第一行包含一个整数 n ，表示村庄的数量。\n接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。\n输出格式 输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。\n样例输入 4 1 1 3 9 9 7 8 8 6 4 5 4  样例输出 17.41\n评测用例规模与约定 对于 30% 的评测用例，1 \u0026lt;= n \u0026lt;= 10；\n对于 60% 的评测用例，1 \u0026lt;= n \u0026lt;= 100；\n对于所有评测用例，1 \u0026lt;= n \u0026lt;= 1000，0 \u0026lt;= x, y, h \u0026lt;= 10000。\n思路与代码 吐槽：这是什么魔怔距离计算公式？\n不过好在题目“好心”提示了一下，所以问题不大。\n读完题目，发现这是一道最小生成树板子题目。你只需，根据魔怔距离公式建出完全图，然后套上最小生成树算法得板子即可。值得注意的是，由于本题是完全图，总共有$\\frac{n(n-1)}{2}$条边，属于稠密图确信，由于$prim$算法在稠密图上表现由于$Kruskal$算法，所以我们采用堆优化得$prim$算法（如果不知道为啥要堆优化，可以查阅一下相关资料，这两个算法应该是离散数学里面讲过的）\n/** * @Project lanqiao_provincial_simulation * @Filename 9 * @Author Visors * @Date 2020/4/25 9:47 * @Version 1.0 * @Description 户户通电 **/ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 1000 + 5; const double oo = sqrt(10000 * 10000 + 10000 * 10000) + 10000 * 10000 + 5; int n; double G[N][N], lowCost[N]; bool book[N]; struct Node { double x, y, h; Node() : x(0), y(0), h(0) {} Node(double x, double y, double h) : x(x), y(y), h(h) {} } node[N]; struct Elem { int num; double dist; Elem() {} Elem(int num, double dist) : num(num), dist(dist) {} //重载\u0026lt;使优先队列为最小堆 bool operator\u0026lt;(const Elem \u0026amp;x) const { return dist \u0026gt; x.dist; } }; priority_queue\u0026lt;Elem\u0026gt; pq; double prim() { //初始化 for (int i = 1; i \u0026lt;= n; i++) { lowCost[i] = G[1][i]; pq.push(Elem(i,lowCost[i])); } lowCost[1] = -oo; double tot = 0.0; int count = 1; Elem tmp; while (1) { if (count == n) break; //取有效堆顶，即为最近顶点 while (!pq.empty()) { tmp = pq.top(); pq.pop(); if (lowCost[tmp.num] != -oo) break; } tot += tmp.dist; lowCost[tmp.num] = -oo; for (int i = 1; i \u0026lt;= n; i++) { if (lowCost[i] != -oo \u0026amp;\u0026amp; G[tmp.num][i] \u0026lt; lowCost[i]) { lowCost[i] = G[tmp.num][i]; pq.push(Elem(i,lowCost[i])); } } count++; } return tot; } int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); double x, y, h; for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%lf%lf%lf\u0026quot;, \u0026amp;x, \u0026amp;y, \u0026amp;h); node[i] = Node(x, y, h); } //建图 for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= i; j++) { if (i == j) G[i][j] = 0; else { x = (node[i].x - node[j].x) * (node[i].x - node[j].x); y = (node[i].y - node[j].y) * (node[i].y - node[j].y); h = (node[i].h - node[j].h) * (node[i].h - node[j].h); G[i][j] = G[j][i] = sqrt(x + y) + h; } } printf(\u0026quot;%.2lf\\n\u0026quot;,prim()); return 0; }  因为这是我临场拼的板子，所以可能写的有点过长。\n 郊外植树 问题描述 小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。\n小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。\n然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。\n他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。\n小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。\n输入格式 输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。\n接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。\n输出格式 输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。\n样例输入 6 1 1 2 1 4 2 1 7 2 4 1 2 4 4 2 4 7 2  样例输出 12\n评测用例规模与约定 对于 30% 的评测用例，1 \u0026lt;= n \u0026lt;= 10；\n对于 60% 的评测用例，1 \u0026lt;= n \u0026lt;= 20；\n对于所有评测用例，1 \u0026lt;= n \u0026lt;= 30，0 \u0026lt;= x, y \u0026lt;= 1000，1 \u0026lt;= r \u0026lt;= 1000。\n思路与代码 如何判断两棵树是否干涉，其实就是利用高中学过的圆与圆间位置关系来判断即可，也就是两圆心（种树的位置）间距离小于两圆半径之和即为相交。\n这题树很少，直接暴力即可，但纯暴力还是有点吃紧，我们可以稍作剪枝。前面已经说了判断两棵树是否干涉的方法，我们可以考虑预处理任意两树是否发生干涉的数组，在搜索时，一旦出现干涉，立刻返回，即采用可行性剪枝（听说也叫左剪枝，这是根据搜索树形态的变化命名的）。\n/** * @Project lanqiao_provincial_simulation * @Filename 10 * @Author Visors * @Date 2020/4/25 10:24 * @Version 1.0 * @Description 郊外植树 **/ #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 35; int n, ans; int x[N], y[N], r[N]; bool book[N], isIntersect[N][N]; void dfs(int step) { if (step \u0026gt; n) { int sum = 0; for (int i = 1; i \u0026lt;= n; i++) if (book[i]) sum += (r[i] * r[i]); //PI*r*r/PI ans = max(sum, ans); return; } book[step] = false; dfs(step + 1); //不种该树搜 for (int i = 1; i \u0026lt; step; i++) if (book[i] \u0026amp;\u0026amp; isIntersect[i][step]) return; //可行性剪枝 book[step] = true; dfs(step + 1); //种该树搜 } int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i] \u0026gt;\u0026gt; r[i]; //判断圆与圆间位置关系 for (int i = 1; i \u0026lt;= n; i++) for (int j = i + 1; j \u0026lt;= n; j++) isIntersect[i][j] = isIntersect[j][i] = ((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) \u0026lt; (r[i] + r[j]) * (r[i] + r[j])); dfs(1); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  总结 之前以为校赛模拟赛会比较简单，省赛模拟赛会难一些，事实上好像难度接近，甚至这场难度还低于前面某场（之前看星星的题目我线下没写出满分）？所以我估计省赛时也就是这样的难度。也就是说，更多的考察一些数学基础与思维，再带上一些常用算法。\n由于蓝桥不能带板子，所以从练习时就要理解所有的算法，以便自己在赛场上能思路清晰的独立敲出来，背代码是吃力不讨好的。推荐备战蓝桥的同学多刷刷蓝桥题库，如果对算法题有进一步兴趣，也可以刷刷leetcode、Codeforces等网站的题目，对以后求职会有很大帮助。也欢迎来参加我们实验室组织的各项比赛XD\n","date":1587785107,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587785107,"objectID":"4c7d9d8a44a039b41df109790b3059a9","permalink":"https://visors.github.io/post/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F/","publishdate":"2020-04-25T11:25:07+08:00","relpermalink":"/post/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F/","section":"post","summary":"4.25上午蓝桥省赛模拟赛解题报告，内涵填空题分析以及程序设计题思路与代码。","tags":["lanqiao","Solution Report"],"title":"蓝桥省赛模拟","type":"post"},{"authors":["Visors"],"categories":["Codeforces","Solution Report"],"content":"碎碎念 终于上分了真的，感觉可以冲到一两千名的（C代码出的时候提交还不多），结果C沉了，最终只有六千名。毕竟这次手稍微快hhh。本来以为我C的代码够简洁了，没想到正解好像更简洁……\n这次真的是非常遗憾，C和D都接近想到正解，却没有最终AC。另外吐槽一下本场的题面，是真的难读……不过题目质量还是在线的。\n解题报告 C - Nastya and Strange Generator C的题目很难读，直接把LYH读崩了，所以这里我先简要翻译一下。\n本题需要我们按照规则检查题目给出的排列能否被生成。开始时排列$p$为空，然后我们按照以下规则依次将$1\\sim n$填入排列，一开始$i=1$：\n 计算$r$数组，$r[j]=min(t\\in [j,n])$，其中$p[t]~is~empty$即没有被填过，如果不存在这样一个$j$，我们可以用$0$之类的特殊数表示 计算$count$数组，$count[j]$为$r[]$中$j$的数目 $count$数组中值最大的下标为$i$的可放置点 将$i$放入排列，$i++$，转到1.，直到$n$个数被填完  根据这个规则，再结合样例解释，就能够理解了：\n如果暴力，显然$O(n^2)$超时，这两个$n$分别是枚举每位数的时间和检查每个数能不能填的时间。我们可以考虑优化其中之一，枚举每位数显然很难优化，就看能否优化检查每个数的时间，只要降到$O(logn)$以下，本题就可解决。\n于是乎我们可以研究一下$r$和$count$的生成方法，很容易发现这两个数组在填$i$和$i+1$时是有一定的转移规律的。然后我想到的规律是：\n 上一个数填在最右边，那么前面的$r$数组不会受影响，进而$count$数组也不会受影响，所以当前数可以填在任意空余位置。 上一个数不在最右边，那么它只会直接影响它自己的$r$，使得其对应下标$r$变为其右边没填的最近的位置，进而打破$count$数组的平衡，使那个位置的count突然比别的多，这时候这个数必须填在那。  /**\r* @Project Codeforces_Round__637__Div__2_\r* @Filename Nastya_and_Strange_Generator\r* @Author Visors\r* @Date 2020/4/23 23:56\r* @Version 1.0\r* @Description TODO\r**/\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;cstring\u0026gt;\rusing namespace std;\rconst int N = 1e5 + 5;\rint T, n;\rint pos[N];\rbool book[N];\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcin \u0026gt;\u0026gt; T;\rwhile (T--) {\rmemset(book, 0, sizeof(book));\rcin \u0026gt;\u0026gt; n;\rfor (int i = 1, t; i \u0026lt;= n; i++) {\rcin \u0026gt;\u0026gt; t;\rpos[t] = i;\r}\rint r = n;\rbool flag = true;\rbook[pos[1]] = true;\rfor (int i = 2; i \u0026lt;= n; i++) {\rif (pos[i - 1] != r) {\rint tmp = pos[i - 1];\rwhile (book[tmp]) tmp++;\rif (tmp != pos[i]) {\rflag = false;\rbreak;\r} else book[tmp] = true;\r}\rif (pos[i - 1] == r) {\rbook[pos[i]] = true;\rr--;\r}\r}\rif (flag) cout \u0026lt;\u0026lt; \u0026quot;Yes\u0026quot; \u0026lt;\u0026lt; endl;\relse cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r}\r 但是在第二个测试点错了，希望有读者能帮我指出一下问题在哪里。\n正解是判断有没有$p[i]-p[i-1]\u0026gt;1$，如果有那么不能生成。感觉跟我的比较像，不知道差异点是在哪里……\n/*\r* @Filename Nastya_and_Strange_Generator.cpp\r* @Author Visors\r* @Date 2020/4/24 11:07\r* @Version 1.0\r* @Description TODO\r**/\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;vector\u0026gt;\rusing namespace std;\rint T, n;\rvector\u0026lt;int\u0026gt; p;\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcin \u0026gt;\u0026gt; T;\rwhile (T--) {\rcin \u0026gt;\u0026gt; n;\rp = vector\u0026lt;int\u0026gt;(n);\rcin \u0026gt;\u0026gt; p[0];\rbool flag = true;\rfor (int i = 1; i \u0026lt; n; i++) {\rcin \u0026gt;\u0026gt; p[i];\rif (p[i] - p[i - 1] \u0026gt; 1) flag = false;\r}\rif (flag) cout \u0026lt;\u0026lt; \u0026quot;Yes\u0026quot; \u0026lt;\u0026lt; endl;\relse cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r}\r to be continue……\n","date":1587693465,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603781543,"objectID":"457cf20316621d72dc73e67bdc1dda05","permalink":"https://visors.github.io/post/codeforces-round-637-div.2/","publishdate":"2020-04-24T09:57:45+08:00","relpermalink":"/post/codeforces-round-637-div.2/","section":"post","summary":"终于上分了真的，感觉可以冲到一两千名的（C代码出的时候提交还不多），结果C沉了，最终只有六千名。毕竟这次手稍微快hhh。本来以为我C的代码够简洁了，没想到正解好像更简洁……这次真的是非常遗憾，C和D都接近想到正解，却没有最终AC。另外吐槽一下本场的题面，是真的难读……不过题目质量还是在线的。","tags":["Codeforces","Solution Report"],"title":"Codeforces Round 637 Div.2","type":"post"},{"authors":["Visors"],"categories":["Free Talk"],"content":"近期我常常因为国内外社交媒体下的评论而感到十分恼火，一方面，推特如同催眠般向我推荐反华言论——尽管我关注的人中没有反华分子，反倒是有马云先生、华春莹女士等——另一方面国内媒体如微博、看点下的无脑节奏也让我愤愤不平。但反观我周围，即便我并非处于什么文化人之行列，却仍鲜少有言论无脑之人。于是我陷入了既因为网络无脑节奏之多而怀疑整体网民素质，又因为周围人并没有参与其中而一定程度否定前者的矛盾当中。不过今天饭桌的闲谈中，我似乎突然明白了些什么。\n当今社交媒体评论显示几乎都是基于热度，我们可以思考热评究竟是如何诞生的。只有在热评尚未诞生之时，我们所看见的热评才几乎等同于最新评论，这时第一批围观者或发表他们的看法，或进行点评赞踩，于是一些言论被顶上前排，成了真正的热评。如果你是后来者，你直接看到的就是他人的热评，大多数人不会有翻看最新评论的习惯，所以你迟来的评论并不会引人关注。而事实往往是后来者更倾向于理性看待问题，冲在前面的人还没经过深度思考，便草草发布见解，甚至为上热评，刻意带起节奏。而这部分内容更容易成为热评，真正理性的评论，却大多数被节奏所淹没，隐藏在了最新评论，或者介于最新评论和热门评论之间的“看不见的地带”。\n诚然互联网给每个人都带来了网络时代的红利，但目前以热度为基础的网络环境，却实实在在诱导了一些网民的内心，而这种言论一经热度放大，带起的节奏却不是一般人能理性看待的，类似的还有流量热度至上的无良自媒体。尽管热度害人，能让毫无营养的评论走上热评，网民的不理性仍是关键一环，而想让每个人都能从感性认识快速走向理性认识，几乎是不可能完成的事情，如此一想，我不必轻易为评论所左右，我有我自己的理性思考，我也不必为评论所生气，因为它们往往代表着的是所有声音中最不理智的那一些。\n","date":1587622082,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587622082,"objectID":"27efd7fabb67b53aabe318ae7dc22fe8","permalink":"https://visors.github.io/post/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E8%BD%BB%E4%BF%A1%E8%AF%84%E8%AE%BA/","publishdate":"2020-04-23T14:08:02+08:00","relpermalink":"/post/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E8%BD%BB%E4%BF%A1%E8%AF%84%E8%AE%BA/","section":"post","summary":"你会因为网上无脑的言论而生气吗？如果会，也许你能从这篇文章中找到一点慰藉。","tags":["Free Talk"],"title":"我们为何不能轻信评论","type":"post"},{"authors":["Visors"],"categories":["Codeforces","Solution Report"],"content":"碎碎念 最近开始参加Codeforces Round——注册四五年，才打四五场比赛。\n不打打CF还不知道自己竟然这么菜，打个div3先是手速过慢被一众巨巨甩掉，后面偏难题目又A不掉不能实现弯道超车，菜的真实，后面还得加大力度，早日冲上1900分。\n解题报告 D - Constant Palindrome Sum 这题看上去好想二分一波，但实际上并没有什么好的局部转移的规则。由于这场基本都是数学思维题，所以感觉这题也是这个方向。一开始被题面迷惑了一波，以为minimum是要每次改变最小的数，然后YY半天发现其实是最少次改变数……\n思考的时候已经发现了Tutorial中的三点：\n We don\u0026rsquo;t need to change anything in this pair; we can replace one element to fix this pair; we need to replace both elements to fix this pair.  也想到要hash各个pair对应的x值，不过因为题意读错的原因老是把两个时期的思维过程搞混，导致本Round直线下分，冷静想想自己已经找到近似解了，比赛的时候还是有点不太理智。\n 其实思路非常简单，题目只考虑$a[i]+a[n-i+1]$，所以我们可以把$a[i]$和$a[n-i+1]$视为一对$pair$。\n首先我们读入所有的$pair$，然后对于每对$pair$，我们可以考虑将其三种分类下的作用范围转化为区间涂色问题。线段树可以解决区间涂色问题，但是在这里前缀和更优，参考color the ball那道题目。\n怎么将其转化为区间涂色问题呢？\n对于第一种分类，该$pair$和就为其简单相加。\n对于第二种分类，我们可以考虑固定$pair$的任意元素，改变另外一个元素。例如对于$pair\u0026lt;a,b\u0026gt;$，我们固定$a$，那么由于$b$的改动范围是$[1,k]$，所以整个$pair$的取值范围就是$[a+1,a+k]$，同理也可以固定$b$，改动$a$.\n对于第三种分类，若设全局$U=[2,2k]$，那么两种都需要改动的范围就是$U-([a+1,a+k]\\cup [b+1,b+k]\\cup {a+b })$啦\n从上述情况来看，我们可以声明两个数组，一个数组$pref$用来做前缀和，一个数组$cnt$来统计第一种分类出现的次数，这样就能知道取任意$x$时需要修改的次数，即$pref[x]-cnt[x]+2*(n/2-pref[x])$（第二种分类减去前缀和中多统计的第一种分类，再加上第三种分类）。\n/** * @Project Codeforces_Round__636__Div__3_ * @Filename Constant_Palindrome_Sum * @Author Visors * @Date 2020/4/22 22:23 * @Version 1.0 * @Description TODO **/ #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int T, n, k, ans; int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; a(n), cnt(2 * k + 1), pref(2 * k + 2); //cnt pref多留一个空间避免超界，pref本身有可能操作2*k+1，所以这里+2 for (auto \u0026amp;it:a) cin \u0026gt;\u0026gt; it; //Editor这么写的，我也学一波 for (int i = 0; i \u0026lt; n / 2; i++) cnt[a[i] + a[n - i - 1]]++; //下标0开始，n-i+1变成n-i-1 for (int i = 0; i \u0026lt; n / 2; i++) { int l1 = a[i] + 1, r1 = a[i] + k; //固定左边 int l2 = a[n - i - 1] + 1, r2 = a[n - i - 1] + k; //固定右边 pref[min(l1, l2)]++; pref[max(r1, r2) + 1]--; } for (int i = 1; i \u0026lt;= 2 * k + 1; i++) pref[i] += pref[i - 1]; ans = 1e9; for (int x = 2; x \u0026lt;= 2 * k; x++) ans = min(ans, (pref[x] - cnt[x]) + 2 * (n / 2 - pref[x])); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }  E - Weights Distributing 这题虽然是2400分，但我觉得我是可写的，只是比赛连看都没看一眼，前面还需压缩时间。\n 这道题题面比较长，但其实核心问题比较简单：\n给定$n$个点$m$条边的无向联通图，先给定$m$个边权$p_i$，问如何分配边权，能使从点$a$到点$b$，再从点$b$到点$c$走过的权值最小。\n初读题目，可能会觉得这题过水——跑一遍从$a$到$b$的最短路，再跑一遍从$b$到$c$的最短路，然后贪心从小到大取边权，如果两个最短路中间有重复路段就优先取重复的部分。\n这种想法有可取之处，即把最终选取的路径分为了两类：\n 两段路有重合部分 两段路没有重复部分  但却忽视了关键问题，即求得的最短路很可能有多条，而选择其中的不同条，会产生不一样的分组结果。其实我们希望重复部分尽量多，但沿用上一方法很难处理。这时候如果把路径的选取看成这样：设两段路的交点为$x$，那么上面的两类可以被描述为：\n $a$-\u0026gt;$x$-\u0026gt;$b$-\u0026gt;$x$-\u0026gt;$c$ $a$-\u0026gt;$b(x)$-\u0026gt;$c$  两种情况对应下图：\ngraph LR; subgraph situation1 a((a))--\u0026gt;x((x)); x((x))--\u0026gt;b((b)); b((b))--\u0026gt;x((x)); x((x))--\u0026gt;c((c)); end subgraph situation2 A((a))--\u0026gt;B((b=x)); B((b=x))--\u0026gt;C((c)); end  于是我们很容易想到求出$a,b,c$到各点的最短路，枚举$x$，找到最小的$dist(a,x)+2*dist(b,x)+dist(c,x)$即为题目要求的答案。\n因为我们一开始只需要求边数即边权为$1$的最短路径的长度，所以用BFS就可以处理。\n/** * @Project Codeforces_Round__636__Div__3_ * @Filename Weights_Distributing * @Author Visors * @Date 2020/4/23 21:03 * @Version 1.0 * @Description TODO **/ #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int oo = 1e9 + 7; int T, n, m, a, b, c; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; //内存占用大的声明在全局 void bfs(int v, vector\u0026lt;int\u0026gt; \u0026amp;dist) { //这里传的是引用，不会爆栈 dist[v] = 0; queue\u0026lt;int\u0026gt; q; q.push(v); while (!q.empty()) { int t = q.front(); q.pop(); for (auto it:G[t]) { if (dist[it] == oo) { dist[it] = dist[t] + 1; q.push(it); } } } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; vector\u0026lt;int\u0026gt; p(m + 1); for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; p[i]; sort(p.begin() + 1, p.end()); //从大到小排序 vector\u0026lt;long long\u0026gt; pref(m + 1); //求前缀和，方便后面快速取最小的路径 for (int i = 1; i \u0026lt;= m; i++) pref[i] = pref[i - 1] + p[i]; G = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n + 1); for (int i = 1, s, t; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; G[s].push_back(t); G[t].push_back(s); } vector\u0026lt;int\u0026gt; distA(n + 1, oo), distB(n + 1, oo), distC(n + 1, oo); bfs(a, distA); bfs(b, distB); bfs(c, distC); long long ans = 1e18; for (int x = 1; x \u0026lt;= n; x++) { if (distA[x] + distB[x] + distC[x] \u0026gt; m) continue; //分不了直接跳过 ans = min(ans, pref[distB[x]] + pref[distA[x] + distB[x] + distC[x]]); // = 2 * pref[distB[x]] + (pref[distA[x] + distB[x] + distC[x]] - pref[distB[x]]) } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }  ","date":1587561202,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603781543,"objectID":"2d03ea4d7f40200d1734bc39e1468938","permalink":"https://visors.github.io/post/codeforces-round-636-div.3/","publishdate":"2020-04-22T21:13:22+08:00","relpermalink":"/post/codeforces-round-636-div.3/","section":"post","summary":"最近开始参加Codeforces Round——注册四五年，才打四五场比赛。不打打CF还不知道自己竟然这么菜，打个div3先是手速过慢被一众巨巨甩掉，后面偏难题目又A不掉不能实现弯道超车，菜的真实，后面还得加大力度，早日冲上1900分。","tags":["Codeforces","Solution Report","BFS","Greedy","Prefix Sum"],"title":"Codeforces Round 636 Div.3","type":"post"}]