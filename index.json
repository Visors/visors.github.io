[{"authors":["admin"],"categories":null,"content":"万祚全，常用网名Visors，大二本科生，现就读于中南民族大学，校ACM队负责人。平时主攻算法竞赛，最近闲时在研究 Android 开发，有几个APP构想，待学成后尝试实现。对爬虫等技术也有一点涉猎。对于我熟悉的领域或我组织的相关事宜，欢迎邮件或电报交流。\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://visors.github.io/author/%E4%B8%87%E7%A5%9A%E5%85%A8/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/%E4%B8%87%E7%A5%9A%E5%85%A8/","section":"authors","summary":"万祚全，常用网名Visors，大二本科生，现就读于中南民族大学，校ACM队负责人。平时主攻算法竞赛，最近闲时在研究 Android 开发，有几个APP构想，待学成后尝试实现。对爬虫等技术也有一点涉猎。对于我熟悉的领域或我组织的相关事宜，欢迎邮件或电报交流。","tags":null,"title":"万祚全","type":"authors"},{"authors":["Visors"],"categories":[],"content":"碎碎念 最近开始参加Codeforces Round——注册四五年，才打四五场比赛。\n不打打CF还不知道自己竟然这么菜，打个div3先是手速过慢被一众巨巨甩掉，后面偏难题目又A不掉不能实现弯道超车，菜的真实，后面还得加大力度，早日冲上1900分。\n解题报告 D - Constant Palindrome Sum 这题看上去好想二分一波，但实际上并没有什么好的局部转移的规则。由于这场基本都是数学思维题，所以感觉这题也是这个方向。一开始被题面迷惑了一波，以为minimum是要每次改变最小的数，然后YY半天发现其实是最少次改变数……\n思考的时候已经发现了Tutirial中的三点：\n We don\u0026rsquo;t need to change anything in this pair; we can replace one element to fix this pair; we need to replace both elements to fix this pair.  也想到要hash各个pair对应的x值，不过因为题意读错的原因老是把两个时期的思维过程搞混，导致本Round直线下分，冷静想想自己已经找到近似解了，比赛的时候还是有点不太理智。\n 其实思路非常简单，题目只考虑$a[i]+a[n-i+1]$，所以我们可以把$a[i]$和$a[n-i+1]$视为一对$pair$。\n首先我们读入所有的$pair$，然后对于每对$pair$，我们可以考虑将其三种分类下的作用范围转化为区间涂色问题。线段树可以解决区间涂色问题，但是在这里前缀和更优，参考color the ball那道题目。\n怎么将其转化为区间涂色问题呢？\n对于第一种分类，该$pair$和就为其简单相加。\n对于第二种分类，我们可以考虑固定$pair$的任意元素，改变另外一个元素。例如对于$pair\u0026lt;a,b\u0026gt;$，我们固定$a$，那么由于$b$的改动范围是$[1,k]$，所以整个$pair$的取值范围就是$[a+1,a+k]$，同理也可以固定$b$，改动$a$.\n对于第三种分类，若设全局$U=[2,2k]$，那么两种都需要改动的范围就是$U-([a+1,a+k]\\cup [b+1,b+k]\\cup{a+b})$啦\n从上述情况来看，我们可以声明两个数组，一个数组$pref$用来做前缀和，一个数组$cnt$来统计第一种分类出现的次数，这样就能知道取任意$x$时需要修改的次数，即$pref[x]-cnt[x]+2*(n/2-pref[x])$（第二种分类减去前缀和中多统计的第一种分类，再加上第三种分类）。\n/**\r* @Project Codeforces_Round__636__Div__3_\r* @Filename Constant\r* @Author Visors\r* @Date 2020/4/22 22:23\r* @Version 1.0\r* @Description TODO\r**/\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;algorithm\u0026gt;\r#include \u0026lt;vector\u0026gt;\rusing namespace std;\rint T, n, k, ans;\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcin \u0026gt;\u0026gt; T;\rwhile (T--) {\rcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\rvector\u0026lt;int\u0026gt; a(n), cnt(2 * k + 1), pref(2 * k + 2); //cnt pref多留一个空间避免超界，pref本身有可能操作2*k+1，所以这里+2\rfor (auto \u0026amp;it:a) cin \u0026gt;\u0026gt; it; //Editor这么写的，我也学一波\rfor (int i = 0; i \u0026lt; n / 2; i++) cnt[a[i] + a[n - i - 1]]++; //下标0开始，n-i+1变成n-i-1\rfor (int i = 0; i \u0026lt; n / 2; i++) {\rint l1 = a[i] + 1, r1 = a[i] + k; //固定左边\rint l2 = a[n - i - 1] + 1, r2 = a[n - i - 1] + k; //固定右边\rpref[min(l1, l2)]++;\rpref[max(r1, r2) + 1]--;\r}\rfor (int i = 1; i \u0026lt;= 2 * k + 1; i++) pref[i] += pref[i - 1];\rans = 1e9;\rfor (int x = 2; x \u0026lt;= 2 * k; x++) ans = min(ans, (pref[x] - cnt[x]) + 2 * (n / 2 - pref[x]));\rcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r}\r ","date":1587561202,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587561202,"objectID":"2d03ea4d7f40200d1734bc39e1468938","permalink":"https://visors.github.io/post/codeforces-round-636-div.3/","publishdate":"2020-04-22T21:13:22+08:00","relpermalink":"/post/codeforces-round-636-div.3/","section":"post","summary":"碎碎念 最近开始参加Codeforces Round——注册四五年，才打四五场比赛。\n不打打CF还不知道自己竟然这么菜，打个div3先是手速过慢被一众巨巨甩掉，后面偏难题目又A不掉不能实现弯道超车，菜的真实，后面还得加大力度，早日冲上1900分。\n解题报告 D - Constant Palindrome Sum 这题看上去好想二分一波，但实际上并没有什么好的局部转移的规则。由于这场基本都是数学思维题，所以感觉这题也是这个方向。一开始被题面迷惑了一波，以为minimum是要每次改变最小的数，然后YY半天发现其实是最少次改变数……\n思考的时候已经发现了Tutirial中的三点：\n We don\u0026rsquo;t need to change anything in this pair; we can replace one element to fix this pair; we need to replace both elements to fix this pair.","tags":["Codeforces","解题报告"],"title":"Codeforces Round 636 Div.3","type":"post"}]