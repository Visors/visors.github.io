[{"authors":["admin"],"categories":null,"content":"万祚全，常用网名Visors，大二本科生，现就读于中南民族大学，校ACM队负责人。平时主攻算法竞赛，最近闲时在研究 Android 开发，有几个APP构想，待学成后尝试实现。对爬虫等技术也有一点涉猎。对于我熟悉的领域或我组织的相关事宜，欢迎邮件或电报交流。\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://visors.github.io/author/%E4%B8%87%E7%A5%9A%E5%85%A8/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/%E4%B8%87%E7%A5%9A%E5%85%A8/","section":"authors","summary":"万祚全，常用网名Visors，大二本科生，现就读于中南民族大学，校ACM队负责人。平时主攻算法竞赛，最近闲时在研究 Android 开发，有几个APP构想，待学成后尝试实现。对爬虫等技术也有一点涉猎。对于我熟悉的领域或我组织的相关事宜，欢迎邮件或电报交流。","tags":null,"title":"万祚全","type":"authors"},{"authors":["Visors"],"categories":["lanqiao","Solution Report"],"content":"填空题 对于填空题，其实很多时候枚举啊之类的就完事了。但是作为整理，我认为认真的态度是把它当成独立的可以用编程解决的普适的问题来分析，所以下面我会写上每道题的题目改编及思路。\n 问题描述 将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。 请问，总共能排列如多少个不同的单词。\n答案 $2520$\n改编 给定一个字符串，求可以得到的排列数。\n戏说 根据组合数学原理，统计不同的字符数$n$，以及不同字符出现的个数$tot[i]$，那么结果即为$\\frac{n!}{\\prod_{i=1}^n{tot[i]!}}$\n 问题描述 一个包含有2019个结点的无向连通图，最少包含多少条边？\n答案 $2018$\n改编一 一个包含有$n$个结点的无向连通图，最少包含多少条边？\n戏说 该图应为一条链，边数为$n-1$\n改编二 一个包含有$n$个结点的无向连通图，最多包含多少条边？\n戏说 该图应为完全图，边数为$\\frac{(1+(n-1))(n-1)}{2}=\\frac{n(n-1)}{2}$\n 问题描述 在计算机存储中，12.5MB是多少字节？\n答案 $13107200$\n戏说 $1\\text{MB}=1024\\text{KB}=1024*1024\\text{B}$\n 问题描述 由1对括号，可以组成一种合法括号序列：()。 由2对括号，可以组成两种合法括号序列：()()、(())。 由4对括号组成的合法括号序列一共有多少种？\n答案 $14$\n改编 由$n$对括号组成的合法括号序列一共有多少种？\n戏说 这题作为填空题肯定是手动枚举一下就行了。\n这里深度为1的序列有一种为：()()()()，深度为2的有7种:(())()()、()(())()、()()(())、(()()())、(()())()、()(()())、(())(())，深度为3的有5种：((()))()、()((()))、((())())、(()(()))、((()()))，深度为4的有1种:(((())))\n我知道你一定觉得这中间有什么规律，但是一时半会儿想不出来。注意，规律不是$2^{n-1}$，我一开始枚举漏了，差点写成8。\n实际上，这是一个卡特兰$Catalan$数问题。\n这里直接给出卡特兰数的定义，即卡特兰数\n$Catalan(n+1)=Catalan(0)*Catalan(n)+Catalan(1)*Catalan(n-1)+\u0026hellip;+Catalan(n)*Catalan(0)$\n其中，$Catalan(0)=1$\n带入一下是不是可以算出：\n$Catalan(1)=1$\n$Catalan(2)=2$\n$Catalan(3)=5$\n$Catalan(4)=14$\n这里便可以用来解决一部分问题了，但这种递推的求法对于$n$较大的情况还是很难处理，即使交给计算机，也容易超时，是否有更好的解法呢？我们可以尝试推一推卡特兰数的通项公式，以这个问题为例：\n  考虑$n$对括号，共有$n$个(和$n$个)。显然其全排列的个数为$2n\\choose n$\n  考虑减法原理，计算非法个数。\n  观察非法排列的特性，我们假设(为$1$，)为$-1$，那么对于任意一个非法排列$a_1,a_2,\u0026hellip;,a_n$ ，一定存在一个$k$,使得$a_1+a_2+\u0026hellip;+a_k\u0026lt;0$，即$1\\sim k$中，)个数比(个数多\n  考虑一个$n=3$时具体的排列$1,-1,1,-1-1,1$，在$k=5$时，出现了非法情况。我们将$1\\sim 5$的每个元素元素翻转，那么该序列就变成了$-1,1,-1,1,1,1$\n翻转过后，一共有$n+1$个$1$，$n-1$个$-1$，共有$2n\\choose n+1$种。\n也就是说，对于一个含$n$个$1$，$n$个$-1$的非法排列，总是存在一个最小的$k$，使得我们对第$1$个到第$k$个元素翻转，就能变成含$n+1$个$1$，$n-1$个$-1$的非法排列。同样，对于含$n+1$个$1$，$n-1$个$-1$的非法排列，也总是存在一个最小的$pos$，使得我们对第$1$个到第$pos$个元素翻转，就能变成含$n$个$1$，$n$个$-1$的非法排列。比如对于非法排列$-1,1,1,1,1,-1$，存在$pos=3$，使得翻转后序列变为$1,-1,-1,1,1,-1$。\n  这意味着所有的含$n+1$个$1$，$n-1$个$-1$的非法排列和含$n$个$1$，$n$个$-1$的非法排列建立了一一对应的关系，所以可以推得，非法排列的个数为$2n\\choose n+1$\n  那么对于$n$对括号，合法的排列共有${2n\\choose n} - {2n\\choose n+1}=\\frac{(2n)!}{(n+1)!n!}=\\frac{2n\\choose n}{n+1}$种\n  而卡特兰数的通项公式正好对应上述结果，即$Catalan(n)=\\frac{2n\\choose n}{n+1}$\n改编不是乱编，戏说不是胡说。\n 程序设计题（还没写） 凯撒密码 问题描述 　给定一个单词，请使用凯撒密码将这个单词加密。 凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，\u0026hellip;，w变为z，x变为a，y变为b，z变为c。 例如，lanqiao会变成odqtldr。\n输入格式 　输入一行，包含一个单词，单词中只包含小写英文字母。\n输出格式 　输出一行，表示加密后的密文。\n样例输入 lanqiao\n样例输出 odqtldr\n评测用例规模与约定 　对于所有评测用例，单词中的字母个数不超过100。\nabcdefghijklmnopqrstuvwxyz\n反倍数 问题描述 　给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。 请问在 1 至 n 中有多少个反倍数。\n输入格式 　输入的第一行包含一个整数 n。 第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。\n输出格式 　输出一行包含一个整数，表示答案。\n样例输入 30 2 3 6\n样例输出 10\n样例说明 　以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。\n评测用例规模与约定 　对于 40% 的评测用例，1 \u0026lt;= n \u0026lt;= 10000。 对于 80% 的评测用例，1 \u0026lt;= n \u0026lt;= 100000。 对于所有评测用例，1 \u0026lt;= n \u0026lt;= 1000000，1 \u0026lt;= a \u0026lt;= n，1 \u0026lt;= b \u0026lt;= n，1 \u0026lt;= c \u0026lt;= n。\n螺旋矩阵 问题描述 　对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。 例如，一个 4 行 5 列的螺旋矩阵如下： 1 2 3 4 5 14 15 16 17 6 13 20 19 18 7 12 11 10 9 8\n输入格式 　输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。 第二行包含两个整数 r, c，表示要求的行号和列号。\n输出格式 　输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。\n样例输入 4 5 2 2\n样例输出 15\n评测用例规模与约定 　对于 30% 的评测用例，2 \u0026lt;= n, m \u0026lt;= 20。 对于 70% 的评测用例，2 \u0026lt;= n, m \u0026lt;= 100。 对于所有评测用例，2 \u0026lt;= n, m \u0026lt;= 1000，1 \u0026lt;= r \u0026lt;= n，1 \u0026lt;= c \u0026lt;= m。\n摆动序列 问题描述 　如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]\u0026lt;a[2i-1], a[2i+1]\u0026gt;a[2i]。 小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。\n输入格式 　输入一行包含两个整数 m，n。\n输出格式 　输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。\n样例输入 3 4\n样例输出 14\n样例说明 　以下是符合要求的摆动序列： 2 1 2 2 1 3 2 1 4 3 1 2 3 1 3 3 1 4 3 2 3 3 2 4 4 1 2 4 1 3 4 1 4 4 2 3 4 2 4 4 3 4\n评测用例规模与约定 　对于 20% 的评测用例，1 \u0026lt;= n, m \u0026lt;= 5； 对于 50% 的评测用例，1 \u0026lt;= n, m \u0026lt;= 10； 对于 80% 的评测用例，1 \u0026lt;= n, m \u0026lt;= 100； 对于所有评测用例，1 \u0026lt;= n, m \u0026lt;= 1000。\n户户通电 问题描述 　2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。 这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。 现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。 小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为 sqrt((x_1-x_2)(x_1-x_2)+(y_1-y_2)(y_1-y_2))+(h_1-h_2)*(h_1-h_2)。 在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。 由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。\n输入格式 　输入的第一行包含一个整数 n ，表示村庄的数量。 接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。\n输出格式 　输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。\n样例输入 4 1 1 3 9 9 7 8 8 6 4 5 4\n样例输出 17.41\n评测用例规模与约定 　对于 30% 的评测用例，1 \u0026lt;= n \u0026lt;= 10； 对于 60% 的评测用例，1 \u0026lt;= n \u0026lt;= 100； 对于所有评测用例，1 \u0026lt;= n \u0026lt;= 1000，0 \u0026lt;= x, y, h \u0026lt;= 10000。\n郊外植树 问题描述 　小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。 小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。 然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。 他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。 小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。\n输入格式 　输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。 接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。\n输出格式 　输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。\n样例输入 6 1 1 2 1 4 2 1 7 2 4 1 2 4 4 2 4 7 2\n样例输出 12\n评测用例规模与约定 　对于 30% 的评测用例，1 \u0026lt;= n \u0026lt;= 10； 对于 60% 的评测用例，1 \u0026lt;= n \u0026lt;= 20； 对于所有评测用例，1 \u0026lt;= n \u0026lt;= 30，0 \u0026lt;= x, y \u0026lt;= 1000，1 \u0026lt;= r \u0026lt;= 1000。\n","date":1587785107,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587785107,"objectID":"4c7d9d8a44a039b41df109790b3059a9","permalink":"https://visors.github.io/post/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F/","publishdate":"2020-04-25T11:25:07+08:00","relpermalink":"/post/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F/","section":"post","summary":"填空题 对于填空题，其实很多时候枚举啊之类的就完事了。但是作为整理，我认为认真的态度是把它当成独立的可以用编程解决的普适的问题来分析，所以下面我会写上每道题的题目改编及思路。\n 问题描述 将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。 请问，总共能排列如多少个不同的单词。\n答案 $2520$\n改编 给定一个字符串，求可以得到的排列数。\n戏说 根据组合数学原理，统计不同的字符数$n$，以及不同字符出现的个数$tot[i]$，那么结果即为$\\frac{n!}{\\prod_{i=1}^n{tot[i]!}}$\n 问题描述 一个包含有2019个结点的无向连通图，最少包含多少条边？\n答案 $2018$\n改编一 一个包含有$n$个结点的无向连通图，最少包含多少条边？\n戏说 该图应为一条链，边数为$n-1$\n改编二 一个包含有$n$个结点的无向连通图，最多包含多少条边？\n戏说 该图应为完全图，边数为$\\frac{(1+(n-1))(n-1)}{2}=\\frac{n(n-1)}{2}$\n 问题描述 在计算机存储中，12.5MB是多少字节？\n答案 $13107200$","tags":["lanqiao","Solution Report"],"title":"蓝桥省赛模拟","type":"post"},{"authors":["Visors"],"categories":["Codeforces","Solution Report"],"content":"碎碎念 终于上分了真的，感觉可以冲到一两千名的（C代码出的时候提交还不多），结果C沉了，最终只有六千名。毕竟这次手稍微快hhh。本来以为我C的代码够简洁了，没想到正解好像更简洁……\n这次真的是非常遗憾，C和D都接近想到正解，却没有最终AC。另外吐槽一下本场的题面，是真的难读……不过题目质量还是在线的。\n解题报告 C - Nastya and Strange Generator C的题目很难读，直接把LYH读崩了，所以这里我先简要翻译一下。\n本题需要我们按照规则检查题目给出的排列能否被生成。开始时排列$p$为空，然后我们按照以下规则依次将$1\\sim n$填入排列，一开始$i=1$：\n 计算$r$数组，$r[j]=min(t\\in [j,n])$，其中$p[t]~is~empty$即没有被填过，如果不存在这样一个$j$，我们可以用$0$之类的特殊数表示 计算$count$数组，$count[j]$为$r[]$中$j$的数目 $count$数组中值最大的下标为$i$的可放置点 将$i$放入排列，$i++$，转到1.，直到$n$个数被填完  根据这个规则，再结合样例解释，就能够理解了：\n![](C Note.png)\n如果暴力，显然$O(n^2)$超时，这两个$n$分别是枚举每位数的时间和检查每个数能不能填的时间。我们可以考虑优化其中之一，枚举每位数显然很难优化，就看能否优化检查每个数的时间，只要降到$O(logn)$以下，本题就可解决。\n于是乎我们可以研究一下$r$和$count$的生成方法，很容易发现这两个数组在填$i$和$i+1$时是有一定的转移规律的。然后我想到的规律是：\n 上一个数填在最右边，那么前面的$r$数组不会受影响，进而$count$数组也不会受影响，所以当前数可以填在任意空余位置。 上一个数不在最右边，那么它只会直接影响它自己的$r$，使得其对应下标$r$变为其右边没填的最近的位置，进而打破$count$数组的平衡，使那个位置的count突然比别的多，这时候这个数必须填在那。  /**\r* @Project Codeforces_Round__637__Div__2_\r* @Filename Nastya_and_Strange_Generator\r* @Author Visors\r* @Date 2020/4/23 23:56\r* @Version 1.0\r* @Description TODO\r**/\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;cstring\u0026gt;\rusing namespace std;\rconst int N = 1e5 + 5;\rint T, n;\rint pos[N];\rbool book[N];\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcin \u0026gt;\u0026gt; T;\rwhile (T--) {\rmemset(book, 0, sizeof(book));\rcin \u0026gt;\u0026gt; n;\rfor (int i = 1, t; i \u0026lt;= n; i++) {\rcin \u0026gt;\u0026gt; t;\rpos[t] = i;\r}\rint r = n;\rbool flag = true;\rbook[pos[1]] = true;\rfor (int i = 2; i \u0026lt;= n; i++) {\rif (pos[i - 1] != r) {\rint tmp = pos[i - 1];\rwhile (book[tmp]) tmp++;\rif (tmp != pos[i]) {\rflag = false;\rbreak;\r} else book[tmp] = true;\r}\rif (pos[i - 1] == r) {\rbook[pos[i]] = true;\rr--;\r}\r}\rif (flag) cout \u0026lt;\u0026lt; \u0026quot;Yes\u0026quot; \u0026lt;\u0026lt; endl;\relse cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r}\r 但是在第二个测试点错了，希望有读者能帮我指出一下问题在哪里。\n正解是判断有没有$p[i]-p[i-1]\u0026gt;1$，如果有那么不能生成。感觉跟我的比较像，不知道差异点是在哪里……\n/*\r* @Filename Nastya_and_Strange_Generator.cpp\r* @Author Visors\r* @Date 2020/4/24 11:07\r* @Version 1.0\r* @Description TODO\r**/\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;vector\u0026gt;\rusing namespace std;\rint T, n;\rvector\u0026lt;int\u0026gt; p;\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcin \u0026gt;\u0026gt; T;\rwhile (T--) {\rcin \u0026gt;\u0026gt; n;\rp = vector\u0026lt;int\u0026gt;(n);\rcin \u0026gt;\u0026gt; p[0];\rbool flag = true;\rfor (int i = 1; i \u0026lt; n; i++) {\rcin \u0026gt;\u0026gt; p[i];\rif (p[i] - p[i - 1] \u0026gt; 1) flag = false;\r}\rif (flag) cout \u0026lt;\u0026lt; \u0026quot;Yes\u0026quot; \u0026lt;\u0026lt; endl;\relse cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r}\r to be continue……\n","date":1587693465,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587693465,"objectID":"457cf20316621d72dc73e67bdc1dda05","permalink":"https://visors.github.io/post/codeforces-round-637-div.2/","publishdate":"2020-04-24T09:57:45+08:00","relpermalink":"/post/codeforces-round-637-div.2/","section":"post","summary":"碎碎念 终于上分了真的，感觉可以冲到一两千名的（C代码出的时候提交还不多），结果C沉了，最终只有六千名。毕竟这次手稍微快hhh。本来以为我C的代码够简洁了，没想到正解好像更简洁……\n这次真的是非常遗憾，C和D都接近想到正解，却没有最终AC。另外吐槽一下本场的题面，是真的难读……不过题目质量还是在线的。\n解题报告 C - Nastya and Strange Generator C的题目很难读，直接把LYH读崩了，所以这里我先简要翻译一下。\n本题需要我们按照规则检查题目给出的排列能否被生成。开始时排列$p$为空，然后我们按照以下规则依次将$1\\sim n$填入排列，一开始$i=1$：\n 计算$r$数组，$r[j]=min(t\\in [j,n])$，其中$p[t]~is~empty$即没有被填过，如果不存在这样一个$j$，我们可以用$0$之类的特殊数表示 计算$count$数组，$count[j]$为$r[]$中$j$的数目 $count$数组中值最大的下标为$i$的可放置点 将$i$放入排列，$i++$，转到1.，直到$n$个数被填完  根据这个规则，再结合样例解释，就能够理解了：\n![](C Note.png)\n如果暴力，显然$O(n^2)$超时，这两个$n$分别是枚举每位数的时间和检查每个数能不能填的时间。我们可以考虑优化其中之一，枚举每位数显然很难优化，就看能否优化检查每个数的时间，只要降到$O(logn)$以下，本题就可解决。\n于是乎我们可以研究一下$r$和$count$的生成方法，很容易发现这两个数组在填$i$和$i+1$时是有一定的转移规律的。然后我想到的规律是：\n 上一个数填在最右边，那么前面的$r$数组不会受影响，进而$count$数组也不会受影响，所以当前数可以填在任意空余位置。 上一个数不在最右边，那么它只会直接影响它自己的$r$，使得其对应下标$r$变为其右边没填的最近的位置，进而打破$count$数组的平衡，使那个位置的count突然比别的多，这时候这个数必须填在那。  /**\r* @Project Codeforces_Round__637__Div__2_\r* @Filename Nastya_and_Strange_Generator\r* @Author Visors\r* @Date 2020/4/23 23:56\r* @Version 1.","tags":["Codeforces","Solution Report"],"title":"Codeforces Round 637 Div.2","type":"post"},{"authors":["Visors"],"categories":["Free Talk"],"content":"近期我常常因为国内外社交媒体下的评论而感到十分恼火，一方面，推特如同催眠般向我推荐反华言论——尽管我关注的人中没有反华分子，反倒是有马云先生、华春莹女士等——另一方面国内媒体如微博、看点下的无脑节奏也让我愤愤不平。但反观我周围，即便我并非处于什么文化人之行列，却仍鲜少有言论无脑之人。于是我陷入了既因为网络无脑节奏之多而怀疑整体网民素质，又因为周围人并没有参与其中而一定程度否定前者的矛盾当中。不过今天饭桌的闲谈中，我似乎突然明白了些什么。\n当今社交媒体评论显示几乎都是基于热度，我们可以思考热评究竟是如何诞生的。只有在热评尚未诞生之时，我们所看见的热评才几乎等同于最新评论，这时第一批围观者或发表他们的看法，或进行点评赞踩，于是一些言论被顶上前排，成了真正的热评。如果你是后来者，你直接看到的就是他人的热评，大多数人不会有翻看最新评论的习惯，所以往往你发送的迟来的评论并不会引人关注。而事实往往是后来者更倾向于理性看待问题，冲在前面的人往往评论还没经过深度思考，便草草发布，甚至为上热评，刻意带起节奏，而只有这部分的人更容易成为热评，真正理性的评论，却大多数被节奏所淹没，隐藏在了最新评论，或者介于最新评论和热门评论之间的“看不见的地带”。\n诚然互联网给每个人都带来了网络时代的红利，但目前以热度为基础的网络环境，却实实在在诱导了一些网民的内心，而这种言论一经热度放大，带起的节奏却不是一般人能理性看待的，类似的还有流量热度至上的无良自媒体。尽管热度害人，能让毫无营养的评论走上热评，网民的不理性仍是关键一环，而想让每个人都能从感性认识快速走向理性认识，几乎是不可能完成的事情，如此一想，我不必轻易为评论所左右，我有我自己的理性思考，我也不必为评论所生气，因为它们往往代表着的是所有声音中最不理智的那一些。\n","date":1587622082,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587622082,"objectID":"27efd7fabb67b53aabe318ae7dc22fe8","permalink":"https://visors.github.io/post/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E8%BD%BB%E4%BF%A1%E8%AF%84%E8%AE%BA/","publishdate":"2020-04-23T14:08:02+08:00","relpermalink":"/post/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E8%BD%BB%E4%BF%A1%E8%AF%84%E8%AE%BA/","section":"post","summary":"你会因为网上无脑的言论而生气吗？如果会，也许你能从这篇文章中找到一点慰藉。","tags":["Free Talk"],"title":"我们为何不能轻信评论","type":"post"},{"authors":["Visors"],"categories":["Codeforces","Solution Report"],"content":"碎碎念 最近开始参加Codeforces Round——注册四五年，才打四五场比赛。\n不打打CF还不知道自己竟然这么菜，打个div3先是手速过慢被一众巨巨甩掉，后面偏难题目又A不掉不能实现弯道超车，菜的真实，后面还得加大力度，早日冲上1900分。\n解题报告 D - Constant Palindrome Sum 这题看上去好想二分一波，但实际上并没有什么好的局部转移的规则。由于这场基本都是数学思维题，所以感觉这题也是这个方向。一开始被题面迷惑了一波，以为minimum是要每次改变最小的数，然后YY半天发现其实是最少次改变数……\n思考的时候已经发现了Tutorial中的三点：\n We don\u0026rsquo;t need to change anything in this pair; we can replace one element to fix this pair; we need to replace both elements to fix this pair.  也想到要hash各个pair对应的x值，不过因为题意读错的原因老是把两个时期的思维过程搞混，导致本Round直线下分，冷静想想自己已经找到近似解了，比赛的时候还是有点不太理智。\n 其实思路非常简单，题目只考虑$a[i]+a[n-i+1]$，所以我们可以把$a[i]$和$a[n-i+1]$视为一对$pair$。\n首先我们读入所有的$pair$，然后对于每对$pair$，我们可以考虑将其三种分类下的作用范围转化为区间涂色问题。线段树可以解决区间涂色问题，但是在这里前缀和更优，参考color the ball那道题目。\n怎么将其转化为区间涂色问题呢？\n对于第一种分类，该$pair$和就为其简单相加。\n对于第二种分类，我们可以考虑固定$pair$的任意元素，改变另外一个元素。例如对于$pair\u0026lt;a,b\u0026gt;$，我们固定$a$，那么由于$b$的改动范围是$[1,k]$，所以整个$pair$的取值范围就是$[a+1,a+k]$，同理也可以固定$b$，改动$a$.\n对于第三种分类，若设全局$U=[2,2k]$，那么两种都需要改动的范围就是$U-([a+1,a+k]\\cup [b+1,b+k]\\cup {a+b })$啦\n从上述情况来看，我们可以声明两个数组，一个数组$pref$用来做前缀和，一个数组$cnt$来统计第一种分类出现的次数，这样就能知道取任意$x$时需要修改的次数，即$pref[x]-cnt[x]+2*(n/2-pref[x])$（第二种分类减去前缀和中多统计的第一种分类，再加上第三种分类）。\n/**\r* @Project Codeforces_Round__636__Div__3_\r* @Filename Constant_Palindrome_Sum\r* @Author Visors\r* @Date 2020/4/22 22:23\r* @Version 1.0\r* @Description TODO\r**/\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;algorithm\u0026gt;\r#include \u0026lt;vector\u0026gt;\rusing namespace std;\rint T, n, k, ans;\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcin \u0026gt;\u0026gt; T;\rwhile (T--) {\rcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\rvector\u0026lt;int\u0026gt; a(n), cnt(2 * k + 1), pref(2 * k + 2); //cnt pref多留一个空间避免超界，pref本身有可能操作2*k+1，所以这里+2\rfor (auto \u0026amp;it:a) cin \u0026gt;\u0026gt; it; //Editor这么写的，我也学一波\rfor (int i = 0; i \u0026lt; n / 2; i++) cnt[a[i] + a[n - i - 1]]++; //下标0开始，n-i+1变成n-i-1\rfor (int i = 0; i \u0026lt; n / 2; i++) {\rint l1 = a[i] + 1, r1 = a[i] + k; //固定左边\rint l2 = a[n - i - 1] + 1, r2 = a[n - i - 1] + k; //固定右边\rpref[min(l1, l2)]++;\rpref[max(r1, r2) + 1]--;\r}\rfor (int i = 1; i \u0026lt;= 2 * k + 1; i++) pref[i] += pref[i - 1];\rans = 1e9;\rfor (int x = 2; x \u0026lt;= 2 * k; x++) ans = min(ans, (pref[x] - cnt[x]) + 2 * (n / 2 - pref[x]));\rcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r}\r E - Weights Distributing 这题虽然是2400分，但我觉得我是可写的，只是比赛连看都没看一眼，前面还需压缩时间。\n 这道题题面比较长，但其实核心问题比较简单：\n给定$n$个点$m$条边的无向联通图，先给定$m$个边权$p_i$，问如何分配边权，能使从点$a$到点$b$，再从点$b$到点$c$走过的权值最小。\n初读题目，可能会觉得这题过水——跑一遍从$a$到$b$的最短路，再跑一遍从$b$到$c$的最短路，然后贪心从小到大取边权，如果两个最短路中间有重复路段就优先取重复的部分。\n这种想法有可取之处，即把最终选取的路径分为了两类：\n 两段路有重合部分 两段路没有重复部分  但却忽视了关键问题，即求得的最短路很可能有多条，而选择其中的不同条，会产生不一样的分组结果。其实我们希望重复部分尽量多，但沿用上一方法很难处理。这时候如果把路径的选取看成这样：设两段路的交点为$x$，那么上面的两类可以被描述为：\n $a$-\u0026gt;$x$-\u0026gt;$b$-\u0026gt;$x$-\u0026gt;$c$ $a$-\u0026gt;$b(x)$-\u0026gt;$c$  两种情况对应下图：\ngraph LR;\rsubgraph situation1\ra((a))--\u0026gt;x((x));\rx((x))--\u0026gt;b((b));\rb((b))--\u0026gt;x((x));\rx((x))--\u0026gt;c((c));\rend\rsubgraph situation2\rA((a))--\u0026gt;B((b=x));\rB((b=x))--\u0026gt;C((c));\rend\r 于是我们很容易想到求出$a,b,c$到各点的最短路，枚举$x$，找到最小的$dist(a,x)+2*dist(b,x)+dist(c,x)$即为题目要求的答案。\n因为我们一开始只需要求边数即边权为$1$的最短路径的长度，所以用BFS就可以处理。\n/**\r* @Project Codeforces_Round__636__Div__3_\r* @Filename Weights_Distributing\r* @Author Visors\r* @Date 2020/4/23 21:03\r* @Version 1.0\r* @Description TODO\r**/\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;vector\u0026gt;\r#include \u0026lt;algorithm\u0026gt;\r#include \u0026lt;queue\u0026gt;\rusing namespace std;\rconst int oo = 1e9 + 7;\rint T, n, m, a, b, c;\rvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; //内存占用大的声明在全局\rvoid bfs(int v, vector\u0026lt;int\u0026gt; \u0026amp;dist) { //这里传的是引用，不会爆栈\rdist[v] = 0;\rqueue\u0026lt;int\u0026gt; q;\rq.push(v);\rwhile (!q.empty()) {\rint t = q.front();\rq.pop();\rfor (auto it:G[t]) {\rif (dist[it] == oo) {\rdist[it] = dist[t] + 1;\rq.push(it);\r}\r}\r}\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcin \u0026gt;\u0026gt; T;\rwhile (T--) {\rcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c;\rvector\u0026lt;int\u0026gt; p(m + 1);\rfor (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; p[i];\rsort(p.begin() + 1, p.end()); //从大到小排序\rvector\u0026lt;long long\u0026gt; pref(m + 1); //求前缀和，方便后面快速取最小的路径\rfor (int i = 1; i \u0026lt;= m; i++) pref[i] = pref[i - 1] + p[i];\rG = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n + 1);\rfor (int i = 1, s, t; i \u0026lt;= m; i++) {\rcin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t;\rG[s].push_back(t);\rG[t].push_back(s);\r}\rvector\u0026lt;int\u0026gt; distA(n + 1, oo), distB(n + 1, oo), distC(n + 1, oo);\rbfs(a, distA);\rbfs(b, distB);\rbfs(c, distC);\rlong long ans = 1e18;\rfor (int x = 1; x \u0026lt;= n; x++) {\rif (distA[x] + distB[x] + distC[x] \u0026gt; m) continue; //分不了直接跳过\rans = min(ans, pref[distB[x]] + pref[distA[x] + distB[x] + distC[x]]);\r// = 2 * pref[distB[x]] + (pref[distA[x] + distB[x] + distC[x]] - pref[distB[x]])\r}\rcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r}\r ","date":1587561202,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587561202,"objectID":"2d03ea4d7f40200d1734bc39e1468938","permalink":"https://visors.github.io/post/codeforces-round-636-div.3/","publishdate":"2020-04-22T21:13:22+08:00","relpermalink":"/post/codeforces-round-636-div.3/","section":"post","summary":"最近开始参加Codeforces Round——注册四五年，才打四五场比赛。不打打CF还不知道自己竟然这么菜，打个div3先是手速过慢被一众巨巨甩掉，后面偏难题目又A不掉不能实现弯道超车，菜的真实，后面还得加大力度，早日冲上1900分。","tags":["Codeforces","Solution Report","BFS","Greedy","Prefix Sum"],"title":"Codeforces Round 636 Div.3","type":"post"}]