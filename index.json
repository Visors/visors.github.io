[{"authors":["admin"],"categories":null,"content":"万祚全，常用网名Visors，大二本科生，现就读于中南民族大学，校ACM队负责人。平时主攻算法竞赛，最近闲时在研究 Android 开发，有几个APP构想，待学成后尝试实现。对爬虫等技术也有一点涉猎。对于我熟悉的领域或我组织的相关事宜，欢迎邮件或电报交流。\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://visors.github.io/author/%E4%B8%87%E7%A5%9A%E5%85%A8/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/%E4%B8%87%E7%A5%9A%E5%85%A8/","section":"authors","summary":"万祚全，常用网名Visors，大二本科生，现就读于中南民族大学，校ACM队负责人。平时主攻算法竞赛，最近闲时在研究 Android 开发，有几个APP构想，待学成后尝试实现。对爬虫等技术也有一点涉猎。对于我熟悉的领域或我组织的相关事宜，欢迎邮件或电报交流。","tags":null,"title":"万祚全","type":"authors"},{"authors":["Visors"],"categories":["Free Talk"],"content":"近期我常常因为国内外社交媒体下的评论而感到十分恼火，一方面，推特如同催眠般向我推荐反华言论——尽管我关注的人中没有反华分子，反倒是有马云先生、华春莹女士等——另一方面国内媒体如微博、看点下的无脑节奏也让我愤愤不平。但反观我周围，即便我并非处于什么文化人之行列，却仍鲜少有言论无脑之人。于是我陷入了既因为网络无脑节奏之多而怀疑整体网民素质，又因为周围人并没有参与其中而一定程度否定前者的矛盾当中。不过今天饭桌的闲谈中，我似乎突然明白了些什么。\n当今社交媒体评论显示几乎都是基于热度，我们可以思考热评究竟是如何诞生的。只有在热评尚未诞生之时，我们所看见的热评才几乎等同于最新评论，这时第一批围观者或发表他们的看法，或进行点评赞踩，于是一些言论被顶上前排，成了真正的热评。如果你是后来者，你直接看到的就是他人的热评，大多数人不会有翻看最新评论的习惯，所以往往你发送的迟来的评论并不会引人关注。而事实往往是后来者更倾向于理性看待问题，冲在前面的人往往评论还没经过深度思考，便草草发布，甚至为上热评，刻意带起节奏，而只有这部分的人更容易成为热评，真正理性的评论，却大多数被节奏所淹没，隐藏在了最新评论，或者介于最新评论和热门评论之间的“看不见的地带”。\n诚然互联网给每个人都带来了网络时代的红利，但目前以热度为基础的网络环境，却实实在在诱导了一些网民的内心，而这种言论一经热度放大，带起的节奏却不是一般人能理性看待的，类似的还有流量热度至上的无良自媒体。尽管热度害人，能让毫无营养的评论走上热评，网民的不理性仍是关键一环，而想让每个人都能从感性认识快速走向理性认识，几乎是不可能完成的事情，如此一想，我不必轻易为评论所左右，我有我自己的理性思考，我也不必为评论所生气，因为它们往往代表着的是所有声音中最不理智的那一些。\n","date":1587622082,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587622082,"objectID":"27efd7fabb67b53aabe318ae7dc22fe8","permalink":"https://visors.github.io/post/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E8%BD%BB%E4%BF%A1%E8%AF%84%E8%AE%BA/","publishdate":"2020-04-23T14:08:02+08:00","relpermalink":"/post/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E8%BD%BB%E4%BF%A1%E8%AF%84%E8%AE%BA/","section":"post","summary":"你会因为网上无脑的言论而生气吗？如果会，也许你能从这篇文章中找到一点慰藉。","tags":["Free Talk"],"title":"我们为何不能轻信评论","type":"post"},{"authors":["Visors"],"categories":["Codeforces","Solution Report"],"content":"碎碎念 最近开始参加Codeforces Round——注册四五年，才打四五场比赛。\n不打打CF还不知道自己竟然这么菜，打个div3先是手速过慢被一众巨巨甩掉，后面偏难题目又A不掉不能实现弯道超车，菜的真实，后面还得加大力度，早日冲上1900分。\n解题报告 D - Constant Palindrome Sum 这题看上去好想二分一波，但实际上并没有什么好的局部转移的规则。由于这场基本都是数学思维题，所以感觉这题也是这个方向。一开始被题面迷惑了一波，以为minimum是要每次改变最小的数，然后YY半天发现其实是最少次改变数……\n思考的时候已经发现了Tutorial中的三点：\n We don\u0026rsquo;t need to change anything in this pair; we can replace one element to fix this pair; we need to replace both elements to fix this pair.  也想到要hash各个pair对应的x值，不过因为题意读错的原因老是把两个时期的思维过程搞混，导致本Round直线下分，冷静想想自己已经找到近似解了，比赛的时候还是有点不太理智。\n 其实思路非常简单，题目只考虑$a[i]+a[n-i+1]$，所以我们可以把$a[i]$和$a[n-i+1]$视为一对$pair$。\n首先我们读入所有的$pair$，然后对于每对$pair$，我们可以考虑将其三种分类下的作用范围转化为区间涂色问题。线段树可以解决区间涂色问题，但是在这里前缀和更优，参考color the ball那道题目。\n怎么将其转化为区间涂色问题呢？\n对于第一种分类，该$pair$和就为其简单相加。\n对于第二种分类，我们可以考虑固定$pair$的任意元素，改变另外一个元素。例如对于$pair\u0026lt;a,b\u0026gt;$，我们固定$a$，那么由于$b$的改动范围是$[1,k]$，所以整个$pair$的取值范围就是$[a+1,a+k]$，同理也可以固定$b$，改动$a$.\n对于第三种分类，若设全局$U=[2,2k]$，那么两种都需要改动的范围就是$U-([a+1,a+k]\\cup [b+1,b+k]\\cup {a+b })$啦\n从上述情况来看，我们可以声明两个数组，一个数组$pref$用来做前缀和，一个数组$cnt$来统计第一种分类出现的次数，这样就能知道取任意$x$时需要修改的次数，即$pref[x]-cnt[x]+2*(n/2-pref[x])$（第二种分类减去前缀和中多统计的第一种分类，再加上第三种分类）。\n/**\r* @Project Codeforces_Round__636__Div__3_\r* @Filename Constant_Palindrome_Sum\r* @Author Visors\r* @Date 2020/4/22 22:23\r* @Version 1.0\r* @Description TODO\r**/\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;algorithm\u0026gt;\r#include \u0026lt;vector\u0026gt;\rusing namespace std;\rint T, n, k, ans;\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcin \u0026gt;\u0026gt; T;\rwhile (T--) {\rcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\rvector\u0026lt;int\u0026gt; a(n), cnt(2 * k + 1), pref(2 * k + 2); //cnt pref多留一个空间避免超界，pref本身有可能操作2*k+1，所以这里+2\rfor (auto \u0026amp;it:a) cin \u0026gt;\u0026gt; it; //Editor这么写的，我也学一波\rfor (int i = 0; i \u0026lt; n / 2; i++) cnt[a[i] + a[n - i - 1]]++; //下标0开始，n-i+1变成n-i-1\rfor (int i = 0; i \u0026lt; n / 2; i++) {\rint l1 = a[i] + 1, r1 = a[i] + k; //固定左边\rint l2 = a[n - i - 1] + 1, r2 = a[n - i - 1] + k; //固定右边\rpref[min(l1, l2)]++;\rpref[max(r1, r2) + 1]--;\r}\rfor (int i = 1; i \u0026lt;= 2 * k + 1; i++) pref[i] += pref[i - 1];\rans = 1e9;\rfor (int x = 2; x \u0026lt;= 2 * k; x++) ans = min(ans, (pref[x] - cnt[x]) + 2 * (n / 2 - pref[x]));\rcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r}\r E - Weights Distributing 这题虽然是2400分，但我觉得我是可写的，只是比赛连看都没看一眼，前面还需压缩时间。\n 这道题体面比较长，但其实核心问题比较简单：\n给定$n$个点$m$条边的无向联通图，先给定$m$个边权$p_i$，问如何分配边权，能使从点$a$到点$b$，再从点$b$到点$c$走过的权值最小。\n初读题目，可能会觉得这题过水——跑一遍从$a$到$b$的最短路，再跑一遍从$b$到$c$的最短路，然后贪心从小到大取边权，如果两个最短路中间有重复路段就优先取重复的部分。\n这种想法有可取之处，即把最终选取的路径分为了两类：\n 两段路有重合部分 两段路没有重复部分  但却忽视了关键问题，即求得的最短路很可能有多条，而选择其中的不同条，会产生不一样的分组结果。其实我们希望重复部分尽量多，但沿用上一方法很难处理。这时候如果把路径的选取看成这样：设两段路的交点为$x$，那么上面的两类可以被描述为：\n $a$-\u0026gt;$x$-\u0026gt;$b$-\u0026gt;$x$-\u0026gt;$c$ $a$-\u0026gt;$b(x)$-\u0026gt;$c$  两种情况对应下图：\ngraph LR;\rsubgraph situation1\ra((a))--\u0026gt;x((x));\rx((x))--\u0026gt;b((b));\rb((b))--\u0026gt;x((x));\rx((x))--\u0026gt;c((c));\rend\rsubgraph situation2\rA((a))--\u0026gt;B((b=x));\rB((b=x))--\u0026gt;C((c));\rend\r 于是我们很容易想到求出$a,b,c$到各点的最短路，枚举$x$，找到最小的$dist(a,x)+2*dist(b,x)+dist(c,x)$即为题目要求的答案。\n因为我们一开始只需要求边数即边权为$1$的最短路径的长度，所以用BFS就可以处理。\n/**\r* @Project Codeforces_Round__636__Div__3_\r* @Filename Weights_Distributing\r* @Author Visors\r* @Date 2020/4/23 21:03\r* @Version 1.0\r* @Description TODO\r**/\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;vector\u0026gt;\r#include \u0026lt;algorithm\u0026gt;\r#include \u0026lt;queue\u0026gt;\rusing namespace std;\rconst int oo = 1e9 + 7;\rint T, n, m, a, b, c;\rvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; //内存占用大的声明在全局\rvoid bfs(int v, vector\u0026lt;int\u0026gt; \u0026amp;dist) { //这里传的是引用，不会爆栈\rdist[v] = 0;\rqueue\u0026lt;int\u0026gt; q;\rq.push(v);\rwhile (!q.empty()) {\rint t = q.front();\rq.pop();\rfor (auto it:G[t]) {\rif (dist[it] == oo) {\rdist[it] = dist[t] + 1;\rq.push(it);\r}\r}\r}\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcin \u0026gt;\u0026gt; T;\rwhile (T--) {\rcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c;\rvector\u0026lt;int\u0026gt; p(m + 1);\rfor (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; p[i];\rsort(p.begin() + 1, p.end()); //从大到小排序\rvector\u0026lt;long long\u0026gt; pref(m + 1); //求前缀和，方便后面快速取最小的路径\rfor (int i = 1; i \u0026lt;= m; i++) pref[i] = pref[i - 1] + p[i];\rG = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n + 1);\rfor (int i = 1, s, t; i \u0026lt;= m; i++) {\rcin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t;\rG[s].push_back(t);\rG[t].push_back(s);\r}\rvector\u0026lt;int\u0026gt; distA(n + 1, oo), distB(n + 1, oo), distC(n + 1, oo);\rbfs(a, distA);\rbfs(b, distB);\rbfs(c, distC);\rlong long ans = 1e18;\rfor (int x = 1; x \u0026lt;= n; x++) {\rif (distA[x] + distB[x] + distC[x] \u0026gt; m) continue; //分不了直接跳过\rans = min(ans, pref[distB[x]] + pref[distA[x] + distB[x] + distC[x]]);\r// = 2 * pref[distB[x]] + (pref[distA[x] + distB[x] + distC[x]] - pref[distB[x]])\r}\rcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r}\r ","date":1587561202,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587561202,"objectID":"2d03ea4d7f40200d1734bc39e1468938","permalink":"https://visors.github.io/post/codeforces-round-636-div.3/","publishdate":"2020-04-22T21:13:22+08:00","relpermalink":"/post/codeforces-round-636-div.3/","section":"post","summary":"最近开始参加Codeforces Round——注册四五年，才打四五场比赛。不打打CF还不知道自己竟然这么菜，打个div3先是手速过慢被一众巨巨甩掉，后面偏难题目又A不掉不能实现弯道超车，菜的真实，后面还得加大力度，早日冲上1900分。","tags":["Codeforces","Solution Report","BFS","Greedy","Prefix Sum"],"title":"Codeforces Round 636 Div.3","type":"post"}]