<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Visors的个人主页</title>
    <link>https://visors.github.io/post/</link>
      <atom:link href="https://visors.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>©2020 万祚全 All rights reserved</copyright>
    <image>
      <url>https://visors.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Posts</title>
      <link>https://visors.github.io/post/</link>
    </image>
    
    <item>
      <title>第六届蓝桥杯国赛解题报告</title>
      <link>https://visors.github.io/post/%E7%AC%AC%E5%85%AD%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</link>
      <pubDate>Tue, 10 Nov 2020 19:53:31 +0800</pubDate>
      <guid>https://visors.github.io/post/%E7%AC%AC%E5%85%AD%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</guid>
      <description>&lt;link href=&#34;https://fonts.googleapis.com/css2?family=Long+Cang&amp;display=swap&#34; rel=&#34;stylesheet&#34;&gt;
&lt;div style=&#34;font-family:&#39;Long Cang&#39;&#34;&gt;
&lt;center&gt;你是太阳 每个人都敬仰&lt;/center&gt;
&lt;center&gt;围著你 我变得不一样&lt;/center&gt;
&lt;center&gt;彩色希望 燃烧璨亮&lt;/center&gt;
&lt;center&gt;我的混沌找到方向&lt;/center&gt;
&lt;center&gt;我是冥王 每个人都遗忘&lt;/center&gt;
&lt;center&gt;抱著你 我发现我的光&lt;/center&gt;
&lt;center&gt;忘掉重量 感情漫长&lt;/center&gt;
&lt;center&gt;我的脆弱有你分享&lt;/center&gt;
&lt;center&gt;那么坚强&lt;/center&gt;
&lt;p align=&#34;right&#34;&gt;&lt;i&gt;——林奕匡《冥王星》&lt;/i&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;a href=&#34;#content&#34;&gt;&lt;i&gt;jump to content&lt;/i&gt;&lt;/a&gt;
&lt;p&gt;最近身体状况不太好，导致干事的热情和效率不是很高，今天突然被告知周末就是蓝桥国赛了，惊地赶紧加班加点做做真题、复习一些知识。虽然今年的省赛让我感觉做往年真题的意义不大（难度不是一个等级的），但是做总比不做要好，就当是一个自我检查，同时严格要求自己不能套板子，必须能按照自己的理解独立写出来。&lt;/p&gt;
&lt;h2 id=&#34;积分之谜&#34;&gt;积分之谜&lt;/h2&gt;
&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;小明开了个网上商店，卖风铃。共有3个品牌：A，B，C。&lt;/p&gt;
&lt;p&gt;为了促销，每件商品都会返固定的积分。&lt;/p&gt;
&lt;p&gt;小明开业第一天收到了三笔订单：&lt;/p&gt;
&lt;p&gt;第一笔：3个A + 7个B + 1个C，共返积分：315&lt;/p&gt;
&lt;p&gt;第二笔：4个A + 10个B + 1个C，共返积分：420&lt;/p&gt;
&lt;p&gt;第三笔：A + B + C，共返积分&amp;hellip;.&lt;/p&gt;
&lt;p&gt;你能算出第三笔订单需要返积分多少吗？&lt;/p&gt;
&lt;p&gt;请提交该整数，不要填写任何多余的内容。&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;
&lt;p&gt;这就是个很简单的三元一次方程组，已知两方程，求另一方程的问题。&lt;/p&gt;
&lt;p&gt;设A返积分为$x$，B返积分为$y$，C返积分为$z$，由题意：
$$
\begin{cases}
3x+7y+z=315\\&lt;br&gt;
4x+10y+z=420
\end{cases}\Rightarrow
x+3y=105\&lt;br&gt;
$$
正好，待求式子：
$$
x+y+z=(4x+10y+z)-3(x+3y)=420-3*105=105
$$&lt;/p&gt;
&lt;h3 id=&#34;发散&#34;&gt;发散&lt;/h3&gt;
&lt;p&gt;对于线性方程组，还需回顾高斯消元这一知识。可以参考&lt;a href=&#34;https://blog.csdn.net/u011815404&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Alex_McAvoy&lt;/a&gt;的博客《&lt;a href=&#34;https://blog.csdn.net/u011815404/article/details/88890702&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;线性代数 —— 高斯消元法&lt;/a&gt;》&lt;/p&gt;
&lt;h2 id=&#34;完美正方形&#34;&gt;完美正方形&lt;/h2&gt;
&lt;h3 id=&#34;问题描述-1&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;如果一些边长互不相同的正方形，可以恰好拼出一个更大的正方形，则称其为完美正方形。&lt;/p&gt;
&lt;p&gt;历史上，人们花了很久才找到了若干完美正方形。比如：如下边长的22个正方形&lt;/p&gt;
&lt;p&gt;2 3 4 6 7 8 12 13 14 15 16 17 18 21 22 23 24 26 27 28 50 60&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;图1.png&#34; alt=&#34;图1&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;如【图1.png】那样组合，就是一种解法。此时，&lt;/p&gt;
&lt;p&gt;紧贴上边沿的是：60 50&lt;/p&gt;
&lt;p&gt;紧贴下边沿的是：26 28 17 21 18&lt;/p&gt;
&lt;p&gt;22阶完美正方形一共有8种。下面的组合是另一种：&lt;/p&gt;
&lt;p&gt;2 5 9 11 16 17 19 21 22 24 26 30 31 33 35 36 41 46 47 50 52 61&lt;/p&gt;
&lt;p&gt;如果告诉你该方案紧贴着上边沿的是从左到右依次为：47 46 61，&lt;/p&gt;
&lt;p&gt;你能计算出紧贴着下边沿的是哪几个正方形吗？&lt;/p&gt;
&lt;p&gt;请提交紧贴着下边沿的正方形的边长，从左到右，用空格分开。&lt;/p&gt;
&lt;p&gt;不要填写任何多余的内容或说明文字。&lt;/p&gt;
&lt;h3 id=&#34;分析-1&#34;&gt;分析&lt;/h3&gt;
&lt;p&gt;开始时试图手玩，然后试着按这种思想操作了一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;边长小的大概率在中间补空&lt;/li&gt;
&lt;li&gt;直接挑边界，挑出来的边界应该满足左边和为107，右边和为83，下面的和为154&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是画了会，觉得这样无法确定是否是可行解，而且能够满足上述条件的构造方法也不唯一，&lt;strong&gt;就算我得到了下面一行的数，我还是需要判断是否可行，才能确定这几个数的顺序&lt;/strong&gt;，遂放弃。&lt;/p&gt;
&lt;p&gt;事实上对于填空题而言，能出结果是第一，算法运行效率是其次，只要不慢到出不了结果，最后填上去，都是一样的。那么我们不妨直接暴力解决。&lt;/p&gt;
&lt;p&gt;如果从线段长度（区间来考虑）会很复杂，我们不妨简单点，就把整个图案看成点阵，这样的话，题目中给出的上边沿的正方形的边长是47 46 61这一条件，就可以被解读为我们要对一个154*154的正方形点阵做覆盖，其中上边沿已经覆盖了三个正方形。&lt;/p&gt;
&lt;p&gt;由于最后所有点都会被覆盖，所以我们可以简单的考虑，对任意一个未覆盖的点搜索，依次尝试每一种覆盖情况，最终找到一组合法的解即可。写的时候，完全没必要为了效率而想一些高级方法，比如判断当前位置能不能放特定正方形，只需要两个for遍历检查一下就行了，最大程度减少代码量并避免出错——一旦出错，耗费的Debug时间可不是一会儿半会儿。&lt;/p&gt;
&lt;h3 id=&#34;参考代码&#34;&gt;参考代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//
// Created by Visors on 2020/11/10.
//
// 题目名：完美正方形
// 题目来源：第六届蓝桥杯国赛
// 题目链接：TODO
// 算法：WanMeiZhengFangXing.cpp
// 用途：TODO
// 时间复杂度：O(TODO)
//

#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

int G[154][154];

// 这里的顺序基于我的贪心思想，如果小的正方形放在前面，则搜索树前几层宽度会很大
vector&amp;lt;int&amp;gt; squares{22, 24, 26, 30, 31, 33, 35, 36, 41, 50, 52, 2, 5, 9, 11, 16, 17, 19, 21};
vector&amp;lt;bool&amp;gt; used; // 记录正方形是否被使用过
vector&amp;lt;int&amp;gt; ans; // 记录最后一行答案
bool getAns = false; // 是否找到解

bool checkFill(int x, int y, int len) {
    // 填进去越界了，肯定不行
    if (x + len &amp;gt; 154 || y + len &amp;gt; 154) return false;
    // 填的正方形位置里有一个被填都不行
    for (int i = 0; i &amp;lt; len; i++)
        for (int j = 0; j &amp;lt; len; j++)
            if (G[x + i][y + j]) return false;
    return true;
}

void dfs(int x, int y) {
//    cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl;
    if (getAns) return; // 找到答案立即停止搜索
    for (int i = 0; i &amp;lt; squares.size(); i++) {
        if (getAns) break; // 找到答案立即停止搜索
        if (!used[i]) {
            int &amp;amp;len = squares[i];
            if (checkFill(x, y, len)) {
                // 填上
                used[i] = true;
                for (int j = 0; j &amp;lt; len; j++)
                    for (int k = 0; k &amp;lt; len; k++)
                        G[x + j][y + k] = len;
                // 如果填的最后一行是下沿，丢进ans
                if (x + len == 154) ans.push_back(len);
                // 找下一个填的起始位置（从上到下，从左到右）
                // 直接暴力找，不用优化
                bool completed = true, flag = false;
                for (int j = 0; j &amp;lt; 154; j++) {
                    for (int k = 0; k &amp;lt; 154; k++)
                        if (!G[j][k]) {
                            dfs(j, k);
                            completed = false;
                            flag = true;
                            break; // 别忘了这个break只会跳出内层循环，用下面的flag处理下
                        }
                    if (flag) break;
                }
                if (completed) {
                    getAns = true;
                    break;
                }
                if (getAns) break;
                // 回溯，撤回决策
                used[i] = false;
                for (int j = 0; j &amp;lt; len; j++)
                    for (int k = 0; k &amp;lt; len; k++)
                        G[x + j][y + k] = 0;
                if (x + len == 154) ans.pop_back();
            }
        }
    }
}

int main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr), cout.tie(nullptr);
    freopen(&amp;quot;ans.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    used.resize(squares.size());
    for (int i = 0; i &amp;lt; 47; i++)
        for (int j = 0; j &amp;lt; 47; j++)
            G[i][j] = 47;
    for (int i = 0; i &amp;lt; 46; i++)
        for (int j = 47; j &amp;lt; 93; j++)
            G[i][j] = 46;
    for (int i = 0; i &amp;lt; 61; i++)
        for (int j = 93; j &amp;lt; 154; j++)
            G[i][j] = 61;
    dfs(46, 47);
    for (int it:ans) cout &amp;lt;&amp;lt; it &amp;lt;&amp;lt; &#39; &#39;;
    cout &amp;lt;&amp;lt; endl;
    for (int i = 0; i &amp;lt; 154; i++) {
        for (int j = 0; j &amp;lt; 154; j++)
            printf(&amp;quot;%3d&amp;quot;, G[i][j]);
        printf(&amp;quot;\n&amp;quot;);
    }
    fclose(stdout);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;发散-1&#34;&gt;发散&lt;/h3&gt;
&lt;p&gt;上述代码中，我求得答案为“50 41 33 30”，我在网上看到另一篇博客中给出的答案是“50 33 30 41”，于是加了个文件输出看了一下，我的答案大约的确是对的，也就是说本题可能有多种合法答案。验证这句话有个简单的方法，就是改改我代码里squares中元素的顺序，而不用去严格证明，不过我就懒得去试了。&lt;/p&gt;
&lt;p&gt;这里有高人&lt;a href=&#34;https://blog.csdn.net/Lonverce&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lonverce&lt;/a&gt;加了线段树优化的版本《&lt;a href=&#34;https://blog.csdn.net/lonverce/article/details/51436195&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;( 题解 )第六届蓝桥杯决赛试题 &amp;ndash; 完美正方形 (线段树 + 深搜)&lt;/a&gt;》&lt;/p&gt;
&lt;h2 id=&#34;关联账户&#34;&gt;关联账户&lt;/h2&gt;
&lt;h3 id=&#34;问题描述-2&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;为增大反腐力度，某地警方专门支队，对若干银行账户展开调查。&lt;/p&gt;
&lt;p&gt;如果两个账户间发生过转账，则认为有关联。如果a,b间有关联, b,c间有关联，则认为a,c间也有关联。&lt;/p&gt;
&lt;p&gt;对于调查范围内的n个账户（编号0到n-1），警方已知道m条因转账引起的直接关联。&lt;/p&gt;
&lt;p&gt;现在希望知道任意给定的两个账户，求出它们间是否有关联。有关联的输出1，没有关联输出0&lt;/p&gt;
&lt;p&gt;小明给出了如下的解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#define N 100

int connected(int* m, int p, int q)
{
	return m[p]==m[q]? 1 : 0;
}

void link(int* m, int p, int q)
{
	int i;
	if(connected(m,p,q)) return;
	int pID = m[p];
	int qID = m[q];
	for(i=0; i&amp;lt;N; i++) _____________________________________;  //填空位置
}

int main()
{
	int m[N];
	int i;
	for(i=0; i&amp;lt;N; i++) m[i] = i; //初始状态，每个节点自成一个连通域
	link(m,0,1); //添加两个账户间的转账关联
	link(m,1,2); 
	link(m,3,4); 
	link(m,5,6); 
	link(m,6,7); 
	link(m,8,9); 
	link(m,3,7); 
	
	printf(&amp;quot;%d &amp;quot;, connected(m,4,7));
	printf(&amp;quot;%d &amp;quot;, connected(m,4,5));
	printf(&amp;quot;%d &amp;quot;, connected(m,7,9));
	printf(&amp;quot;%d &amp;quot;, connected(m,9,2));
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请分析源代码，并提交划线部分缺少的代码。不要填写已有代码或任何多余内容。&lt;/p&gt;
&lt;h3 id=&#34;分析-2&#34;&gt;分析&lt;/h3&gt;
&lt;p&gt;这个问题拿到手，当然一眼出并查集啦！不过出题人非要给你个思路，让你在上面做文章，那我们先分析下代码中例子的情况：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
0 --- 1
1 --- 2
3 --- 4
5 --- 6
6 --- 7
8 --- 9
3 --- 7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以首先，我们把代码copy到本地，填完空后，我们输出的结果必须是“1 1 0 0”（填对了一定是这个答案，是这个答案不一定填对了）。&lt;/p&gt;
&lt;p&gt;我们再分析下题目给出的算法，emmm这就是传说中的$O(n)$合并？？对于该算法，每次合并时将所有同集合元素的m更新为相同值，这样查询时只需要$O(1)$判断下两者m值是否相同即可。算法正确性可用归纳法证明。&lt;/p&gt;
&lt;p&gt;按照上述意思，补全的代码应该是&lt;code&gt;if (connected(m, pID, i) m[i] = qID&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;密文搜索&#34;&gt;密文搜索&lt;/h2&gt;
&lt;h3 id=&#34;问题描述-3&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;福尔摩斯从X星收到一份资料，全部是小写字母组成。&lt;/p&gt;
&lt;p&gt;他的助手提供了另一份资料：许多长度为8的密码列表。&lt;/p&gt;
&lt;p&gt;福尔摩斯发现，这些密码是被打乱后隐藏在先前那份资料中的。&lt;/p&gt;
&lt;p&gt;请你编写一个程序，从第一份资料中搜索可能隐藏密码的位置。要考虑密码的所有排列可能性。&lt;/p&gt;
&lt;h4 id=&#34;数据格式&#34;&gt;数据格式&lt;/h4&gt;
&lt;p&gt;输入第一行：一个字符串s，全部由小写字母组成，长度小于1024*1024&lt;/p&gt;
&lt;p&gt;紧接着一行是一个整数n,表示以下有n行密码，1&amp;lt;=n&amp;lt;=1000&lt;/p&gt;
&lt;p&gt;紧接着是n行字符串，都是小写字母组成，长度都为8&lt;/p&gt;
&lt;h4 id=&#34;要求输出&#34;&gt;要求输出&lt;/h4&gt;
&lt;p&gt;一个整数, 表示每行密码的所有排列在s中匹配次数的总和。&lt;/p&gt;
&lt;h4 id=&#34;例如&#34;&gt;例如&lt;/h4&gt;
&lt;p&gt;用户输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aaaabbbbaabbcccc
2
aaaabbbb
abcabccc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则程序应该输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为：第一个密码匹配了3次，第二个密码匹配了1次，一共4次。&lt;/p&gt;
&lt;h4 id=&#34;资源约定&#34;&gt;资源约定&lt;/h4&gt;
&lt;p&gt;峰值内存消耗 &amp;lt; 512M&lt;/p&gt;
&lt;p&gt;CPU消耗  &amp;lt; 3000ms&lt;/p&gt;
&lt;h3 id=&#34;分析-3&#34;&gt;分析&lt;/h3&gt;
&lt;p&gt;讲实在话，这题看了半天没看懂意思，第一个密码怎么匹配了3次？“要考虑密码的所有排列可能性”是什么意思？可能语文不好不配打蓝桥= =&lt;/p&gt;
&lt;p&gt;在网上看了下别人的代码，才知道原来意思是对于s中任意长度为8的子串，判断其排列后能得到给定密码的数目和（这tm……我直接迷惑）。&lt;/p&gt;
&lt;h4 id=&#34;法一-brute-force&#34;&gt;法一 Brute Force&lt;/h4&gt;
&lt;p&gt;我们可以枚举s中每一个长度为8的子串，然后统计串中各字符出现次数。对于任意密码，逐一检查密码中的字符个数与子串字符个数是否匹配，匹配答案就+1。这样的复杂度是$O(n*s.length)$，显然会T一些点。&lt;/p&gt;
&lt;p&gt;因为BF很不优雅还不能把分拿满，这里就不写了。&lt;/p&gt;
&lt;h4 id=&#34;法二-算术基本定理hash&#34;&gt;法二 算术基本定理+Hash&lt;/h4&gt;
&lt;p&gt;根据算术基本定理，任何一个大于1的自然数都能被分为有限个质数之积（或者它本身就是质数），且这个分解是唯一的。&lt;/p&gt;
&lt;p&gt;根据这一定理，我们很容易想到，如果让每个字母表示不同的质数，那么整个字符串就能被Hash为其质数积，这样的Hash方法是不会有冲突的，因为分解是唯一的，所以不会有两个不一样的串Hash值相同。&lt;/p&gt;
&lt;p&gt;那么我们就设&amp;rsquo;a&#39;&amp;lsquo;b&#39;&amp;lsquo;c&amp;rsquo;等字符为前26个质数，然后对原串s中所有的长度为8的子串Hash后记录在map里。然后每度入一个密码，累加改Hash值出现的次数即可，算法复杂度为$O(s.length*\log(s.legnth)+nlog(s.length))$。子串长度只有8，所以Hash值也不会爆long long（第26个素数是101）。&lt;/p&gt;
&lt;h3 id=&#34;参考代码-1&#34;&gt;参考代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//
// Created by Visors on 2020/11/11.
//
// 题目名：密文搜索
// 题目来源：第六届蓝桥杯国赛
// 题目链接：https://www.dotcpp.com/oj/problem1828.html
// 算法：算术基本定理+Hash
// 用途：TODO
// 时间复杂度：$O(s.length*\log(s.legnth)+nlog(s.length))$
//

#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

vector&amp;lt;int&amp;gt; value{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
                  43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};
unordered_map&amp;lt;long long, int&amp;gt; book;

string s, t;
int n, ans = 0;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin &amp;gt;&amp;gt; s;
    // 题目没有明说s长度范围，所以特判一下
    if (s.length() &amp;gt;= 8) {
        long long mul = 1;
        for (int i = 0; i &amp;lt; 8; i++) mul *= value[s[i] - &#39;a&#39;];
        book[mul]++;
        for (int i = 8; i &amp;lt; s.length(); i++) {
            // 一除一乘，优化常数
            mul /= value[s[i - 8] - &#39;a&#39;];
            mul *= value[s[i] - &#39;a&#39;];
            book[mul]++;
        }
    }
    cin &amp;gt;&amp;gt; n;
    while (n--) {
        cin &amp;gt;&amp;gt; t;
        if (s.length() &amp;lt; 8) continue;
        long long mul = 1;
        for (char c:t) mul *= value[c - &#39;a&#39;];
        ans += book[mul];
    }
    if (s.length() &amp;lt; 8) cout &amp;lt;&amp;lt; &amp;quot;0\n&amp;quot;;
    else cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;吐槽&#34;&gt;吐槽&lt;/h3&gt;
&lt;p&gt;这个题面真的神了，“这些密码是被打乱后隐藏在先前那份资料中的”让我以为这题是对给出的所有密码找到最大不冲突匹配数。&lt;/p&gt;
&lt;p&gt;然后这个乱序到底是取子串还是子序列，也没有说明白。我觉得既然都打乱了应该就是子序列吧，结果博客里面都是直接当作子串写的，莽一发直接过了。&lt;/p&gt;
&lt;p&gt;可能是五年前蓝桥题目质量还不够好吧……&lt;/p&gt;
&lt;h2 id=&#34;居民集会&#34;&gt;居民集会&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;蓝桥村的居民都生活在一条公路的边上，公路的长度为L，每户家庭的位置都用这户家庭到公路的起点的距离来计算，第i户家庭距起点的距离为di。&lt;/p&gt;
&lt;p&gt;每年，蓝桥村都要举行一次集会。今年，由于村里的人口太多，村委会决定要在4个地方举行集会，其中3个位于公路中间，1个位最公路的终点。&lt;/p&gt;
&lt;p&gt;已知每户家庭都会向着远离公路起点的方向去参加集会，参加集会的路程开销为家庭内的人数ti与距离的乘积。&lt;/p&gt;
&lt;p&gt;给定每户家庭的位置di和人数ti，请为村委会寻找最好的集会举办地：p1, p2, p3, p4 (p1&amp;lt;=p2&amp;lt;=p3&amp;lt;=p4=L),使得村内所有人的路程开销和最小。&lt;/p&gt;
&lt;h4 id=&#34;输入格式&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行包含两个整数n, L，分别表示蓝桥村的家庭数和公路长度。&lt;/p&gt;
&lt;p&gt;接下来n行，每行两个整数di, ti，分别表示第i户家庭距离公路起点的距离和家庭中的人数。&lt;/p&gt;
&lt;h4 id=&#34;输出格式&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行，包含一个整数，表示村内所有人路程的开销和。&lt;/p&gt;
&lt;h4 id=&#34;样例输入&#34;&gt;样例输入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;6 10
1 3
2 2
4 5
5 20
6 5
8 7
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;样例输出&#34;&gt;样例输出&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;18
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;样例说明&#34;&gt;样例说明&lt;/h4&gt;
&lt;p&gt;在距起点2, 5, 8, 10这4个地方集会，6个家庭需要的走的距离分别为1, 0, 1, 0, 2, 0，总的路程开销为1*3+0*2+1*5+0*20+2*5+0*7=18。&lt;/p&gt;
&lt;h4 id=&#34;数据规模与约定&#34;&gt;数据规模与约定&lt;/h4&gt;
&lt;p&gt;对于10%的评测数据，1&amp;lt;=n&amp;lt;=300。&lt;/p&gt;
&lt;p&gt;对于30%的评测数据，1&amp;lt;=n&amp;lt;=2000，1&amp;lt;=L&amp;lt;=10000，0&amp;lt;=di&amp;lt;=L，di&amp;lt;=di+1，0&amp;lt;=ti&amp;lt;=20。&lt;/p&gt;
&lt;p&gt;对于100%的评测数据，1&amp;lt;=n&amp;lt;=100000，1&amp;lt;=L&amp;lt;=1000000，0&amp;lt;=di&amp;lt;=L，di&amp;lt;=di+1，0&amp;lt;=ti&amp;lt;=1000000。&lt;/p&gt;
&lt;h4 id=&#34;资源约定-1&#34;&gt;资源约定&lt;/h4&gt;
&lt;p&gt;峰值内存消耗 &amp;lt; 512M&lt;/p&gt;
&lt;p&gt;CPU消耗  &amp;lt; 5000ms&lt;/p&gt;
&lt;h3 id=&#34;分析-4&#34;&gt;分析&lt;/h3&gt;
&lt;p&gt;显然，题目中的p1,p2,p3应在三个不同的家庭处，那么BF枚举三个点的位置再加上前缀和优化，就能$O(n^3)$求解，但这个复杂度太差了。&lt;/p&gt;
&lt;p&gt;前缀和如何优化？如果你把居民从家走到集会点看成从家走到p4，再减去p4到其集会点的距离，则对于划分出的一个区间，其减去的值的和应为区间内的人数（前缀和处理）*l-集会点距起点的距离。&lt;/p&gt;
&lt;p&gt;因着这个，我跟队友讨论了下，莽了个假算法：先枚举p2，然后在左右区间分别三分找p1和p2。交了一下WA了，似乎两遍区间内函数并不是单峰函数，这个算法有问题，不过可以过部分点。不过由于不是官方评测，可能数据有问题，毕竟过的人数只有个位数……&lt;/p&gt;
&lt;h3 id=&#34;参考代码-2&#34;&gt;参考代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//
// Created by Visors on 2020/11/11.
//
// 题目名：居民集会
// 题目来源：第六届蓝桥杯国赛
// 题目链接：https://www.dotcpp.com/oj/problem1829.html
// 算法：JuMinJiHui.cpp
// 用途：TODO
// 时间复杂度：O(TODO)
//

#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

typedef long long ll;
typedef pair&amp;lt;int, int&amp;gt; pii;

int n, l;
set&amp;lt;int&amp;gt; s;
vector&amp;lt;pii&amp;gt; families;
vector&amp;lt;ll&amp;gt; preSum;
int p1, p2, p3;

inline ll getPreSum(int left, int right) {
    return preSum[right + 1] - preSum[left];
}

inline ll f1(int x) {
    return getPreSum(0, x) * (l - families[x].first) + getPreSum(x + 1, p2) * (l - families[p2].first);
}

inline ll f2(int x) {
    return getPreSum(p2 + 1, x) * (l - families[x].first);
}

int sanfen1(int left, int right) {
    while (left &amp;lt; right - 1) {
        int mid1 = (left + right) / 2,
                mid2 = (mid1 + right) / 2;
        if (f1(mid1) &amp;gt; f1(mid2)) right = mid2;
        else left = mid1;
    }
    return f1(left) &amp;gt; f1(right) ? left : right;
}

int sanfen2(int left, int right) {
    while (left &amp;lt; right - 1) {
        int mid1 = (left + right) / 2,
                mid2 = (mid1 + right) / 2;
        if (f2(mid1) &amp;gt; f2(mid2)) right = mid2;
        else left = mid1;
    }
    return f2(left) &amp;gt; f2(right) ? left : right;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; l;
    families.resize(n);
    preSum.resize(n + 1);
    for (pii &amp;amp;it:families) {
        cin &amp;gt;&amp;gt; it.first &amp;gt;&amp;gt; it.second;
        s.insert(it.first);
    }
    sort(families.begin(), families.end());
    if (s.size() &amp;lt;= 3) {
        cout &amp;lt;&amp;lt; &amp;quot;0\n&amp;quot;;
        return 0;
    }
    preSum[0] = 0;
    for (int i = 1; i &amp;lt;= n; i++)
        preSum[i] = preSum[i - 1] + families[i - 1].second;
    ll Sum = 0;
    for (pii it:families) Sum += (l - it.first) * it.second;
    ll ans = 0x3f3f3f3f3f3f3f3f;
    for (int i = 1; i &amp;lt; n - 1; i++) {
        p2 = i;
        p1 = sanfen1(0, p2 - 1);
        p3 = sanfen2(p2 + 1, n - 1);
        ans = min(ans, Sum - f1(p1) - f2(p3));
    }
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;发散-2&#34;&gt;发散&lt;/h3&gt;
&lt;p&gt;更好的写法是DP，这个DP并不难想，不过不知道为什么当初讨论着讨论着就开始三分了，可能是因为我们都想把分拿满吧。经过前缀和优化后，DP可以$O(n^2)$出解，有大佬指出该DP可以斜率优化，不过我不懂……&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Baobab_Tree&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;名道&lt;/a&gt;《&lt;a href=&#34;https://blog.csdn.net/Baobab_Tree/article/details/90109757&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;15年国赛 居民集会&lt;/a&gt;》&lt;/p&gt;
&lt;h2 id=&#34;模型染色&#34;&gt;模型染色&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-1&#34;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;在电影《超能陆战队》中，小宏可以使用他的微型机器人组合成各种各样的形状。&lt;/p&gt;
&lt;p&gt;现在他用他的微型机器人拼成了一个大玩具给小朋友们玩。为了更加美观，他决定给玩具染色。&lt;/p&gt;
&lt;p&gt;小宏的玩具由n个球型的端点和m段连接这些端点之间的边组成。下图给出了一个由5个球型端点和4条边组成的玩具，看上去很像一个分子的球棍模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./图2.png&#34; alt=&#34;图2&#34; style=&#34;zoom:33%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;由于小宏的微型机器人很灵活，这些球型端点可以在空间中任意移动，同时连接相邻两个球型端点的边可以任意的伸缩，这样一个玩具可以变换出不同的形状。在变换的过程中，边不会增加，也不会减少。&lt;/p&gt;
&lt;p&gt;小宏想给他的玩具染上不超过k种颜色，这样玩具看上去会不一样。如果通过变换可以使得玩具变成完全相同的颜色模式，则认为是本质相同的染色。现在小宏想知道，可能有多少种本质不同的染色。&lt;/p&gt;
&lt;h4 id=&#34;输入格式-1&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行包含三个整数n, m, k，&lt;/p&gt;
&lt;p&gt;分别表示小宏的玩具上的端点数、边数和小宏可能使用的颜色数。端点从1到n编号。&lt;/p&gt;
&lt;p&gt;接下来m行每行两个整数a, b，表示第a个端点和第b个端点之间有一条边。输入保证不会出现两条相同的边。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-1&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行，表示本质不同的染色的方案数。由于方案数可能很多，请输入方案数除10007的余数。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-1&#34;&gt;样例输入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;3 2 2
1 2
3 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;样例输出-1&#34;&gt;样例输出&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;6
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;样例说明-1&#34;&gt;样例说明&lt;/h4&gt;
&lt;p&gt;令(a, b, c)表示第一个端点染成a，第二个端点染成b，第三个端点染成c，则下面6种本质不同的染色：(1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 2, 2), (2, 1, 2), (2, 2, 2)。&lt;/p&gt;
&lt;p&gt;而(2, 1, 1)与(1, 1, 2)是本质相同的，(2, 2, 1)与(2, 1, 2)是本质相同的。&lt;/p&gt;
&lt;h4 id=&#34;数据规模与约定-1&#34;&gt;数据规模与约定&lt;/h4&gt;
&lt;p&gt;对于20%的评测数据，1&amp;lt;=n&amp;lt;=5， 1&amp;lt;=k&amp;lt;=2。&lt;/p&gt;
&lt;p&gt;对于50%的评测数据，1&amp;lt;=n&amp;lt;=10, 1&amp;lt;=k&amp;lt;=8。&lt;/p&gt;
&lt;p&gt;对于100%的评测数据，1&amp;lt;=n&amp;lt;=10, 1&amp;lt;=m&amp;lt;=45, 1&amp;lt;=k&amp;lt;=30。&lt;/p&gt;
&lt;h4 id=&#34;资源约定-2&#34;&gt;资源约定&lt;/h4&gt;
&lt;p&gt;峰值内存消耗 &amp;lt; 512M&lt;/p&gt;
&lt;p&gt;CPU消耗  &amp;lt; 5000ms&lt;/p&gt;
&lt;h3 id=&#34;分析-5&#34;&gt;分析&lt;/h3&gt;
&lt;p&gt;我只会暴力……大佬说用Polya定理，虽然以前接触过，不过已经忘干净了……&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Baobab_Tree&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;名道&lt;/a&gt;《&lt;a href=&#34;https://blog.csdn.net/Baobab_Tree/article/details/90109956&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;15年国赛 模型染色&lt;/a&gt;》&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;这么看上去国赛大题想拿满分并不简单，不知道到时候同台竞技的人水平如何，突然有一点小虚。&lt;/p&gt;
&lt;div id=&#34;content&#34;&gt;&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#积分之谜&#34;&gt;积分之谜&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#问题描述&#34;&gt;问题描述&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#分析&#34;&gt;分析&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#发散&#34;&gt;发散&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#完美正方形&#34;&gt;完美正方形&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#问题描述-1&#34;&gt;问题描述&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#分析-1&#34;&gt;分析&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#参考代码&#34;&gt;参考代码&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#发散-1&#34;&gt;发散&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#关联账户&#34;&gt;关联账户&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#问题描述-2&#34;&gt;问题描述&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#分析-2&#34;&gt;分析&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#密文搜索&#34;&gt;密文搜索&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#问题描述-3&#34;&gt;问题描述&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#分析-3&#34;&gt;分析&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#参考代码-1&#34;&gt;参考代码&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#吐槽&#34;&gt;吐槽&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#居民集会&#34;&gt;居民集会&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#题目描述&#34;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#分析-4&#34;&gt;分析&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#参考代码-2&#34;&gt;参考代码&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#发散-2&#34;&gt;发散&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#模型染色&#34;&gt;模型染色&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#题目描述-1&#34;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#分析-5&#34;&gt;分析&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#后记&#34;&gt;后记&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>分层图思想及其处理方法</title>
      <link>https://visors.github.io/post/%E5%88%86%E5%B1%82%E5%9B%BE%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 09 Nov 2020 20:49:54 +0800</pubDate>
      <guid>https://visors.github.io/post/%E5%88%86%E5%B1%82%E5%9B%BE%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;link href=&#34;https://fonts.googleapis.com/css2?family=Noto+Serif+TC&amp;display=swap&#34; rel=&#34;stylesheet&#34;&gt;
&lt;div style=&#34;font-family:&#39;Noto Serif TC&#39;&#34;&gt;
&lt;center&gt;我知 一雙手 只要握成拳頭&lt;/center&gt;
&lt;center&gt;能捱下去&lt;/center&gt;
&lt;center&gt;哪怕我 面容極蒼白&lt;/center&gt;
&lt;center&gt;拒絕疲累&lt;/center&gt;
&lt;center&gt;追 追不到 也得追&lt;/center&gt;
&lt;center&gt;成就最渺小的壯舉&lt;/center&gt;
&lt;center&gt;一雙手 可以不求人 頑強面對&lt;/center&gt;
&lt;center&gt;這世界 絕情又刻薄 照樣無懼&lt;/center&gt;
&lt;center&gt;當 天開眼 暖風吹 雲霧會散開&lt;/center&gt;
&lt;center&gt;給我堡壘&lt;/center&gt;
&lt;p align=&#34;right&#34;&gt;&lt;i&gt;——林奕匡《壹雙手》&lt;/i&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&#34;状态与图&#34;&gt;状态与图&lt;/h2&gt;
&lt;h3 id=&#34;一个小插曲&#34;&gt;一个小插曲&lt;/h3&gt;
&lt;p&gt;学习动态规划时，我们一定会接触到一个概念——状态。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tarjan求割点所割连通分量数</title>
      <link>https://visors.github.io/post/tarjan%E6%B1%82%E5%89%B2%E7%82%B9%E6%89%80%E5%89%B2%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E6%95%B0/</link>
      <pubDate>Sat, 31 Oct 2020 10:54:46 +0800</pubDate>
      <guid>https://visors.github.io/post/tarjan%E6%B1%82%E5%89%B2%E7%82%B9%E6%89%80%E5%89%B2%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E6%95%B0/</guid>
      <description>&lt;link href=&#34;https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@500&amp;display=swap&#34; rel=&#34;stylesheet&#34;&gt;
&lt;div style=&#34;font-family:&#39;Noto Serif JP&#39;, serif&#34;&gt;
    &lt;center&gt;ただ ひたすらなその思い&lt;/center&gt;
	&lt;center&gt;孤独な闇をいつか&lt;/center&gt;
	&lt;center&gt;照らすだろう&lt;/center&gt;
    &lt;p align=&#34;right&#34; font-style&gt;&lt;i&gt;——《3びきのくま》&lt;/i&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Tarjan求割点的方法已经在《&lt;a href=&#34;https://visors.github.io/post/tarjan%e6%b1%82%e6%97%a0%e5%90%91%e5%9b%be%e5%89%b2%e7%82%b9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tarjan求无向图割点&lt;/a&gt;》中介绍了，不清楚的读者可以先行阅读那部分内容，这里直接分析求割点所割连通分量数的方法。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;&lt;/h2&gt;
&lt;p&gt;前面介绍Tarjan算法时，我们介绍了无向图的搜索树的概念。那时，我们从形状的角度感性认识了Tarjan算法的正确性，事实上，对于$low$的实际意义，我们可以更进一步地思考一下，首先回顾下$low$的求法：&lt;/p&gt;
&lt;p&gt;考虑这样的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在非搜索树上的边$(u,v)$的$v$点&lt;/li&gt;
&lt;li&gt;在回溯前能访问到的最早的点，即搜索树中以$u$为根的子树上的点能访问到的最早的点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;找出这些点中的最小的时间戳，即为我们能追溯到的最早节点，我们称之为&lt;strong&gt;追溯值&lt;/strong&gt;$low$。&lt;/p&gt;
&lt;p&gt;注意上述定义中，对于点$u$，在考虑第一种点时，我们只需考虑其$dfn$即可，而对于第二种点，我们需要在递归过程中考虑其子节点的$low$才行。对于该子树上一叶子$a$，显然其无子节点，若要更新其$low$，必然有非搜索树上的边$(a,b)$，使得$low[a] = dfn[b]$，否则$low[a]=dfn[a]$。继续向上考虑，若一个节点在回溯前每个点都无非搜索树上的边，则其$low = dfn$。换言之，一旦一个节点的$low\neq dfn$，则其子树上必有一点存在不在搜索树上的边。顺着这个思路往下想，由于这是一个递归过程，所以当递归回溯到$u$的邻点$v$时，$low[v]$应当为其子树中所有节点最小的$low$，亦即能追溯到的最早的点。若$low[v]\neq dfn[v]$，则一定存在某个子节点有一条连向时间戳为$low[v]$的点，那么形状准确来说应该类似下图：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((A))
B((B))
C((C))
D((D))
E((E))
F((F))
A --- B
B === C
C --- D
D --- E
D --- F
F -.- C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上图是一个缩略的图模型，意思指C的子树中有最早能追溯到C的点F，同时B点到C点间所有的点都仅为一条链。此时B到C上任意一点都为割点，删去其中任意一个点都将使其后搜索树上的子图成为一个新的连通子图。&lt;/p&gt;
&lt;p&gt;这里直接给出我们在删去割点的时候的判断标准：&lt;/p&gt;
&lt;p&gt;对于一个非搜索树根节点$u$，其有$k$个满足$dfn[u]\leq low[v]$的搜索树上的子节点$v$，则删去$u$后将生成$k+1$个互不连通的子图。&lt;/p&gt;
&lt;p&gt;这个道理很简单，删去割点，每个满足$dfn[u]\leq low[v]$的节点所在的子树自成一个个连通子图，$u$祖先方向的节点自成一个连通子图。&lt;/p&gt;
&lt;p&gt;换言之，每有一个满足$dfn[u]\leq low[v]$的子节点$v$，则删去$u$后会使连通子图数$+1$.为什么这些满足$dfn[u]\leq low[v]$的点对新生成互不连通子图的贡献不会重复呢？可以这么证明：&lt;/p&gt;
&lt;p&gt;若存在$u$的邻点$a$和$b$，满足$dfn[u]\leq low[a]$和$dfn[u]\leq low[b]$，可以假设$a$、$b$连通，那么删去$u$后，$a$和$b$同属一个连通子图，答案只增加1。但事实上，在上述假设情况下，当我们递归访问$a$（假设优先遍历$a$）时，就会遍历到$b$，并为其打上时间戳、求出回溯值，他们在搜索树上属于祖先和后代的关系，那么删去根$u$，显然只会产生多个互不连通的子图，但同时$b$并非$u$邻点，这与假设相悖。所以上述结论得证。&lt;/p&gt;
&lt;p&gt;但有一个特殊的情况需要注意，如果删除的$u$是整个搜索树的树根，则其没有祖先方向的节点，这样就会少一个连通子图。总结一下就是：&lt;/p&gt;
&lt;p&gt;对于点$u$：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$u$不是割点，则删去它不会增加互不连通子图的数目。&lt;/li&gt;
&lt;li&gt;$u$是割点，假设其满足$dfn[u]\leq low[v]$的邻点$v$有$k$个：
&lt;ol&gt;
&lt;li&gt;若$u$是搜索树根，则删去$u$后，互不连通子图数目增加$k-1$。&lt;/li&gt;
&lt;li&gt;若$u$不是搜索树根，则删去$u$后，互不连通子图数目增加$k$。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考实现&#34;&gt;参考实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//
// Created by Visors on 2020/10/25.
//
// 题目名：Router Mesh
// 题目来源：2020ICPC·小米 网络选拔赛第一场
// 题目链接：https://ac.nowcoder.com/acm/contest/7501/D
// 算法：Tarjan
// 用途：求割点所割连通分量数
// 时间复杂度：O(n+m)
//

#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

int block = 0;

struct Tarjan {
    struct Edge {
        int to, next;

        Edge() = default;

        Edge(int to, int next) : to(to), next(next) {}
    };

    int vertexNum{}, edgeNum{};
    int cnt{};              // 当前时间戳
    int root{};             // 保存当前搜索树根
    vector&amp;lt;Edge&amp;gt; edges;
    vector&amp;lt;int&amp;gt; heads;
    vector&amp;lt;int&amp;gt; dfn;        // 时间戳
    vector&amp;lt;int&amp;gt; low;        // 最早追溯时间
    vector&amp;lt;bool&amp;gt; isCut;     // 割点
    vector&amp;lt;int&amp;gt; branches;   // 分支数

    void init(int n, int m) {
        cnt = 0;
        vertexNum = n;
        edgeNum = m;
        heads.resize(vertexNum);
        fill(heads.begin(), heads.end(), -1);
        dfn.resize(vertexNum);
        low.resize(vertexNum);
        isCut.resize(vertexNum);
        branches.resize(vertexNum);
    }

    void addEdge(int u, int v) {
        edges.emplace_back(v, heads[u]);
        heads[u] = edges.size() - 1;
    }

    void dfs(int u) {
        dfn[u] = low[u] = ++cnt;
        int tot = 0;
        for (int i = heads[u]; ~i; i = edges[i].next) {
            int &amp;amp;v = edges[i].to;
            if (!dfn[v]) {
                dfs(v);
                low[u] = min(low[u], low[v]);
                if (low[v] &amp;gt;= dfn[u]) {
                    tot++;
                    if (u != root || tot &amp;gt; 1) isCut[u] = true;   // 对树根特判
                }
            } else low[u] = min(low[u], dfn[v]);
        }
        if (u != root) tot++;
        branches[u] = tot;
    }

    void run() {
        for (int i = 0; i &amp;lt; vertexNum; i++)
            if (!dfn[i]) {
                root = i;
                block++;
                dfs(i);
            }
    }
} tarjan;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n, m;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    tarjan.init(n, m);
    for (int i = 1, u, v; i &amp;lt;= m; i++) {
        cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
        u--, v--;
        tarjan.addEdge(u, v);
        tarjan.addEdge(v, u);
    }
    tarjan.run();
    cout &amp;lt;&amp;lt; block + tarjan.branches[0] - 1;
    for (int i = 1; i &amp;lt; n; i++)
        cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; block + tarjan.branches[i] - 1;
    cout &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;比赛的时候不知道从哪看的找值不同的$low$数目是真的煞笔，然后煞笔的我就真的按这个思路交了十发，全WA。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tarjan求无向图割点</title>
      <link>https://visors.github.io/post/tarjan%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E7%82%B9/</link>
      <pubDate>Thu, 29 Oct 2020 10:28:18 +0800</pubDate>
      <guid>https://visors.github.io/post/tarjan%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E7%82%B9/</guid>
      <description>&lt;link href=&#34;https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@500&amp;display=swap&#34; rel=&#34;stylesheet&#34;&gt;
&lt;div style=&#34;font-family:&#39;Noto Serif JP&#39;, serif&#34;&gt;&lt;center&gt;さざ波のラインダンス 時間だけこわれてく&lt;/center&gt;
	&lt;center&gt;まなざしのボルテージ 熱くしながら&lt;/center&gt;
	&lt;center&gt;君に胸キュン 夏の印画紙&lt;/center&gt;
	&lt;center&gt;太陽だけ焼きつけて&lt;/center&gt;
	&lt;center&gt;君に胸キュン ぼくはと言えば&lt;/center&gt;
	&lt;center&gt;柄にもなくプラトニック&lt;/center&gt;
	&lt;center&gt;心の距離を計る 罪つくりな潮風&lt;/center&gt;
   	&lt;center&gt;眼を伏せた一瞬の せつなさがいい&lt;/center&gt;
    &lt;p align=&#34;right&#34; font-style&gt;&lt;i&gt;——YMO《君に、胸キュン。-浮気なヴァカンス-》&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;Tarjan算法的核心思想已经在《&lt;a href=&#34;https://visors.github.io/post/tarjan%e6%b1%82%e6%97%a0%e5%90%91%e5%9b%be%e5%89%b2%e8%be%b9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tarjan求无向图割边&lt;/a&gt;》中介绍了，不清楚的读者可以先行阅读那部分内容，这里直接从介绍割点开始。&lt;/p&gt;
&lt;h2 id=&#34;无向图的割点及判定&#34;&gt;无向图的割点及判定&lt;/h2&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;对于无向连通图$G(V,E)$，若删去点$v\in V$及其邻边$\forall u\in {V-v}, (v,u)\in E$后，$G$被分为两个或更多互不连通的子图，则称$v$为&lt;strong&gt;割点&lt;/strong&gt;或&lt;strong&gt;割顶&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据上面$dfn$和$low$，很容易能想出割边的方法——无向边$(u,v)$是割边，当且仅当搜索树上存在$u$的一个子节点$v$，满足：&lt;/p&gt;
&lt;p&gt;$$dfn[u]\leq low[v]$$&lt;/p&gt;
&lt;p&gt;如果不明白上式，可以参考之前文章中抽象的三种图形。当$dfn[u]=low[v]$时，两条链合起来状似闭环，此时无割边，但两条链$dfn$最小的咬合点显然是割点。&lt;/p&gt;
&lt;p&gt;特别的，对于我们搜索的起点，上述判定方法还需限定条件，先来看一个反例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((1/1))
B((2/1))
C((3/1))
D((4/1))
A === B
B === C
C === D
D --- A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上图中，有唯一满足$dfn[u]\leq low[v]$的$(1,2)$，但去掉$1$后，剩余图为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
B((2))
C((3))
D((4))
B --- C
C --- D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并没有被分为两个或以上的互不连通子图，所以这里搜索起点$1$尽管满足上面的判别式，但并不是割点。&lt;/p&gt;
&lt;p&gt;是不是所有的搜索起点都不是割点呢？提出这个问题固然在思考，但细想却很好笑——任意点都能作为搜索起点，如果这句话成立，则任意点都不是割点。&lt;/p&gt;
&lt;h2 id=&#34;对搜索起点的处理&#34;&gt;对搜索起点的处理&lt;/h2&gt;
&lt;p&gt;如果搜索起点有两个以上的子树，则意味着在搜索树上，根结点出度为二或以上。根据树的性质，如果我们删去根节点及其邻边，则原树将裂解成子树个数个互不连通的树。若不明白，任意找几棵树观察便知。&lt;/p&gt;
&lt;p&gt;要在代码中实现上述判断，可记录从根节点出发的邻点调用的DFS次数即可，伪代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int children = 0;
for (int v: G[u]) {
    if (!vis[v]) {
        children++;
        dfs(v);
    }
}
if (children &amp;gt;= 2)  u是割点
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;对重边的处理&#34;&gt;对重边的处理&lt;/h2&gt;
&lt;p&gt;对割点问题而言，删去割点将会将所有相邻的重边删去，所以割点问题并不受重边影响。&lt;/p&gt;
&lt;h2 id=&#34;参考实现&#34;&gt;参考实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//
// Created by Visors on 2020/10/29.
//
// 题目名：P3388 【模板】割点（割顶）
// 题目来源：luogu
// 题目链接：https://www.luogu.com.cn/problem/P3388
// 算法：Tarjan
// 用途：无向图割点
// 时间复杂度：O(n+m)
//

#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

struct Tarjan {
    struct Edge {
        int to, next;

        Edge() = default;

        Edge(int to, int next) : to(to), next(next) {}
    };

    int vertexNum{}, edgeNum{};
    int cnt{};              // 当前时间戳
    int root{};             // 保存当前搜索树根
    vector&amp;lt;Edge&amp;gt; edges;
    vector&amp;lt;int&amp;gt; heads;
    vector&amp;lt;int&amp;gt; dfn;        // 时间戳
    vector&amp;lt;int&amp;gt; low;        // 最早追溯时间
    set&amp;lt;int&amp;gt; cuts;          // 割点编号集

    void init(int n, int m) {
        cnt = 0;
        vertexNum = n;
        edgeNum = m;
        heads.resize(vertexNum);
        fill(heads.begin(), heads.end(), -1);
        dfn.resize(vertexNum);
        low.resize(vertexNum);
        cuts.clear();
    }

    void addEdge(int u, int v) {
        edges.emplace_back(v, heads[u]);
        heads[u] = edges.size() - 1;
    }

    void dfs(int u) {
        dfn[u] = low[u] = ++cnt;
        int tot = 0;
        for (int i = heads[u]; ~i; i = edges[i].next) {
            int &amp;amp;v = edges[i].to;
            if (!dfn[v]) {
                dfs(v);
                low[u] = min(low[u], low[v]);
                if (low[v] &amp;gt;= dfn[u]) {
                    tot++;
                    if (u != root || tot &amp;gt; 1) cuts.insert(u);   // 对树根特判
                }
            } else low[u] = min(low[u], dfn[v]);
        }
    }

    void run() {
        for (int i = 0; i &amp;lt; vertexNum; i++)
            if (!dfn[i]) {
                root = i;
                dfs(i);
            }
    }
} tarjan;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n, m;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    tarjan.init(n, m);
    for (int i = 1, u, v; i &amp;lt;= m; i++) {
        cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
        if (u == v) continue;
        u--, v--;
        tarjan.addEdge(u, v);
        tarjan.addEdge(v, u);
    }
    tarjan.run();
    cout &amp;lt;&amp;lt; tarjan.cuts.size() &amp;lt;&amp;lt; endl;
    bool first = true;
    for (int it:tarjan.cuts)
        if (first) {
            cout &amp;lt;&amp;lt; it + 1;
            first = false;
        } else cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; it + 1;
    cout &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Tarjan求无向图割边</title>
      <link>https://visors.github.io/post/tarjan%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E8%BE%B9/</link>
      <pubDate>Tue, 27 Oct 2020 19:54:43 +0800</pubDate>
      <guid>https://visors.github.io/post/tarjan%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E8%BE%B9/</guid>
      <description>&lt;link href=&#34;https://fonts.googleapis.com/css2?family=Marck+Script&amp;display=swap&#34; rel=&#34;stylesheet&#34;&gt;
&lt;div style=&#34;font-family:&#39;Marck Script&#39;&#34;&gt;&lt;center&gt;There&#39;s nothing in your eyes&lt;/center&gt;
&lt;center&gt;That marks where you cried&lt;/center&gt;
&lt;center&gt;All is blank all is blind&lt;/center&gt;
&lt;center&gt;Dead inside the inner mind&lt;/center&gt;
    &lt;p align=&#34;right&#34; font-style&gt;&lt;i&gt;——YMO《Behind The Mask》&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&#34;tarjan算法&#34;&gt;Tarjan算法&lt;/h2&gt;
&lt;p&gt;不得不说Robert Tarjan真的是大师，发个网站大家感受一下——&lt;a href=&#34;https://dblp.dagstuhl.de/pid/t/RobertEndreTarjan.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;论文索引&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里要说的Tarjan算法用于解决无向图的连通性，学习之前，先了解两个概念。&lt;/p&gt;
&lt;h3 id=&#34;无向连通图的搜索树&#34;&gt;无向连通图的搜索树&lt;/h3&gt;
&lt;p&gt;当我们遍历一个无向连通图时，显然一个点只会被访问一次，而访问一个点的方法是从一个当前已访问的点$u$，沿着它的邻边走向未访问过的点$v$，则对于任意非遍历起点，其都唯一对应一条边$(u,v)$，这些边恰巧构成一棵树（深究其证明，可考虑将$(u,v)$视为有向边，则非起点入度为$1$，起点入度为$0$），我们称之为&lt;strong&gt;无向连通图的搜索树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于DFS序不唯一，所以搜索树也不唯一。若按节点编号顺序遍历图，则搜索树如下图中加粗部分：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((A))
B((B))
C((C))
D((D))
E((E))
A === B
A --- C
B === C
B --- D
C === D
C === E
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;时间戳dfn&#34;&gt;时间戳dfn&lt;/h3&gt;
&lt;p&gt;按照DFS的先后顺序，我们可以为每个节点定义一个访问时间，其为该点在DFS序中的下标，我们称之为&lt;strong&gt;时间戳&lt;/strong&gt;。对于上图，DFS序为$ABCDE$，则若从$1$开始标记时间，则各点时间戳为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((1))
B((2))
C((3))
D((4))
E((5))
A === B
A --- C
B === C
B --- D
C === D
C === E
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;追溯值low&#34;&gt;追溯值low&lt;/h3&gt;
&lt;p&gt;当DFS序不同时，我们对节点标记的$dfn$也不尽相同，例如上图稍加改变，即可得到：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((1))
B((2))
C((4))
D((3))
E((5))
A === B
A --- C
B --- C
B === D
C === D
C === E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以单纯考虑dfn似乎没什么意义。&lt;/p&gt;
&lt;p&gt;我们考虑这样一个事实：若一个点$u$存在非搜索树上的邻边$(u,v)$，且$dfn(u)&amp;gt;dfn(v)$，则显然遍历到点$v$（先于$u$）时，如果我们先走$(u,v)$，那么$dfn(u)$将减小为$dfn(v)+1$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更准确地说，若一个点$u$存在不在搜索树上的邻边$(u,v)$，则必然有$dfn(u)&amp;gt;dfn(v)$，读者可以思考下为什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，对任一点而言，我们将所有可优化的边枚举出来，则其中存在一个最小的优化值，但这个值是我们可以优化到的最小时间戳吗？并非如此，我们对上图稍作改动：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((1))
B((3))
C((5))
D((4))
E((6))
F((2))
A === F
F === B
A --- E
B --- C
B === D
C === D
C === E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以发现，当我们DFS到$6$时，我们有非搜索树上的邻边指向$1$，则$6$的$dfn$事实上可以被优化为$2$，当回溯到$5$时，我们发现$5$有非搜索树上的邻边指向$3$，则$5$的$dfn$可被优化为$4$。但由于我们是从$6$开始回溯的，既然$6$能被优化为$2$，那么$5$肯定能被优化到$3$。&lt;/p&gt;
&lt;p&gt;但这样还是无法避免因为DFS序不同产生的不唯一性问题，不过上述思考给我们指明了一个方向——我们不妨试着找到任意点能回溯到的最早的点的时间戳。与上面过程类似，对于任意点$u$，我们只需考虑这样的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在非搜索树上的边$(u,v)$的$v$点&lt;/li&gt;
&lt;li&gt;在回溯前能访问到的最早的点，即搜索树中以$u$为根的子树上的点能访问到的最早的点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;找出这些点中的最小的时间戳，即为我们能追溯到的最早节点，我们称之为&lt;strong&gt;追溯值&lt;/strong&gt;$low$。则依上述定义，我们可求得上图追溯值（A/B表示时间戳为A，追溯值为B）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((1/1))
B((3/1))
C((5/1))
D((4/1))
E((6/1))
F((2/1))
A === F
F === B
A --- E
B --- C
B === D
C === D
C === E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们发现上图各点都能追溯到$1$，若变换下例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TB
1((1/1))
2((2/1))
3((3/1))
4((4/1))
5((5/1))
6((6/6))
7((7/7))
8((8/6))
9((9/6))
1 === 2
2 === 3
3 === 4
4 === 5
2 --- 5
1 --- 5
1 -.- 6
6 -.- 7
6 === 8
6 --- 9
8 === 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;无向图的割边及判定&#34;&gt;无向图的割边及判定&lt;/h2&gt;
&lt;p&gt;对于无向连通图$G(V,E)$，若删去边$e\in E$后，$G$被分为两个不连通的子图，则称$e$为&lt;strong&gt;割边&lt;/strong&gt;或&lt;strong&gt;桥&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据上面$dfn$和$low$，很容易能想出割边的方法——无向边$(u,v)$是割边，当且仅当搜索树上存在$u$的一个子节点$v$，满足：&lt;/p&gt;
&lt;p&gt;$$dfn[u]&amp;lt;low[v]$$&lt;/p&gt;
&lt;p&gt;如果不明白上式，可以想象，$dfn[u]$指代了一条从起点到$u$的搜索树链，而$low[v]$代表了一条从$v$到$low[v]$对应的点的回溯链。那么若$dfn[u]&amp;lt;low[v]$，则这两条链相连状似一条穿起来的皮带（加粗部分），那么删掉皮带多出来的那一截中的任意一条边，都能使将原图分为两个不连通的子图（后面的点都无法追溯到$u$）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
s((s))
a((a))
b((b))
u((u))
v((v))
s --- u
u === v
v === a
a === b
b === v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若$dfn[u]=low[v]$，则状似闭环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
s((s))
a((a))
u((u))
v((v))
s --- u
u === v
v === a
a === u
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若$dfn[u]&amp;gt;low[v]$，则状似未穿起的皮带：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
s((s))
a((a))
b((b))
u((u))
v((v))
s --- u
u === v
v === a
a === b
b === s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是不是形象了很多？当然，这只是个辅助记忆的可爱的例子，因为如果从递归的最远的节点开始，存在无非搜索树上邻边的点，则上图两条链应当在某些部分重合。但在割边附近，都能形成状似上面三种情况的图形，单链除外：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
s((s))
u((u))
a((a))
b((b))
v((v))
t((t))
s --- u
u --- a
a --- b
b --- v
v --- t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上图中显然任意一条边都为割边。&lt;/p&gt;
&lt;h2 id=&#34;对重边的处理&#34;&gt;对重边的处理&lt;/h2&gt;
&lt;p&gt;显然，当图中存在重边时，我们上面的$low$值求法存在问题，若仅考虑符合条件的两种点，即使存在重边，求得的$low$也不会变化，然而显然下图并不存在割边：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((A))
B((B))
C((C))
D((D))
A --- B
A --- B
B --- C
C --- D
D --- B
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若不做一些处理，则会得到存在割边$(A,B)$的错误答案。&lt;/p&gt;
&lt;p&gt;一个可行的方法是——每个点的访问情况仅用于控制不重复遍历点，更新$low$值时转而考虑每条边是否访问过，如果存在未访问过的非搜索树上的边，更新其$low$即可。&lt;/p&gt;
&lt;p&gt;这里有必要对每条边做标记处理吗？显然不用。&lt;/p&gt;
&lt;p&gt;由于我们搜索时形成的是一棵树，那么我们在从节点$u$搜得邻点$v$时，纵使$(u,v)$可能不唯一，但真正访问的$(u,v)$有且仅有一条，当我们回溯时，仅需避开这条边的反向边（^1）即可。因此，我们可以在DFS函数中加一参数，用于记录走到当前节点来时的边的编号。&lt;/p&gt;
&lt;h2 id=&#34;参考实现&#34;&gt;参考实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//
// Created by Visors on 2020/10/27.
//
// 题目名：T103481 【模板】割边
// 题目来源：luogu
// 题目链接：https://www.luogu.com.cn/problem/T103481
// 算法：Tarjan
// 用途：无向图割边
// 时间复杂度：O(n+m)
//

#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

struct Tarjan {
    struct Edge {
        int to, next;

        Edge() = default;

        Edge(int to, int next) : to(to), next(next) {}
    };

    int vertexNum{}, edgeNum{};
    int cnt{};                // 当前时间戳
    vector&amp;lt;Edge&amp;gt; edges;
    vector&amp;lt;int&amp;gt; heads;
    vector&amp;lt;int&amp;gt; dfn;        // 时间戳
    vector&amp;lt;int&amp;gt; low;        // 最早追溯时间
    vector&amp;lt;int&amp;gt; bridges;     // 桥边编号集

    void init(int n, int m) {
        cnt = 0;
        vertexNum = n;
        edgeNum = m;
        heads.resize(vertexNum);
        fill(heads.begin(), heads.end(), -1);
        dfn.resize(vertexNum);
        low.resize(vertexNum);
        bridges.clear();
    }

    void addEdge(int u, int v) {
        edges.emplace_back(v, heads[u]);
        heads[u] = edges.size() - 1;
    }

    void dfs(int u, int inEdge) {
        dfn[u] = low[u] = ++cnt;
        for (int i = heads[u]; ~i; i = edges[i].next) {
            int &amp;amp;v = edges[i].to;
            if (!dfn[v]) {
                dfs(v, i);
                low[u] = min(low[u], low[v]);
                if (low[v] &amp;gt; dfn[u]) bridges.push_back(i);
            } else if (i != (inEdge ^ 1))
                low[u] = min(low[u], dfn[v]);
        }
    }

    void run() {
        for (int i = 0; i &amp;lt; vertexNum; i++)
            if (!dfn[i]) dfs(i, -1);
    }
} tarjan;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n, m;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    tarjan.init(n, m);
    for (int i = 1, u, v; i &amp;lt;= m; i++) {
        cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
        u--, v--;
        tarjan.addEdge(u, v);
        tarjan.addEdge(v, u);
    }
    tarjan.run();
    cout &amp;lt;&amp;lt; tarjan.bridges.size() &amp;lt;&amp;lt; endl;
//    for (int it:tarjan.bridges)
//        cout &amp;lt;&amp;lt; tarjan.edges[it ^ 1].to &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; tarjan.edges[it].to &amp;lt;&amp;lt; endl;
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;还是觉得Wowchemy的代码块样式好看！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>重启博客后的吐槽</title>
      <link>https://visors.github.io/post/%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%9A%84%E5%90%90%E6%A7%BD/</link>
      <pubDate>Tue, 27 Oct 2020 19:30:26 +0800</pubDate>
      <guid>https://visors.github.io/post/%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%9A%84%E5%90%90%E6%A7%BD/</guid>
      <description>&lt;p&gt;换电脑了之后不知道怎么把博客的本地环境搬到新Mac上，所以本博客就一直没有更新，为避免麻烦就在CSDN的博客上发了些内容（择日搬运过来）。这期间我经历了从大二升到大三、以及实验室位置的变动（还有无数场被吊打的比赛），连生成这网站的Academic都改名成了Wowchemy……半年的时间转瞬即逝，谁也不知道明天又会发生什么。&lt;/p&gt;
&lt;p&gt;由于前些日子想法太多（甚至码了本书），现在复归平静，决心调整下状态，便准备从重启本博客开刀。之前怕转过来网站和git需要重新配置，没想到直接copy文件夹过来就行了，于是乎在感叹于跨平台的便捷性的同时，本站重启……&lt;/p&gt;
&lt;p&gt;最近听了不少歌，有些过于小众，想同人分享却又怕不受待见，发空间指不定会被当成小众优越🐶，思来想去也只有这个人网站可以容我自在发言，又偶尔有人能看见，便决定以后每发一篇博客，都在前面简短安利一首歌，若读者遇上喜欢的，欢迎与我交流。也许某天也能遇到那么一个人，会一边听着我安利的歌，一边读着我的文章，那便是荣幸之至了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java8新特性</title>
      <link>https://visors.github.io/post/java8%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Mon, 01 Jun 2020 10:09:27 +0800</pubDate>
      <guid>https://visors.github.io/post/java8%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description>&lt;p&gt;我们的教材虽然在前言中声明使用的是Java8，但一些Java8比较重要的新特性并没有出现在教材中，此处略作补充。&lt;/p&gt;
&lt;h2 id=&#34;lambda表达式&#34;&gt;Lambda表达式&lt;/h2&gt;
&lt;p&gt;Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。&lt;/p&gt;
&lt;h3 id=&#34;什么是闭包&#34;&gt;什么是闭包？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;没错这个词很熟悉，离散数学中讲过，不过这里我们以编程的角度来介绍它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;闭包又称词法闭包，最早定义为一种包含&lt;em&gt;&lt;strong&gt;环境成分&lt;/strong&gt;&lt;/em&gt;和&lt;em&gt;&lt;strong&gt;控制成分&lt;/strong&gt;&lt;/em&gt;的实体。&lt;/p&gt;
&lt;p&gt;解释一：闭包是引用了自由变量的函数，这个被引用的变量将和这个函数一同存在。&lt;/p&gt;
&lt;p&gt;解释二：闭包是函数和相关引用环境组成的实体。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;自由变量&lt;/strong&gt;&lt;/em&gt;：除了局部变量的其他变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单理解：闭包能够将一个方法作为一个变量去存储，这个方法有能力去访问所在类的自由变量。&lt;/p&gt;
&lt;p&gt;我们来看一个 Getter&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Closure {
    private int x = 1;

    public int getX() {
        return x; // return this.x
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这段代码中，虽然我们是直接&lt;code&gt;return x&lt;/code&gt;，但其实它是省略的&lt;code&gt;return this.x&lt;/code&gt;，也就是说 Getter 捕获了外部作用域（环境）中的变量 x （自由变量），因此形成了闭包。 Getter 已经是非常常见的方法了，可想而知一个大点的工程项目里会有多少个闭包。但是如果闭包都像这里的 Getter 一样，把自由变量写在环境里，显然这样的代码连续性是很差的，而且我们并不一定希望自由变量永远的存在于环境里（可能会造成全局变量污染等），这时候就需要使用 Lambda 表达式（通常需要结合&lt;em&gt;&lt;strong&gt;函数式接口&lt;/strong&gt;&lt;/em&gt;，后面会讲解）来解决这一问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。&lt;/p&gt;
&lt;p&gt;使用 Lambda 表达式可以使代码变的更加简洁紧凑（可能很多时候更重要）。&lt;/p&gt;
&lt;h3 id=&#34;语法&#34;&gt;语法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;(parameters) -&amp;gt; expression
(parameters) -&amp;gt; { statements; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是lambda表达式的重要特征:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**可选类型声明：**不需要声明参数类型，编译器可以统一识别参数值。&lt;/li&gt;
&lt;li&gt;**可选的参数圆括号：**一个参数无需定义（显式书写）圆括号，但多个参数需要定义圆括号。&lt;/li&gt;
&lt;li&gt;**可选的大括号：**如果主体只包含了一个语句（expression），就不需要使用大括号。&lt;/li&gt;
&lt;li&gt;**可选的返回关键字：**如果主体只有一个表达式返回值则编译器会自动返回值（不用显式书写 return），大括号需要指明表达式返回值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1. 不需要参数,返回值为 5  
() -&amp;gt; 5  // 此处无参数，但仍要保留括号，避免语法缺省（在Kotlin中甚至可以简写成5）
  
// 2. 接收一个参数(数字类型),返回其2倍的值  
x -&amp;gt; 2 * x  
  
// 3. 接受2个参数(数字),并返回他们的差值  
(x, y) -&amp;gt; x – y  // 得益于Java8对泛型的类型推导，类型推导在Java10中得到了进一步进化
  
// 4. 接收2个int型整数,返回他们的和  
(int x, int y) -&amp;gt; x + y  
  
// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
(String s) -&amp;gt; System.out.print(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;虚拟扩展方法&#34;&gt;虚拟扩展方法&lt;/h2&gt;
&lt;p&gt;接口的封装和可复用性是接口的主要优点，但如果出现这样的设计，&lt;strong&gt;类只需要实现接口的部分方法&lt;/strong&gt;时，提供所有接口方法的方法实现就会显得十分冗余。虽然这一问题可以通过设计来获得解决，但 Java8 提供了虚拟扩展方法来解决这一问题。&lt;/p&gt;
&lt;p&gt;虚拟扩展方法是接口中具有默认实现的方法。如果实现类不提供方法的实现，则使用默认的实现。实现类可以重写默认实现，或提供新的默认实现。&lt;/p&gt;
&lt;p&gt;虚拟扩展方法中的默认实现是用 &lt;code&gt;default&lt;/code&gt; 关键字提供的。由于虚拟扩展方法提供默认实现，因此不能是抽象方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}

public class Default {
    public static void main(String[] args) {
        Formula formula = new Formula() { // 这个意思可不是声明了一个接口实例
            @Override
            public double calculate(int a) {
                return sqrt(a * 100);
            }

//            @Override
//            public double sqrt(int a) {
//                return 0;
//            }
        };
        System.out.println(formula.calculate(100)); // 100.0
        System.out.println(formula.sqrt(16)); // 4.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;函数式接口&#34;&gt;函数式接口&lt;/h2&gt;
&lt;p&gt;Lambda 表达式是如何在 Java 的类型系统中表示的呢？每一个 Lambda 表达式都对应一个类型，通常是接口类型。而&lt;strong&gt;函数式接口&lt;/strong&gt;是指仅仅只包含一个抽象方法的接口，每一个该类型的 Lambda 表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。&lt;/p&gt;
&lt;p&gt;我们可以将 Lambda 表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加&lt;code&gt;@FunctionalInterface&lt;/code&gt;注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的（类似的还有&lt;code&gt;@override&lt;/code&gt;等）。&lt;/p&gt;
&lt;p&gt;我们可以来看一个函数式接口的使用例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @Project innovation
 * @Filename Seller
 * @Author Visors
 * @Date 2020/6/1 17:27
 * @Version 1.0
 * @Description TODO
 **/

class Seller1 implements Runnable {
    private int ticket;

    public Seller1(int ticket) {
        this.ticket = ticket;
    }

    @Override
    public void run() {
        while (ticket &amp;gt; 0) {
            ticket--;
            System.out.println(&amp;quot;剩余&amp;quot; + ticket + &amp;quot;张票&amp;quot;);
        }
    }
}

@FunctionalInterface
interface Seller2 {
    void run(int ticket);
}

public class Functional {

    public static void main(String[] args) {
        System.out.println(&amp;quot;开始卖票！&amp;quot;);
//        new Seller1(10).run();
//        new Thread(new Seller1(100)).start();
//        new Thread(new Seller1(20)).start();
        new Seller2() {
            @Override
            public void run(int ticket) {
                while (ticket &amp;gt; 0) {
                    ticket--;
                    System.out.println(&amp;quot;剩余&amp;quot; + ticket + &amp;quot;张票&amp;quot;);
                }
            }
        }.run(10);
        // 没有自由变量
        ((Seller2) ticket -&amp;gt; {
            while (ticket &amp;lt; 10) {
                ticket++;
                System.out.println(&amp;quot;补充到&amp;quot; + ticket + &amp;quot;张票&amp;quot;);
            }
        }).run(0);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数式接口的一个重要作用是实现&lt;em&gt;&lt;strong&gt;行为参数化&lt;/strong&gt;&lt;/em&gt;，即将（模板）方法中可变部分设计成该方法的参数，使得该方法具有通用性。详情可见另一个例子，代码较长，不适合贴在这里。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;编写本文时，我发现很多概念的解释是众说纷纭，相对模糊的，为了尽量解释的合理，我广泛参阅了 &lt;a href=&#34;https://stackoverflow.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StackOverflow&lt;/a&gt; 上的一些问答以及国内一些大牛的博客，结合我自己的理解进行了如上的整理，决不能算作是官方的，甚至还会有错误，希望发现错误的读者可以与我一起讨论更正。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces Round 639 Div.2</title>
      <link>https://visors.github.io/post/codeforces-round-639-div.2/</link>
      <pubDate>Fri, 08 May 2020 12:13:12 +0800</pubDate>
      <guid>https://visors.github.io/post/codeforces-round-639-div.2/</guid>
      <description>&lt;p&gt;这场div本来应该在5月3日举办，结果因为数据库问题被挪到了5月6日。没想到当天，CF又挂了！！！漫长的队列导致一次提交可能要在半个小时甚至多个小时之后才能看到结果，于是这场比赛变成了unrated。不过这对我来说是个好事（明明是必须这样好吗），因为我的B题在提交后半个小时才返回WA结果，然后我检查代码发现打表打小了……于是又补交了一发，直到比赛结束的时候我都没有看见评测结果，第二天醒来才看见AC……总之这是一次体验糟糕的比赛。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;另B被人用暴力水过了……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;c---hilberts-hotelhttpscodeforcescomcontest1345problemc&#34;&gt;&lt;a href=&#34;https://codeforces.com/contest/1345/problem/C&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;C - Hilbert&amp;rsquo;s Hotel&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这题其实非常简单，比赛的时候想到了正解，不过不知道怎么验证。第二天YGL告诉我这样写就OK，我就认真想了下，好像确实是这么一回事。&lt;/p&gt;
&lt;p&gt;虽然考虑的整数是无穷的，但是我们可以人为的把它划分成长度为$n$的周期，题目其实就是对一个周期中的数按照$a[]$的值进行偏移。那么什么时候会空出房间呢？显然是两个不同不同的数在偏移过后得到了相同的结果呗。用数学的方式来表示，那就是&lt;/p&gt;
&lt;p&gt;$$
i+nk_i+a_i=j+nk_j+a_j
$$&lt;/p&gt;
&lt;p&gt;其中$i,j\in[0,n-1]$，$k$则是它们各自所在的周期位置，那么$i+nk_i$就是其对应的初始数字，然后我们再加上它的偏移量$a_i$，得到的就是偏移后的心的位置，对于$j$也是如此。&lt;/p&gt;
&lt;p&gt;那么很显然，上述式子仍然具有周期性，我们可以对等式两边取模&lt;/p&gt;
&lt;p&gt;$i+nk_i+a_i=j+nk_j+a_j$&lt;/p&gt;
&lt;p&gt;$(i+nk_i+a_i)\% n=(j+nk_j+a_j)\% n$&lt;/p&gt;
&lt;p&gt;$(i+a_i)\% n=(j+a_j)\% n$&lt;/p&gt;
&lt;p&gt;也就是说我们只需要判断一个周期$[0,n-1]$的重叠情况就可以了。&lt;/p&gt;
&lt;p&gt;当然这里存在一点细节，由于C/Java使用的是$Truncate$除法，所以如果负数对正数取模时，得到的结果可能是负数，实际编写时，为了防止下标越界，我们应该进一步处理&lt;/p&gt;
&lt;p&gt;$(i+a_i)\% n=(j+a_j)\% n$&lt;/p&gt;
&lt;p&gt;$((i+a_i)\% n+n)\% n=((j+a_j)\% n+n)\% n$&lt;/p&gt;
&lt;p&gt;取模在不同语言下得到的结果可能不同，这取决于语言遵循的取整方式，详细内容可以参考《&lt;a href=&#34;https://www.jianshu.com/p/452c1a5acd31&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;负数取模怎么算&lt;/a&gt;》&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project Codeforces_Round__639__Div__2_
  * @Filename Hilberts_Hotel
  * @Author Visors
  * @Date 2020/5/8 11:26
  * @Version 1.0
  * @Description TODO
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;
int T, n;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; T;
    while (T--) {
        cin &amp;gt;&amp;gt; n;
        vector&amp;lt;int&amp;gt; v(n);
        vector&amp;lt;bool&amp;gt; book(n, false);
        for (auto &amp;amp;it:v) cin &amp;gt;&amp;gt; it;
        for (int i = 0, tmp; i &amp;lt; n; i++) {
            tmp = (((v[i] + i) % n) + n) % n; //避免%出负数
            if (!book[tmp]) book[tmp] = true;
            else {
                cout &amp;lt;&amp;lt; &amp;quot;NO&amp;quot; &amp;lt;&amp;lt; endl;
                goto over;
            }
        }
        cout &amp;lt;&amp;lt; &amp;quot;YES&amp;quot; &amp;lt;&amp;lt; endl;
        over:;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;cf79342299.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kotlin类语法及避雷</title>
      <link>https://visors.github.io/post/kotlin%E7%B1%BB%E8%AF%AD%E6%B3%95%E5%8F%8A%E9%81%BF%E9%9B%B7/</link>
      <pubDate>Thu, 30 Apr 2020 20:49:09 +0800</pubDate>
      <guid>https://visors.github.io/post/kotlin%E7%B1%BB%E8%AF%AD%E6%B3%95%E5%8F%8A%E9%81%BF%E9%9B%B7/</guid>
      <description>&lt;p&gt;Kotlin虽然基于Java语言，但很多语言特性都与Java不一样。这里记录了我学习Kotlin面向对象时的一些见解。&lt;/p&gt;
&lt;p&gt;我们首先来看这样一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Person {
    var name = &amp;quot;&amp;quot;
    var age = 0
    fun eat() {
        println(&amp;quot;$name is eating. He is $age years old.&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个基本的类声明，我们创建了两个字段，并且编写了一个类函数。此时，如果我们想要编写其子类，比如Student，并写下了如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Student : Person() {
    var sno = &amp;quot;&amp;quot;
    var grade = 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们会发现出现了编译错误——Person类是final的，无法被继承。&lt;/p&gt;
&lt;p&gt;这是因为Kotlin默认类是无法被继承的，如果想要允许类被继承，需要使用open关键字开放对某类的继承，即像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;open class Person {
    var name = &amp;quot;&amp;quot;
    var age = 0
    fun eat() {
        println(&amp;quot;$name is eating. He is $age years old.&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能你会疑惑，类被允许继承不是理所应当的吗？为何要多此一举手动开放继承权限呢？&lt;/p&gt;
&lt;p&gt;这里涉及到了Kotlin语言的设计思想，《Effective Java》中曾经指出——如果一个类不是专门为继承而设计的，那么就应该主动将它加上final声明，禁止它可以被继承。这样可以避免一些未知的风险，而Kotlin则是贯彻这一理念，强制coder遵循这一思想。其实这也是一种安全性的体现。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;还有一些关于主次构造函数的辨析内容，写起来可能比较多，后续再进行补充。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hack The Box注册方法</title>
      <link>https://visors.github.io/post/hack-the-box%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 27 Apr 2020 09:43:15 +0800</pubDate>
      <guid>https://visors.github.io/post/hack-the-box%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.hackthebox.eu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hack The Box&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在YGL那里看到这个，听说是拿来训练CTF竞赛的。看上去比较高大上，就先蹭进去再说。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一开始进去应该是这样一个页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;invite.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;遇事不决F12，然后发现一个大大的骷髅头，上面写着让你冷静下来，hack它&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;OX.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后我们再检查元素，发现一个跳到脸上来的api，好像生怕我们找不到它&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;inviteapi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;检查inviteapi.min.js，可以发现一个疑似生成邀请码的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;api.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;于是我们在控制台调用一下这个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;makeInviteCode.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;能够看出这是一段BASE64加密码，百度一个解码工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;decode.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;大白话，使用hackbar POST一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;post.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;又得到一串加密码，估摸着又是BASE64&lt;img src=&#34;invite_code.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;邀请码到手注册进入&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;index.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;看着就很高级，不过这不是我现在要弄的，也许日后见？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用vscode一键编译运行Java代码</title>
      <link>https://visors.github.io/post/%E4%BD%BF%E7%94%A8vscode%E4%B8%80%E9%94%AE%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cjava%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 26 Apr 2020 09:59:30 +0800</pubDate>
      <guid>https://visors.github.io/post/%E4%BD%BF%E7%94%A8vscode%E4%B8%80%E9%94%AE%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cjava%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;确保设备上已安装好Java编译环境（可以在命令行通过指令编译运行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在vscode上安装插件Java Extension Pack&lt;img src=&#34;image-20200319082123511.png&#34; alt=&#34;image-20200319082123511&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在vscode上安装插件Code Runner&lt;img src=&#34;image-20200319082219635.png&#34; alt=&#34;image-20200319082219635&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;image-20200319082343770.png&#34; alt=&#34;image-20200319082343770&#34;&gt;
在设置内找到并勾选在终端内运行（否则无法输入）
&lt;img src=&#34;image-20200319082505479.png&#34; alt=&#34;image-20200319082505479&#34;&gt;
勾选运行前保存（也可以不勾选手动ctrl+s保存）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在工作文件夹下新建&amp;quot;.vscode&amp;quot;文件夹，新建设置文件&amp;quot;settings.json&amp;quot;，拷贝下面的代码，并作本地化修改（大部分设置已有注释，部分是cpp的设置，可自行修改）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;files.defaultLanguage&amp;quot;: &amp;quot;java&amp;quot;, // ctrl+N新建文件后默认的语言
    &amp;quot;editor.formatOnType&amp;quot;: true, // （对于C/C++）输入分号后自动格式化当前这一行的代码
    &amp;quot;editor.suggest.snippetsPreventQuickSuggestions&amp;quot;: false, // clangd的snippets有很多的跳转点，不用这个就必须手动触发Intellisense了
    &amp;quot;editor.acceptSuggestionOnEnter&amp;quot;: &amp;quot;off&amp;quot;, // 我个人的习惯，按回车时一定是真正的换行，只有tab才会接受Intellisense
    // &amp;quot;editor.snippetSuggestions&amp;quot;: &amp;quot;top&amp;quot;, // （可选）snippets显示在补全列表顶端，默认是inline
    &amp;quot;code-runner.runInTerminal&amp;quot;: true, // 设置成false会在“输出”中输出，无法输入
    &amp;quot;code-runner.executorMap&amp;quot;: {
        &amp;quot;java&amp;quot;: &amp;quot;cd $dir &amp;amp;&amp;amp; javac -encoding utf-8 $fileName &amp;amp;&amp;amp; java $fileNameWithoutExt&amp;quot;,//这步非常重要，简单来说是指定了一键编译时发送给终端的命令的形式，默认是没有-encoding utf-8的，这样会导致中文乱码，手动添加可解决这一问题
    }, // 控制Code Runner命令；未注释的仅适用于PowerShell（Win10默认），文件名中有空格也可以编译运行；注释掉的适用于cmd（win7默认），也适用于PS，文件名中有空格时无法运行
    &amp;quot;code-runner.saveFileBeforeRun&amp;quot;: true, // run code前保存
    &amp;quot;code-runner.preserveFocus&amp;quot;: true, // 若为false，run code后光标会聚焦到终端上。如果需要频繁输入数据可设为false
    &amp;quot;code-runner.clearPreviousOutput&amp;quot;: false, // 每次run code前清空属于code runner的终端消息，默认false
    &amp;quot;code-runner.ignoreSelection&amp;quot;: false, // 默认为false，效果是鼠标选中一块代码后可以单独执行
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;在代码页右键Run Code或使用快捷键ctrl+alt+N运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果run code报错，在main函数下面也有个run/debug。尝试使用那里的run&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>蓝桥省赛模拟</title>
      <link>https://visors.github.io/post/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Sat, 25 Apr 2020 11:25:07 +0800</pubDate>
      <guid>https://visors.github.io/post/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F/</guid>
      <description>&lt;h2 id=&#34;填空题&#34;&gt;填空题&lt;/h2&gt;
&lt;p&gt;对于填空题，其实很多时候枚举啊之类的就完事了。但是作为整理，我认为认真的态度是把它当成独立的可以用编程解决的普适的问题来分析，所以下面我会写上每道题的题目改编及思路。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。
请问，总共能排列如多少个不同的单词。&lt;/p&gt;
&lt;h3 id=&#34;答案&#34;&gt;答案&lt;/h3&gt;
&lt;p&gt;$2520$&lt;/p&gt;
&lt;h3 id=&#34;改编&#34;&gt;改编&lt;/h3&gt;
&lt;p&gt;给定一个字符串，求可以得到的排列数。&lt;/p&gt;
&lt;h4 id=&#34;戏说&#34;&gt;戏说&lt;/h4&gt;
&lt;p&gt;根据组合数学原理，统计不同的字符数$n$，以及不同字符出现的个数$tot[i]$，那么结果即为$\frac{n!}{\prod_{i=1}^n{tot[i]!}}$&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;问题描述-1&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;一个包含有2019个结点的无向连通图，最少包含多少条边？&lt;/p&gt;
&lt;h3 id=&#34;答案-1&#34;&gt;答案&lt;/h3&gt;
&lt;p&gt;$2018$&lt;/p&gt;
&lt;h3 id=&#34;改编一&#34;&gt;改编一&lt;/h3&gt;
&lt;p&gt;一个包含有$n$个结点的无向连通图，最少包含多少条边？&lt;/p&gt;
&lt;h4 id=&#34;戏说-1&#34;&gt;戏说&lt;/h4&gt;
&lt;p&gt;该图应为一条链，边数为$n-1$&lt;/p&gt;
&lt;h3 id=&#34;改编二&#34;&gt;改编二&lt;/h3&gt;
&lt;p&gt;一个包含有$n$个结点的无向连通图，最多包含多少条边？&lt;/p&gt;
&lt;h4 id=&#34;戏说-2&#34;&gt;戏说&lt;/h4&gt;
&lt;p&gt;该图应为完全图，边数为$\frac{(1+(n-1))(n-1)}{2} = \frac{n(n-1)}{2}$&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;问题描述-2&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;在计算机存储中，12.5MB是多少字节？&lt;/p&gt;
&lt;h3 id=&#34;答案-2&#34;&gt;答案&lt;/h3&gt;
&lt;p&gt;$13107200$&lt;/p&gt;
&lt;h3 id=&#34;戏说-3&#34;&gt;戏说&lt;/h3&gt;
&lt;p&gt;$1\text{MB}=1024\text{KB}=1024*1024\text{B}$&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;问题描述-3&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;由1对括号，可以组成一种合法括号序列：()。
由2对括号，可以组成两种合法括号序列：()()、(())。
由4对括号组成的合法括号序列一共有多少种？&lt;/p&gt;
&lt;h3 id=&#34;答案-3&#34;&gt;答案&lt;/h3&gt;
&lt;p&gt;$14$&lt;/p&gt;
&lt;h3 id=&#34;改编-1&#34;&gt;改编&lt;/h3&gt;
&lt;p&gt;由$n$对括号组成的合法括号序列一共有多少种？&lt;/p&gt;
&lt;h4 id=&#34;戏说-4&#34;&gt;戏说&lt;/h4&gt;
&lt;p&gt;这题作为填空题肯定是手动枚举一下就行了。&lt;/p&gt;
&lt;p&gt;这里深度为1的序列有一种为：&lt;code&gt;()()()()&lt;/code&gt;，深度为2的有7种:&lt;code&gt;(())()()&lt;/code&gt;、&lt;code&gt;()(())()&lt;/code&gt;、&lt;code&gt;()()(())&lt;/code&gt;、&lt;code&gt;(()()())&lt;/code&gt;、&lt;code&gt;(()())()&lt;/code&gt;、&lt;code&gt;()(()())&lt;/code&gt;、&lt;code&gt;(())(())&lt;/code&gt;，深度为3的有5种：&lt;code&gt;((()))()&lt;/code&gt;、&lt;code&gt;()((()))&lt;/code&gt;、&lt;code&gt;((())())&lt;/code&gt;、&lt;code&gt;(()(()))&lt;/code&gt;、&lt;code&gt;((()()))&lt;/code&gt;，深度为4的有1种:&lt;code&gt;(((())))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我知道你一定觉得这中间有什么规律，但是一时半会儿想不出来。注意，规律不是$2^{n-1}$，我一开始枚举漏了，差点写成8。&lt;/p&gt;
&lt;p&gt;实际上，这是一个卡特兰$Catalan$数问题。&lt;/p&gt;
&lt;p&gt;这里直接给出卡特兰数的定义，即卡特兰数&lt;/p&gt;
&lt;p&gt;$Catalan(n+1)=Catalan(0)*Catalan(n)+Catalan(1)*Catalan(n-1)+&amp;hellip;+Catalan(n)*Catalan(0)$&lt;/p&gt;
&lt;p&gt;其中，$Catalan(0)=1$&lt;/p&gt;
&lt;p&gt;带入一下是不是可以算出：&lt;/p&gt;
&lt;p&gt;$Catalan(1)=1$&lt;/p&gt;
&lt;p&gt;$Catalan(2)=2$&lt;/p&gt;
&lt;p&gt;$Catalan(3)=5$&lt;/p&gt;
&lt;p&gt;$Catalan(4)=14$&lt;/p&gt;
&lt;p&gt;这里便可以用来解决一部分问题了，但这种递推的求法对于$n$较大的情况还是很难处理，即使交给计算机，也容易超时，是否有更好的解法呢？我们可以尝试推一推卡特兰数的通项公式，以这个问题为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;考虑$n$对括号，共有$n$个&lt;code&gt;(&lt;/code&gt;和$n$个&lt;code&gt;)&lt;/code&gt;。显然其全排列的个数为$2n\choose n$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑减法原理，计算非法个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观察非法排列的特性，我们假设&lt;code&gt;(&lt;/code&gt;为$1$，&lt;code&gt;)&lt;/code&gt;为$-1$，那么对于任意一个非法排列$a_1,a_2,&amp;hellip;,a_n$ ，一定存在一个$k$,使得$a_1+a_2+&amp;hellip;+a_k&amp;lt;0$，即$1\sim k$中，&lt;code&gt;)&lt;/code&gt;个数比&lt;code&gt;(&lt;/code&gt;个数多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑一个$n=3$时具体的排列$1,-1,1,-1-1,1$，在$k=5$时，出现了非法情况。我们将$1\sim 5$的每个元素元素翻转，那么该序列就变成了$-1,1,-1,1,1,1$&lt;/p&gt;
&lt;p&gt;翻转过后，一共有$n+1$个$1$，$n-1$个$-1$，共有$2n\choose n+1$种。&lt;/p&gt;
&lt;p&gt;也就是说，对于一个含$n$个$1$，$n$个$-1$的非法排列，总是存在一个最小的$k$，使得我们对第$1$个到第$k$个元素翻转，就能变成含$n+1$个$1$，$n-1$个$-1$的非法排列。同样，对于含$n+1$个$1$，$n-1$个$-1$的非法排列，也总是存在一个最小的$pos$，使得我们对第$1$个到第$pos$个元素翻转，就能变成含$n$个$1$，$n$个$-1$的非法排列。比如对于非法排列$-1,1,1,1,1,-1$，存在$pos=3$，使得翻转后序列变为$1,-1,-1,1,1,-1$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这意味着所有的含$n+1$个$1$，$n-1$个$-1$的非法排列和含$n$个$1$，$n$个$-1$的非法排列建立了一一对应的关系，所以可以推得，非法排列的个数为$2n\choose n+1$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那么对于$n$对括号，合法的排列共有${2n\choose n} - {2n\choose n+1}=\frac{(2n)!}{(n+1)!n!}=\frac{2n\choose n}{n+1}$种&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而卡特兰数的通项公式正好对应上述结果，即$Catalan(n)=\frac{2n\choose n}{n+1}$&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;del&gt;改编不是乱编，戏说不是胡说。&lt;/del&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;程序设计题&#34;&gt;程序设计题&lt;/h2&gt;
&lt;h3 id=&#34;凯撒密码&#34;&gt;凯撒密码&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-4&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;给定一个单词，请使用凯撒密码将这个单词加密。&lt;/p&gt;
&lt;p&gt;凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，&amp;hellip;，w变为z，x变为a，y变为b，z变为c。&lt;/p&gt;
&lt;p&gt;例如，lanqiao会变成odqtldr。&lt;/p&gt;
&lt;h4 id=&#34;输入格式&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入一行，包含一个单词，单词中只包含小写英文字母。&lt;/p&gt;
&lt;h4 id=&#34;输出格式&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行，表示加密后的密文。&lt;/p&gt;
&lt;h4 id=&#34;样例输入&#34;&gt;样例输入&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;lanqiao&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例输出&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;odqtldr&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;评测用例规模与约定&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于所有评测用例，单词中的字母个数不超过100。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;利用ASCII值进行变换，注意处理x,y,z，直接给出代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 5
  * @Author Visors
  * @Date 2020/4/25 8:48
  * @Version 1.0
  * @Description 凯撒密码
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;
string s;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; s;
    int len = s.length();
    for (int i = 0; i &amp;lt; len; i++) s[i] = (s[i] + 3 - &#39;a&#39;) % 26 + &#39;a&#39;;
    cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不用写很多if，一个公式就可以解决了。&lt;/p&gt;
&lt;p&gt;本题的一个好的测试方法是，输入&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;，看看结果是否为&lt;code&gt;defghijklmnopqrstuvwxyzabc&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;反倍数&#34;&gt;反倍数&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-5&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。&lt;/p&gt;
&lt;p&gt;请问在 1 至 n 中有多少个反倍数。&lt;/p&gt;
&lt;h4 id=&#34;输入格式-1&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行包含一个整数 n。&lt;/p&gt;
&lt;p&gt;第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-1&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行包含一个整数，表示答案。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-1&#34;&gt;样例输入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;30
2 3 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;样例输出-1&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;10&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例说明&#34;&gt;样例说明&lt;/h4&gt;
&lt;p&gt;以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。&lt;/p&gt;
&lt;h4 id=&#34;评测用例规模与约定-1&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于 40% 的评测用例，1 &amp;lt;= n &amp;lt;= 10000。&lt;/p&gt;
&lt;p&gt;对于 80% 的评测用例，1 &amp;lt;= n &amp;lt;= 100000。&lt;/p&gt;
&lt;p&gt;对于所有评测用例，1 &amp;lt;= n &amp;lt;= 1000000，1 &amp;lt;= a &amp;lt;= n，1 &amp;lt;= b &amp;lt;= n，1 &amp;lt;= c &amp;lt;= n。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码-1&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;就这个范围，暴力应该就可以了，不过我还是敲了个筛法。最关键的地方是，不要重复统计！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 6
  * @Author Visors
  * @Date 2020/4/25 8:53
  * @Version 1.0
  * @Description 反倍数
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;
const int N = 1e6 + 5;
int n;
bool book[N]; //记录非反倍数

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; n;
    vector&amp;lt;int&amp;gt; v(3);
    for (auto &amp;amp;it:v) cin &amp;gt;&amp;gt; it;
    sort(v.begin(), v.end()); //对题目的a,b,c从小到大排序，至于为什么，见后面
    long long a, b, c; //因为要乘所以开long long，不然如果题目给个1和1000000
    // 我的程序就会1000000*1000000导致int溢出
    int tot = 0; //统计非反倍数个数
    for (int i = 1; i &amp;lt;= n; i++) { //枚举倍数
        a = v[0] * i;
        b = v[1] * i;
        c = v[2] * i;
        //cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
        if (a &amp;gt; n) break; //最小数的倍数都比n大，其它数肯定也大，直接结束
        if (a &amp;lt;= n &amp;amp;&amp;amp; !book[a]) { //a*i没超界且该数没被记录过（去重）
            book[a] = true; //记录
            tot++; //非反倍数+1
        }
        if (b &amp;lt;= n &amp;amp;&amp;amp; !book[b]) {
            book[b] = true;
            tot++;
        }
        if (c &amp;lt;= n &amp;amp;&amp;amp; !book[c]) {
            book[c] = true;
            tot++;
        }
    }
    cout &amp;lt;&amp;lt; n - tot &amp;lt;&amp;lt; endl; //总个数-非反倍数个数=反倍数个数
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有点小题大做不是……&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;螺旋矩阵&#34;&gt;螺旋矩阵&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-6&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。&lt;/p&gt;
&lt;p&gt;例如，一个 4 行 5 列的螺旋矩阵如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1  2  3  4  5
14 15 16 17 6
13 20 19 18 7
12 11 10 9  8
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输入格式-2&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。&lt;/p&gt;
&lt;p&gt;第二行包含两个整数 r, c，表示要求的行号和列号。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-2&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-2&#34;&gt;样例输入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;4 5
2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;样例输出-2&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;15&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;评测用例规模与约定-2&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于 30% 的评测用例，2 &amp;lt;= n, m &amp;lt;= 20。&lt;/p&gt;
&lt;p&gt;对于 70% 的评测用例，2 &amp;lt;= n, m &amp;lt;= 100。&lt;/p&gt;
&lt;p&gt;对于所有评测用例，2 &amp;lt;= n, m &amp;lt;= 1000，1 &amp;lt;= r &amp;lt;= n，1 &amp;lt;= c &amp;lt;= m。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码-2&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;这题数据范围太小，四个while暴力一个一个填数，填到$r$行$c$列即可，下面是随便找的代码（网上博客里面填蛇形矩阵的，如果没记错估计是copy的紫书的）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tot = a[x = 0][y = 0] = 1;
while (tot&amp;lt;n*m)
{
		while (y + 1&amp;lt;n&amp;amp;&amp;amp;!a[x][y + 1])a[x][++y] = ++tot;
		while (x + 1&amp;lt;m&amp;amp;&amp;amp;!a[x + 1][y])a[++x][y] = ++tot;
		while (y - 1 &amp;gt;= 0 &amp;amp;&amp;amp; !a[x][y - 1])a[x][--y] = ++tot;
		while (x - 1 &amp;gt;= 0 &amp;amp;&amp;amp; !a[x - 1][y])a[--x][y] = ++tot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里只放了核心代码，对于初学者来说可能不太容易懂。我初接触算法竞赛时，看到紫书上这个代码，也有点迷糊（刘汝佳代码都比较精炼）。如果不懂，建议智商跟着画一画，或者在Excel里面填着看。&lt;/p&gt;
&lt;p&gt;不过我还是得整点活，上述代码时间复杂度肯定是$O(nm)$，数据范围再大点呢？显然容易超时。有没有公式可以让我们快速求解呢？&lt;/p&gt;
&lt;p&gt;若用$rect[i][j]$表示螺旋矩阵$i$行$j$列的数字，那么对于$n$行$m$列的螺旋矩阵的最外圈，我们可以发现其遵循下面公式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$rect[1][j]=j$&lt;/li&gt;
&lt;li&gt;$rect[i][m]=m+i-1$&lt;/li&gt;
&lt;li&gt;$rect[n][j]=n+2*m-2-j+1$&lt;/li&gt;
&lt;li&gt;$rect[i][1]=2*(n+m)-4-i+2$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这只是最外圈的公式，还要不要继续推下去呢？再推太麻烦了，其实一个矩阵可以被拆成$(n+1)/2$个外圈，分治即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 7
  * @Author Visors
  * @Date 2020/4/25 9:14
  * @Version 1.0
  * @Description 螺旋矩阵
  **/

#include &amp;lt;iostream&amp;gt;

using namespace std;

int n, m, r, c;

int calc(int row, int col, int i, int j) {
    //如果在当前矩阵最外圈，直接公式求解
    if (i == 1)
        return j;
    if (j == col)
        return col + i - 1;
    if (i == row)
        return row + 2 * col - 2 - j + 1;
    if (j == 1)
        return 2 * (row + col) - 4 - i + 2;
    //带着数字进入子矩阵求解
    return calc(row - 2, col - 2, i - 1, j - 1) + 2 * (row + col) - 4;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c;
    cout &amp;lt;&amp;lt; calc(n, m, r, c) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;摆动序列&#34;&gt;摆动序列&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-7&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]&amp;lt;a[2i-1], a[2i+1]&amp;gt;a[2i]。&lt;/p&gt;
&lt;p&gt;小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。&lt;/p&gt;
&lt;h4 id=&#34;输入格式-3&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入一行包含两个整数 m，n。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-3&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-3&#34;&gt;样例输入&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;3 4&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例输出-3&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;14&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例说明-1&#34;&gt;样例说明&lt;/h4&gt;
&lt;p&gt;以下是符合要求的摆动序列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 1 2
2 1 3
2 1 4
3 1 2
3 1 3
3 1 4
3 2 3
3 2 4
4 1 2
4 1 3
4 1 4
4 2 3
4 2 4
4 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;评测用例规模与约定-3&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于 20% 的评测用例，1 &amp;lt;= n, m &amp;lt;= 5；&lt;/p&gt;
&lt;p&gt;对于 50% 的评测用例，1 &amp;lt;= n, m &amp;lt;= 10；&lt;/p&gt;
&lt;p&gt;对于 80% 的评测用例，1 &amp;lt;= n, m &amp;lt;= 100；&lt;/p&gt;
&lt;p&gt;对于所有评测用例，1 &amp;lt;= n, m &amp;lt;= 1000。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码-3&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;这题很多人都说是DP，其实也算不上是DP吧，因为递推就可以了，没有什么“决策”可言。&lt;/p&gt;
&lt;p&gt;若令$f[m][n]$为长度为$m$，以$n$结尾的方案数，那么有&lt;/p&gt;
&lt;p&gt;$f[i][j]=\sum{f[i-1][t]},(t&amp;lt;j)$&lt;/p&gt;
&lt;p&gt;对这个式子不理解？看下后面的代码应该就明白了。&lt;/p&gt;
&lt;p&gt;很明显我们需要枚举$i$和$j$，并且还要计算$\sum$值，这样做的时间复杂度是$O(mn^2)$，显然超出的范围限制（终于？？）。但无需惊慌，对于连续求和，我们可以用前缀和优化一下，时间复杂度即降到$O(mn)$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 8
  * @Author Visors
  * @Date 2020/4/25 9:27
  * @Version 1.0
  * @Description 摆动序列
  **/

#include&amp;lt;iostream&amp;gt;

using namespace std;
const int N = 1000 + 5, MOD = 10000;
int m, n, ans = 0;
int f[N][N]; //f[i][j]为长度为i，以j结尾的方案数

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; i++) f[1][i] = 1; //长度为1，以谁结尾都是一种方案，递推起点
    for (int i = 2; i &amp;lt;= m; i++) {
        int sum = 0;
        if (i &amp;amp; 1) { //奇数与1得1
            //奇数项，从前开始
            for (int j = 1; j &amp;lt;= n; j++) {
                //前缀和优化
                f[i][j] += sum;
                f[i][j] %= MOD;
                sum += f[i - 1][j];
                sum %= MOD;
            }
        } else {
            //偶数项，从后开始
            for (int j = n; j &amp;gt;= 1; j--) {
                //前缀和优化
                f[i][j] += sum;
                f[i][j] %= MOD;
                sum += f[i - 1][j];
                sum %= MOD;
            }
        }
    }
    for (int i = 1; i &amp;lt;= n; i++) {
        ans += f[m][i];
        ans %= MOD;
    }
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题是NOIP2013花匠的弱化版，有兴趣可以深入了解一下。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;户户通电&#34;&gt;户户通电&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-8&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。&lt;/p&gt;
&lt;p&gt;这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。&lt;/p&gt;
&lt;p&gt;现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。&lt;/p&gt;
&lt;p&gt;小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为&lt;/p&gt;
&lt;p&gt;$$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(h_1-h_2)^2}$$&lt;/p&gt;
&lt;p&gt;在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。&lt;/p&gt;
&lt;p&gt;由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。&lt;/p&gt;
&lt;h4 id=&#34;输入格式-4&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行包含一个整数 n ，表示村庄的数量。&lt;/p&gt;
&lt;p&gt;接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-4&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-4&#34;&gt;样例输入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;4
1 1 3
9 9 7
8 8 6
4 5 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;样例输出-4&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;17.41&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;评测用例规模与约定-4&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于 30% 的评测用例，1 &amp;lt;= n &amp;lt;= 10；&lt;/p&gt;
&lt;p&gt;对于 60% 的评测用例，1 &amp;lt;= n &amp;lt;= 100；&lt;/p&gt;
&lt;p&gt;对于所有评测用例，1 &amp;lt;= n &amp;lt;= 1000，0 &amp;lt;= x, y, h &amp;lt;= 10000。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码-4&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;吐槽：这是什么&lt;del&gt;魔怔&lt;/del&gt;距离计算公式？&lt;/p&gt;
&lt;p&gt;不过好在题目“好心”提示了一下，所以问题不大。&lt;/p&gt;
&lt;p&gt;读完题目，发现这是一道最小生成树板子题目。你只需，根据&lt;del&gt;魔怔&lt;/del&gt;距离公式建出完全图，然后套上最小生成树算法得板子即可。值得注意的是，由于本题是完全图，总共有$\frac{n(n-1)}{2}$条边，属于稠密图&lt;del&gt;确信&lt;/del&gt;，由于$prim$算法在稠密图上表现由于$Kruskal$算法，所以我们采用堆优化得$prim$算法（如果不知道为啥要堆优化，可以查阅一下相关资料，这两个算法应该是离散数学里面讲过的）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 9
  * @Author Visors
  * @Date 2020/4/25 9:47
  * @Version 1.0
  * @Description 户户通电
  **/

#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;
const int N = 1000 + 5;
const double oo = sqrt(10000 * 10000 + 10000 * 10000) + 10000 * 10000 + 5;
int n;
double G[N][N], lowCost[N];
bool book[N];

struct Node {
    double x, y, h;

    Node() : x(0), y(0), h(0) {}

    Node(double x, double y, double h) : x(x), y(y), h(h) {}
} node[N];

struct Elem {
    int num;
    double dist;

    Elem() {}

    Elem(int num, double dist) : num(num), dist(dist) {}

    //重载&amp;lt;使优先队列为最小堆
    bool operator&amp;lt;(const Elem &amp;amp;x) const {
        return dist &amp;gt; x.dist;
    }
};

priority_queue&amp;lt;Elem&amp;gt; pq;

double prim() {
    //初始化
    for (int i = 1; i &amp;lt;= n; i++) {
        lowCost[i] = G[1][i];
        pq.push(Elem(i,lowCost[i]));
    }
    lowCost[1] = -oo;
    double tot = 0.0;
    int count = 1;
    Elem tmp;
    while (1) {
        if (count == n) break;
        //取有效堆顶，即为最近顶点
        while (!pq.empty()) {
            tmp = pq.top();
            pq.pop();
            if (lowCost[tmp.num] != -oo) break;
        }
        tot += tmp.dist;
        lowCost[tmp.num] = -oo;
        for (int i = 1; i &amp;lt;= n; i++) {
            if (lowCost[i] != -oo &amp;amp;&amp;amp; G[tmp.num][i] &amp;lt; lowCost[i]) {
                lowCost[i] = G[tmp.num][i];
                pq.push(Elem(i,lowCost[i]));
            }
        }
        count++;
    }
    return tot;
}

int main() {
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    double x, y, h;
    for (int i = 1; i &amp;lt;= n; i++) {
        scanf(&amp;quot;%lf%lf%lf&amp;quot;, &amp;amp;x, &amp;amp;y, &amp;amp;h);
        node[i] = Node(x, y, h);
    }
    //建图
    for (int i = 1; i &amp;lt;= n; i++)
        for (int j = 1; j &amp;lt;= i; j++) {
            if (i == j) G[i][j] = 0;
            else {
                x = (node[i].x - node[j].x) * (node[i].x - node[j].x);
                y = (node[i].y - node[j].y) * (node[i].y - node[j].y);
                h = (node[i].h - node[j].h) * (node[i].h - node[j].h);
                G[i][j] = G[j][i] = sqrt(x + y) + h;
            }
        }
    printf(&amp;quot;%.2lf\n&amp;quot;,prim());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为这是我临场拼的板子，所以可能写的有点过长。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;郊外植树&#34;&gt;郊外植树&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-9&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。&lt;/p&gt;
&lt;p&gt;小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。&lt;/p&gt;
&lt;p&gt;然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。&lt;/p&gt;
&lt;p&gt;他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。&lt;/p&gt;
&lt;p&gt;小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。&lt;/p&gt;
&lt;h4 id=&#34;输入格式-5&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。&lt;/p&gt;
&lt;p&gt;接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-5&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-5&#34;&gt;样例输入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;6
1 1 2
1 4 2
1 7 2
4 1 2
4 4 2
4 7 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;样例输出-5&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;12&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;评测用例规模与约定-5&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于 30% 的评测用例，1 &amp;lt;= n &amp;lt;= 10；&lt;/p&gt;
&lt;p&gt;对于 60% 的评测用例，1 &amp;lt;= n &amp;lt;= 20；&lt;/p&gt;
&lt;p&gt;对于所有评测用例，1 &amp;lt;= n &amp;lt;= 30，0 &amp;lt;= x, y &amp;lt;= 1000，1 &amp;lt;= r &amp;lt;= 1000。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码-5&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;如何判断两棵树是否干涉，其实就是利用高中学过的圆与圆间位置关系来判断即可，也就是两圆心（种树的位置）间距离小于两圆半径之和即为相交。&lt;/p&gt;
&lt;p&gt;这题树很少，直接暴力即可，但纯暴力还是有点吃紧，我们可以稍作剪枝。前面已经说了判断两棵树是否干涉的方法，我们可以考虑预处理任意两树是否发生干涉的数组，在搜索时，一旦出现干涉，立刻返回，即采用可行性剪枝（听说也叫左剪枝，这是根据搜索树形态的变化命名的）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 10
  * @Author Visors
  * @Date 2020/4/25 10:24
  * @Version 1.0
  * @Description 郊外植树
  **/

#include&amp;lt;iostream&amp;gt;

using namespace std;
const int N = 35;
int n, ans;
int x[N], y[N], r[N];
bool book[N], isIntersect[N][N];

void dfs(int step) {
    if (step &amp;gt; n) {
        int sum = 0;
        for (int i = 1; i &amp;lt;= n; i++)
            if (book[i]) sum += (r[i] * r[i]); //PI*r*r/PI
        ans = max(sum, ans);
        return;
    }
    book[step] = false;
    dfs(step + 1); //不种该树搜
    for (int i = 1; i &amp;lt; step; i++)
        if (book[i] &amp;amp;&amp;amp; isIntersect[i][step]) return; //可行性剪枝
    book[step] = true;
    dfs(step + 1); //种该树搜
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; i++) cin &amp;gt;&amp;gt; x[i] &amp;gt;&amp;gt; y[i] &amp;gt;&amp;gt; r[i];
    //判断圆与圆间位置关系
    for (int i = 1; i &amp;lt;= n; i++)
        for (int j = i + 1; j &amp;lt;= n; j++)
            isIntersect[i][j] = isIntersect[j][i] = ((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) &amp;lt;
                                                     (r[i] + r[j]) * (r[i] + r[j]));
    dfs(1);
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;之前以为校赛模拟赛会比较简单，省赛模拟赛会难一些，事实上好像难度接近，甚至这场难度还低于前面某场（之前看星星的题目我线下没写出满分）？所以我估计省赛时也就是这样的难度。也就是说，更多的考察一些数学基础与思维，再带上一些常用算法。&lt;/p&gt;
&lt;p&gt;由于蓝桥不能带板子，所以从练习时就要理解所有的算法，以便自己在赛场上能思路清晰的独立敲出来，背代码是吃力不讨好的。推荐备战蓝桥的同学多刷刷蓝桥题库，如果对算法题有进一步兴趣，也可以刷刷leetcode、Codeforces等网站的题目，对以后求职会有很大帮助。&lt;del&gt;也欢迎来参加我们实验室组织的各项比赛XD&lt;/del&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces Round 637 Div.2</title>
      <link>https://visors.github.io/post/codeforces-round-637-div.2/</link>
      <pubDate>Fri, 24 Apr 2020 09:57:45 +0800</pubDate>
      <guid>https://visors.github.io/post/codeforces-round-637-div.2/</guid>
      <description>&lt;h2 id=&#34;碎碎念&#34;&gt;碎碎念&lt;/h2&gt;
&lt;p&gt;终于上分了真的，感觉可以冲到一两千名的（C代码出的时候提交还不多），结果C沉了，最终只有六千名。毕竟这次手稍微快hhh。本来以为我C的代码够简洁了，没想到正解好像更简洁……&lt;/p&gt;
&lt;p&gt;这次真的是非常遗憾，C和D都接近想到正解，却没有最终AC。另外吐槽一下本场的题面，是真的难读……不过题目质量还是在线的。&lt;/p&gt;
&lt;h2 id=&#34;解题报告&#34;&gt;解题报告&lt;/h2&gt;
&lt;h3 id=&#34;c---nastya-and-strange-generatorhttpscodeforcescomcontest1341problemc&#34;&gt;&lt;a href=&#34;https://codeforces.com/contest/1341/problem/C&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;C - Nastya and Strange Generator&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;C的题目很难读，直接把LYH读崩了，所以这里我先简要翻译一下。&lt;/p&gt;
&lt;p&gt;本题需要我们按照规则检查题目给出的排列能否被生成。开始时排列$p$为空，然后我们按照以下规则依次将$1\sim n$填入排列，一开始$i=1$：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算$r$数组，$r[j]=min(t\in [j,n])$，其中$p[t]~is~empty$即没有被填过，如果不存在这样一个$j$，我们可以用$0$之类的特殊数表示&lt;/li&gt;
&lt;li&gt;计算$count$数组，$count[j]$为$r[]$中$j$的数目&lt;/li&gt;
&lt;li&gt;$count$数组中值最大的下标为$i$的可放置点&lt;/li&gt;
&lt;li&gt;将$i$放入排列，$i++$，转到1.，直到$n$个数被填完&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据这个规则，再结合样例解释，就能够理解了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;C_Note.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果暴力，显然$O(n^2)$超时，这两个$n$分别是枚举每位数的时间和检查每个数能不能填的时间。我们可以考虑优化其中之一，枚举每位数显然很难优化，就看能否优化检查每个数的时间，只要降到$O(logn)$以下，本题就可解决。&lt;/p&gt;
&lt;p&gt;于是乎我们可以研究一下$r$和$count$的生成方法，很容易发现这两个数组在填$i$和$i+1$时是有一定的转移规律的。然后我想到的规律是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上一个数填在最右边，那么前面的$r$数组不会受影响，进而$count$数组也不会受影响，所以当前数可以填在任意空余位置。&lt;/li&gt;
&lt;li&gt;上一个数不在最右边，那么它只会直接影响它自己的$r$，使得其对应下标$r$变为其右边没填的最近的位置，进而打破$count$数组的平衡，使那个位置的count突然比别的多，这时候这个数必须填在那。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project Codeforces_Round__637__Div__2_
  * @Filename Nastya_and_Strange_Generator
  * @Author Visors
  * @Date 2020/4/23 23:56
  * @Version 1.0
  * @Description TODO
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;
const int N = 1e5 + 5;
int T, n;
int pos[N];
bool book[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; T;
    while (T--) {
        memset(book, 0, sizeof(book));
        cin &amp;gt;&amp;gt; n;
        for (int i = 1, t; i &amp;lt;= n; i++) {
            cin &amp;gt;&amp;gt; t;
            pos[t] = i;
        }
        int r = n;
        bool flag = true;
        book[pos[1]] = true;
        for (int i = 2; i &amp;lt;= n; i++) {
            if (pos[i - 1] != r) {
                int tmp = pos[i - 1];
                while (book[tmp]) tmp++;
                if (tmp != pos[i]) {
                    flag = false;
                    break;
                } else book[tmp] = true;
            }
            if (pos[i - 1] == r) {
                book[pos[i]] = true;
                r--;
            }
        }
        if (flag) cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
        else cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是在第二个测试点错了，希望有读者能帮我指出一下问题在哪里。&lt;/p&gt;
&lt;p&gt;正解是判断有没有$p[i]-p[i-1]&amp;gt;1$，如果有那么不能生成。感觉跟我的比较像，不知道差异点是在哪里……&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/*
  * @Filename Nastya_and_Strange_Generator.cpp
  * @Author Visors
  * @Date 2020/4/24 11:07
  * @Version 1.0
  * @Description TODO
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;
int T, n;
vector&amp;lt;int&amp;gt; p;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; T;
    while (T--) {
        cin &amp;gt;&amp;gt; n;
        p = vector&amp;lt;int&amp;gt;(n);
        cin &amp;gt;&amp;gt; p[0];
        bool flag = true;
        for (int i = 1; i &amp;lt; n; i++) {
            cin &amp;gt;&amp;gt; p[i];
            if (p[i] - p[i - 1] &amp;gt; 1) flag = false;
        }
        if (flag) cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
        else cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;cf77872094.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;to be continue……&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我们为何不能轻信评论</title>
      <link>https://visors.github.io/post/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E8%BD%BB%E4%BF%A1%E8%AF%84%E8%AE%BA/</link>
      <pubDate>Thu, 23 Apr 2020 14:08:02 +0800</pubDate>
      <guid>https://visors.github.io/post/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E8%BD%BB%E4%BF%A1%E8%AF%84%E8%AE%BA/</guid>
      <description>&lt;p&gt;近期我常常因为国内外社交媒体下的评论而感到十分恼火，一方面，推特如同催眠般向我推荐反华言论——尽管我关注的人中没有反华分子，反倒是有马云先生、华春莹女士等——另一方面国内媒体如微博、看点下的无脑节奏也让我愤愤不平。但反观我周围，即便我并非处于什么文化人之行列，却仍鲜少有言论无脑之人。于是我陷入了既因为网络无脑节奏之多而怀疑整体网民素质，又因为周围人并没有参与其中而一定程度否定前者的矛盾当中。不过今天饭桌的闲谈中，我似乎突然明白了些什么。&lt;/p&gt;
&lt;p&gt;当今社交媒体评论显示几乎都是基于热度，我们可以思考热评究竟是如何诞生的。只有在热评尚未诞生之时，我们所看见的热评才几乎等同于最新评论，这时第一批围观者或发表他们的看法，或进行点评赞踩，于是一些言论被顶上前排，成了真正的热评。如果你是后来者，你直接看到的就是他人的热评，大多数人不会有翻看最新评论的习惯，所以你迟来的评论并不会引人关注。而事实往往是后来者更倾向于理性看待问题，冲在前面的人还没经过深度思考，便草草发布见解，甚至为上热评，刻意带起节奏。而这部分内容更容易成为热评，真正理性的评论，却大多数被节奏所淹没，隐藏在了最新评论，或者介于最新评论和热门评论之间的“看不见的地带”。&lt;/p&gt;
&lt;p&gt;诚然互联网给每个人都带来了网络时代的红利，但目前以热度为基础的网络环境，却实实在在诱导了一些网民的内心，而这种言论一经热度放大，带起的节奏却不是一般人能理性看待的，类似的还有流量热度至上的无良自媒体。尽管热度害人，能让毫无营养的评论走上热评，网民的不理性仍是关键一环，而想让每个人都能从感性认识快速走向理性认识，几乎是不可能完成的事情，如此一想，我不必轻易为评论所左右，我有我自己的理性思考，我也不必为评论所生气，因为它们往往代表着的是所有声音中最不理智的那一些。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces Round 636 Div.3</title>
      <link>https://visors.github.io/post/codeforces-round-636-div.3/</link>
      <pubDate>Wed, 22 Apr 2020 21:13:22 +0800</pubDate>
      <guid>https://visors.github.io/post/codeforces-round-636-div.3/</guid>
      <description>&lt;h2 id=&#34;碎碎念&#34;&gt;碎碎念&lt;/h2&gt;
&lt;p&gt;最近开始参加Codeforces Round——注册四五年，才打四五场比赛。&lt;/p&gt;
&lt;p&gt;不打打CF还不知道自己竟然这么菜，打个div3先是手速过慢被一众巨巨甩掉，后面偏难题目又A不掉不能实现弯道超车，菜的真实，后面还得加大力度，早日冲上1900分。&lt;/p&gt;
&lt;h2 id=&#34;解题报告&#34;&gt;解题报告&lt;/h2&gt;
&lt;h3 id=&#34;d---constant-palindrome-sumhttpscodeforcescomcontest1343problemd&#34;&gt;&lt;a href=&#34;https://codeforces.com/contest/1343/problem/D&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;D - Constant Palindrome Sum&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这题看上去好想二分一波，但实际上并没有什么好的局部转移的规则。由于这场基本都是数学思维题，所以感觉这题也是这个方向。一开始被题面迷惑了一波，以为minimum是要每次改变最小的数，然后YY半天发现其实是最少次改变数……&lt;/p&gt;
&lt;p&gt;思考的时候已经发现了Tutorial中的三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We don&amp;rsquo;t need to change anything in this pair;&lt;/li&gt;
&lt;li&gt;we can replace one element to fix this pair;&lt;/li&gt;
&lt;li&gt;we need to replace both elements to fix this pair.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也想到要hash各个pair对应的x值，不过因为题意读错的原因老是把两个时期的思维过程搞混，导致本Round直线下分，冷静想想自己已经找到近似解了，比赛的时候还是有点不太理智。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;其实思路非常简单，题目只考虑$a[i]+a[n-i+1]$，所以我们可以把$a[i]$和$a[n-i+1]$视为一对$pair$。&lt;/p&gt;
&lt;p&gt;首先我们读入所有的$pair$，然后对于每对$pair$，我们可以考虑将其三种分类下的作用范围转化为区间涂色问题。线段树可以解决区间涂色问题，但是在这里前缀和更优，参考color the ball那道题目。&lt;/p&gt;
&lt;p&gt;怎么将其转化为区间涂色问题呢？&lt;/p&gt;
&lt;p&gt;对于第一种分类，该$pair$和就为其简单相加。&lt;/p&gt;
&lt;p&gt;对于第二种分类，我们可以考虑固定$pair$的任意元素，改变另外一个元素。例如对于$pair&amp;lt;a,b&amp;gt;$，我们固定$a$，那么由于$b$的改动范围是$[1,k]$，所以整个$pair$的取值范围就是$[a+1,a+k]$，同理也可以固定$b$，改动$a$.&lt;/p&gt;
&lt;p&gt;对于第三种分类，若设全局$U=[2,2k]$，那么两种都需要改动的范围就是$U-([a+1,a+k]\cup [b+1,b+k]\cup {a+b })$啦&lt;/p&gt;
&lt;p&gt;从上述情况来看，我们可以声明两个数组，一个数组$pref$用来做前缀和，一个数组$cnt$来统计第一种分类出现的次数，这样就能知道取任意$x$时需要修改的次数，即$pref[x]-cnt[x]+2*(n/2-pref[x])$（第二种分类减去前缀和中多统计的第一种分类，再加上第三种分类）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project Codeforces_Round__636__Div__3_
  * @Filename Constant_Palindrome_Sum
  * @Author Visors
  * @Date 2020/4/22 22:23
  * @Version 1.0
  * @Description TODO
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;
int T, n, k, ans;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; T;
    while (T--) {
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
        vector&amp;lt;int&amp;gt; a(n), cnt(2 * k + 1), pref(2 * k + 2); //cnt pref多留一个空间避免超界，pref本身有可能操作2*k+1，所以这里+2
        for (auto &amp;amp;it:a) cin &amp;gt;&amp;gt; it; //Editor这么写的，我也学一波
        for (int i = 0; i &amp;lt; n / 2; i++) cnt[a[i] + a[n - i - 1]]++; //下标0开始，n-i+1变成n-i-1
        for (int i = 0; i &amp;lt; n / 2; i++) {
            int l1 = a[i] + 1, r1 = a[i] + k; //固定左边
            int l2 = a[n - i - 1] + 1, r2 = a[n - i - 1] + k; //固定右边
            pref[min(l1, l2)]++;
            pref[max(r1, r2) + 1]--;
        }
        for (int i = 1; i &amp;lt;= 2 * k + 1; i++) pref[i] += pref[i - 1];
        ans = 1e9;
        for (int x = 2; x &amp;lt;= 2 * k; x++) ans = min(ans, (pref[x] - cnt[x]) + 2 * (n / 2 - pref[x]));
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;cf77661481.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;e---weights-distributinghttpscodeforcescomcontest1343probleme&#34;&gt;&lt;a href=&#34;https://codeforces.com/contest/1343/problem/E&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;E - Weights Distributing&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这题虽然是2400分，但我觉得我是可写的，只是比赛连看都没看一眼，前面还需压缩时间。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这道题题面比较长，但其实核心问题比较简单：&lt;/p&gt;
&lt;p&gt;给定$n$个点$m$条边的无向联通图，先给定$m$个边权$p_i$，问如何分配边权，能使从点$a$到点$b$，再从点$b$到点$c$走过的权值最小。&lt;/p&gt;
&lt;p&gt;初读题目，可能会觉得这题过水——跑一遍从$a$到$b$的最短路，再跑一遍从$b$到$c$的最短路，然后贪心从小到大取边权，如果两个最短路中间有重复路段就优先取重复的部分。&lt;/p&gt;
&lt;p&gt;这种想法有可取之处，即把最终选取的路径分为了两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两段路有重合部分&lt;/li&gt;
&lt;li&gt;两段路没有重复部分&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但却忽视了关键问题，即求得的最短路很可能有多条，而选择其中的不同条，会产生不一样的分组结果。其实我们希望重复部分尽量多，但沿用上一方法很难处理。这时候如果把路径的选取看成这样：设两段路的交点为$x$，那么上面的两类可以被描述为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$a$-&amp;gt;$x$-&amp;gt;$b$-&amp;gt;$x$-&amp;gt;$c$&lt;/li&gt;
&lt;li&gt;$a$-&amp;gt;$b(x)$-&amp;gt;$c$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种情况对应下图：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
	subgraph situation1
	a((a))--&amp;gt;x((x));
	x((x))--&amp;gt;b((b));
	b((b))--&amp;gt;x((x));
	x((x))--&amp;gt;c((c));
	end
	subgraph situation2
	A((a))--&amp;gt;B((b=x));
	B((b=x))--&amp;gt;C((c));
	end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是我们很容易想到求出$a,b,c$到各点的最短路，枚举$x$，找到最小的$dist(a,x)+2*dist(b,x)+dist(c,x)$即为题目要求的答案。&lt;/p&gt;
&lt;p&gt;因为我们一开始只需要求边数即边权为$1$的最短路径的长度，所以用BFS就可以处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project Codeforces_Round__636__Div__3_
  * @Filename Weights_Distributing
  * @Author Visors
  * @Date 2020/4/23 21:03
  * @Version 1.0
  * @Description TODO
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;
const int oo = 1e9 + 7;

int T, n, m, a, b, c;

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; G; //内存占用大的声明在全局

void bfs(int v, vector&amp;lt;int&amp;gt; &amp;amp;dist) { //这里传的是引用，不会爆栈
    dist[v] = 0;
    queue&amp;lt;int&amp;gt; q;
    q.push(v);
    while (!q.empty()) {
        int t = q.front();
        q.pop();
        for (auto it:G[t]) {
            if (dist[it] == oo) {
                dist[it] = dist[t] + 1;
                q.push(it);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; T;
    while (T--) {
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        vector&amp;lt;int&amp;gt; p(m + 1);
        for (int i = 1; i &amp;lt;= m; i++) cin &amp;gt;&amp;gt; p[i];
        sort(p.begin() + 1, p.end()); //从大到小排序
        vector&amp;lt;long long&amp;gt; pref(m + 1); //求前缀和，方便后面快速取最小的路径
        for (int i = 1; i &amp;lt;= m; i++) pref[i] = pref[i - 1] + p[i];
        G = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(n + 1);
        for (int i = 1, s, t; i &amp;lt;= m; i++) {
            cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
            G[s].push_back(t);
            G[t].push_back(s);
        }
        vector&amp;lt;int&amp;gt; distA(n + 1, oo), distB(n + 1, oo), distC(n + 1, oo);
        bfs(a, distA);
        bfs(b, distB);
        bfs(c, distC);
        long long ans = 1e18;
        for (int x = 1; x &amp;lt;= n; x++) {
            if (distA[x] + distB[x] + distC[x] &amp;gt; m) continue; //分不了直接跳过
            ans = min(ans, pref[distB[x]] + pref[distA[x] + distB[x] + distC[x]]);
            // = 2 * pref[distB[x]] + (pref[distA[x] + distB[x] + distC[x]] - pref[distB[x]])
        }
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;cf77762497.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
