<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Visors的个人主页</title>
    <link>https://visors.github.io/post/</link>
      <atom:link href="https://visors.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sat, 25 Apr 2020 11:25:07 +0800</lastBuildDate>
    <image>
      <url>https://visors.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Posts</title>
      <link>https://visors.github.io/post/</link>
    </image>
    
    <item>
      <title>蓝桥省赛模拟</title>
      <link>https://visors.github.io/post/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Sat, 25 Apr 2020 11:25:07 +0800</pubDate>
      <guid>https://visors.github.io/post/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F/</guid>
      <description>&lt;h2 id=&#34;填空题&#34;&gt;填空题&lt;/h2&gt;
&lt;p&gt;对于填空题，其实很多时候枚举啊之类的就完事了。但是作为整理，我认为认真的态度是把它当成独立的可以用编程解决的普适的问题来分析，所以下面我会写上每道题的题目改编及思路。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。
请问，总共能排列如多少个不同的单词。&lt;/p&gt;
&lt;h3 id=&#34;答案&#34;&gt;答案&lt;/h3&gt;
&lt;p&gt;$2520$&lt;/p&gt;
&lt;h3 id=&#34;改编&#34;&gt;改编&lt;/h3&gt;
&lt;p&gt;给定一个字符串，求可以得到的排列数。&lt;/p&gt;
&lt;h4 id=&#34;戏说&#34;&gt;戏说&lt;/h4&gt;
&lt;p&gt;根据组合数学原理，统计不同的字符数$n$，以及不同字符出现的个数$tot[i]$，那么结果即为$\frac{n!}{\prod_{i=1}^n{tot[i]!}}$&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;问题描述-1&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;一个包含有2019个结点的无向连通图，最少包含多少条边？&lt;/p&gt;
&lt;h3 id=&#34;答案-1&#34;&gt;答案&lt;/h3&gt;
&lt;p&gt;$2018$&lt;/p&gt;
&lt;h3 id=&#34;改编一&#34;&gt;改编一&lt;/h3&gt;
&lt;p&gt;一个包含有$n$个结点的无向连通图，最少包含多少条边？&lt;/p&gt;
&lt;h4 id=&#34;戏说-1&#34;&gt;戏说&lt;/h4&gt;
&lt;p&gt;该图应为一条链，边数为$n-1$&lt;/p&gt;
&lt;h3 id=&#34;改编二&#34;&gt;改编二&lt;/h3&gt;
&lt;p&gt;一个包含有$n$个结点的无向连通图，最多包含多少条边？&lt;/p&gt;
&lt;h4 id=&#34;戏说-2&#34;&gt;戏说&lt;/h4&gt;
&lt;p&gt;该图应为完全图，边数为$\frac{(1+(n-1))(n-1)}{2} = \frac{n(n-1)}{2}$&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;问题描述-2&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;在计算机存储中，12.5MB是多少字节？&lt;/p&gt;
&lt;h3 id=&#34;答案-2&#34;&gt;答案&lt;/h3&gt;
&lt;p&gt;$13107200$&lt;/p&gt;
&lt;h3 id=&#34;戏说-3&#34;&gt;戏说&lt;/h3&gt;
&lt;p&gt;$1\text{MB}=1024\text{KB}=1024*1024\text{B}$&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;问题描述-3&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;由1对括号，可以组成一种合法括号序列：()。
由2对括号，可以组成两种合法括号序列：()()、(())。
由4对括号组成的合法括号序列一共有多少种？&lt;/p&gt;
&lt;h3 id=&#34;答案-3&#34;&gt;答案&lt;/h3&gt;
&lt;p&gt;$14$&lt;/p&gt;
&lt;h3 id=&#34;改编-1&#34;&gt;改编&lt;/h3&gt;
&lt;p&gt;由$n$对括号组成的合法括号序列一共有多少种？&lt;/p&gt;
&lt;h4 id=&#34;戏说-4&#34;&gt;戏说&lt;/h4&gt;
&lt;p&gt;这题作为填空题肯定是手动枚举一下就行了。&lt;/p&gt;
&lt;p&gt;这里深度为1的序列有一种为：&lt;code&gt;()()()()&lt;/code&gt;，深度为2的有7种:&lt;code&gt;(())()()&lt;/code&gt;、&lt;code&gt;()(())()&lt;/code&gt;、&lt;code&gt;()()(())&lt;/code&gt;、&lt;code&gt;(()()())&lt;/code&gt;、&lt;code&gt;(()())()&lt;/code&gt;、&lt;code&gt;()(()())&lt;/code&gt;、&lt;code&gt;(())(())&lt;/code&gt;，深度为3的有5种：&lt;code&gt;((()))()&lt;/code&gt;、&lt;code&gt;()((()))&lt;/code&gt;、&lt;code&gt;((())())&lt;/code&gt;、&lt;code&gt;(()(()))&lt;/code&gt;、&lt;code&gt;((()()))&lt;/code&gt;，深度为4的有1种:&lt;code&gt;(((())))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我知道你一定觉得这中间有什么规律，但是一时半会儿想不出来。注意，规律不是$2^{n-1}$，我一开始枚举漏了，差点写成8。&lt;/p&gt;
&lt;p&gt;实际上，这是一个卡特兰$Catalan$数问题。&lt;/p&gt;
&lt;p&gt;这里直接给出卡特兰数的定义，即卡特兰数&lt;/p&gt;
&lt;p&gt;$Catalan(n+1)=Catalan(0)*Catalan(n)+Catalan(1)*Catalan(n-1)+&amp;hellip;+Catalan(n)*Catalan(0)$&lt;/p&gt;
&lt;p&gt;其中，$Catalan(0)=1$&lt;/p&gt;
&lt;p&gt;带入一下是不是可以算出：&lt;/p&gt;
&lt;p&gt;$Catalan(1)=1$&lt;/p&gt;
&lt;p&gt;$Catalan(2)=2$&lt;/p&gt;
&lt;p&gt;$Catalan(3)=5$&lt;/p&gt;
&lt;p&gt;$Catalan(4)=14$&lt;/p&gt;
&lt;p&gt;这里便可以用来解决一部分问题了，但这种递推的求法对于$n$较大的情况还是很难处理，即使交给计算机，也容易超时，是否有更好的解法呢？我们可以尝试推一推卡特兰数的通项公式，以这个问题为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;考虑$n$对括号，共有$n$个&lt;code&gt;(&lt;/code&gt;和$n$个&lt;code&gt;)&lt;/code&gt;。显然其全排列的个数为$2n\choose n$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑减法原理，计算非法个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观察非法排列的特性，我们假设&lt;code&gt;(&lt;/code&gt;为$1$，&lt;code&gt;)&lt;/code&gt;为$-1$，那么对于任意一个非法排列$a_1,a_2,&amp;hellip;,a_n$ ，一定存在一个$k$,使得$a_1+a_2+&amp;hellip;+a_k&amp;lt;0$，即$1\sim k$中，&lt;code&gt;)&lt;/code&gt;个数比&lt;code&gt;(&lt;/code&gt;个数多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑一个$n=3$时具体的排列$1,-1,1,-1-1,1$，在$k=5$时，出现了非法情况。我们将$1\sim 5$的每个元素元素翻转，那么该序列就变成了$-1,1,-1,1,1,1$&lt;/p&gt;
&lt;p&gt;翻转过后，一共有$n+1$个$1$，$n-1$个$-1$，共有$2n\choose n+1$种。&lt;/p&gt;
&lt;p&gt;也就是说，对于一个含$n$个$1$，$n$个$-1$的非法排列，总是存在一个最小的$k$，使得我们对第$1$个到第$k$个元素翻转，就能变成含$n+1$个$1$，$n-1$个$-1$的非法排列。同样，对于含$n+1$个$1$，$n-1$个$-1$的非法排列，也总是存在一个最小的$pos$，使得我们对第$1$个到第$pos$个元素翻转，就能变成含$n$个$1$，$n$个$-1$的非法排列。比如对于非法排列$-1,1,1,1,1,-1$，存在$pos=3$，使得翻转后序列变为$1,-1,-1,1,1,-1$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这意味着所有的含$n+1$个$1$，$n-1$个$-1$的非法排列和含$n$个$1$，$n$个$-1$的非法排列建立了一一对应的关系，所以可以推得，非法排列的个数为$2n\choose n+1$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那么对于$n$对括号，合法的排列共有${2n\choose n} - {2n\choose n+1}=\frac{(2n)!}{(n+1)!n!}=\frac{2n\choose n}{n+1}$种&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而卡特兰数的通项公式正好对应上述结果，即$Catalan(n)=\frac{2n\choose n}{n+1}$&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;del&gt;改编不是乱编，戏说不是胡说。&lt;/del&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;程序设计题&#34;&gt;程序设计题&lt;/h2&gt;
&lt;h3 id=&#34;凯撒密码&#34;&gt;凯撒密码&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-4&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;给定一个单词，请使用凯撒密码将这个单词加密。&lt;/p&gt;
&lt;p&gt;凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，&amp;hellip;，w变为z，x变为a，y变为b，z变为c。&lt;/p&gt;
&lt;p&gt;例如，lanqiao会变成odqtldr。&lt;/p&gt;
&lt;h4 id=&#34;输入格式&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入一行，包含一个单词，单词中只包含小写英文字母。&lt;/p&gt;
&lt;h4 id=&#34;输出格式&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行，表示加密后的密文。&lt;/p&gt;
&lt;h4 id=&#34;样例输入&#34;&gt;样例输入&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;lanqiao&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例输出&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;odqtldr&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;评测用例规模与约定&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于所有评测用例，单词中的字母个数不超过100。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;利用ASCII值进行变换，注意处理x,y,z，直接给出代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 5
  * @Author Visors
  * @Date 2020/4/25 8:48
  * @Version 1.0
  * @Description 凯撒密码
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;
string s;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; s;
    int len = s.length();
    for (int i = 0; i &amp;lt; len; i++) s[i] = (s[i] + 3 - &#39;a&#39;) % 26 + &#39;a&#39;;
    cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不用写很多if，一个公式就可以解决了。&lt;/p&gt;
&lt;p&gt;本题的一个好的测试方法是，输入&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;，看看结果是否为&lt;code&gt;defghijklmnopqrstuvwxyzabc&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;反倍数&#34;&gt;反倍数&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-5&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。&lt;/p&gt;
&lt;p&gt;请问在 1 至 n 中有多少个反倍数。&lt;/p&gt;
&lt;h4 id=&#34;输入格式-1&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行包含一个整数 n。&lt;/p&gt;
&lt;p&gt;第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-1&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行包含一个整数，表示答案。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-1&#34;&gt;样例输入&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;30&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2 3 6&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例输出-1&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;10&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例说明&#34;&gt;样例说明&lt;/h4&gt;
&lt;p&gt;以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。&lt;/p&gt;
&lt;h4 id=&#34;评测用例规模与约定-1&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于 40% 的评测用例，1 &amp;lt;= n &amp;lt;= 10000。&lt;/p&gt;
&lt;p&gt;对于 80% 的评测用例，1 &amp;lt;= n &amp;lt;= 100000。&lt;/p&gt;
&lt;p&gt;对于所有评测用例，1 &amp;lt;= n &amp;lt;= 1000000，1 &amp;lt;= a &amp;lt;= n，1 &amp;lt;= b &amp;lt;= n，1 &amp;lt;= c &amp;lt;= n。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码-1&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;就这个范围，暴力应该就可以了，不过我还是敲了个筛法。最关键的地方是，不要重复统计！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 6
  * @Author Visors
  * @Date 2020/4/25 8:53
  * @Version 1.0
  * @Description 反倍数
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;
const int N = 1e6 + 5;
int n;
bool book[N]; //记录非反倍数

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; n;
    vector&amp;lt;int&amp;gt; v(3);
    for (auto &amp;amp;it:v) cin &amp;gt;&amp;gt; it;
    sort(v.begin(), v.end()); //对题目的a,b,c从小到大排序，至于为什么，见后面
    long long a, b, c; //因为要乘所以开long long，不然如果题目给个1和1000000
    // 我的程序就会1000000*1000000导致int溢出
    int tot = 0; //统计非反倍数个数
    for (int i = 1; i &amp;lt;= n; i++) { //枚举倍数
        a = v[0] * i;
        b = v[1] * i;
        c = v[2] * i;
        //cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
        if (a &amp;gt; n) break; //最小数的倍数都比n大，其它数肯定也大，直接结束
        if (a &amp;lt;= n &amp;amp;&amp;amp; !book[a]) { //a*i没超界且该数没被记录过（去重）
            book[a] = true; //记录
            tot++; //非反倍数+1
        }
        if (b &amp;lt;= n &amp;amp;&amp;amp; !book[b]) {
            book[b] = true;
            tot++;
        }
        if (c &amp;lt;= n &amp;amp;&amp;amp; !book[c]) {
            book[c] = true;
            tot++;
        }
    }
    cout &amp;lt;&amp;lt; n - tot &amp;lt;&amp;lt; endl; //总个数-非反倍数个数=反倍数个数
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有点小题大做不是……&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;螺旋矩阵&#34;&gt;螺旋矩阵&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-6&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。&lt;/p&gt;
&lt;p&gt;例如，一个 4 行 5 列的螺旋矩阵如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1  2  3  4  5
14 15 16 17 6
13 20 19 18 7
12 11 10 9  8
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输入格式-2&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。&lt;/p&gt;
&lt;p&gt;第二行包含两个整数 r, c，表示要求的行号和列号。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-2&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-2&#34;&gt;样例输入&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;4 5&lt;/code&gt;
&lt;code&gt;2 2&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例输出-2&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;15&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;评测用例规模与约定-2&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于 30% 的评测用例，2 &amp;lt;= n, m &amp;lt;= 20。&lt;/p&gt;
&lt;p&gt;对于 70% 的评测用例，2 &amp;lt;= n, m &amp;lt;= 100。&lt;/p&gt;
&lt;p&gt;对于所有评测用例，2 &amp;lt;= n, m &amp;lt;= 1000，1 &amp;lt;= r &amp;lt;= n，1 &amp;lt;= c &amp;lt;= m。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码-2&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;这题数据范围太小，四个while暴力一个一个填数，填到$r$行$c$列即可，下面是随便找的代码（网上博客里面填蛇形矩阵的，如果没记错估计是copy的紫书的）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tot = a[x = 0][y = 0] = 1;
while (tot&amp;lt;n*m)
{
		while (y + 1&amp;lt;n&amp;amp;&amp;amp;!a[x][y + 1])a[x][++y] = ++tot;
		while (x + 1&amp;lt;m&amp;amp;&amp;amp;!a[x + 1][y])a[++x][y] = ++tot;
		while (y - 1 &amp;gt;= 0 &amp;amp;&amp;amp; !a[x][y - 1])a[x][--y] = ++tot;
		while (x - 1 &amp;gt;= 0 &amp;amp;&amp;amp; !a[x - 1][y])a[--x][y] = ++tot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里只放了核心代码，对于初学者来说可能不太容易懂。我初接触算法竞赛时，看到紫书上这个代码，也有点迷糊（刘汝佳代码都比较精炼）。如果不懂，建议智商跟着画一画，或者在Excel里面填着看。&lt;/p&gt;
&lt;p&gt;不过我还是得整点活，上述代码时间复杂度肯定是$O(nm)$，数据范围再大点呢？显然容易超时。有没有公式可以让我们快速求解呢？&lt;/p&gt;
&lt;p&gt;若用$rect[i][j]$表示螺旋矩阵$i$行$j$列的数字，那么对于$n$行$m$列的螺旋矩阵的最外圈，我们可以发现其遵循下面公式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$rect[1][j]=j$&lt;/li&gt;
&lt;li&gt;$rect[i][m]=m+i-1$&lt;/li&gt;
&lt;li&gt;$rect[n][j]=n+2*m-2-j+1$&lt;/li&gt;
&lt;li&gt;$rect[i][1]=2*(n+m)-4-i+2$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这只是最外圈的公式，还要不要继续推下去呢？再推太麻烦了，其实一个矩阵可以被拆成$(n+1)/2$个外圈，分治即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 7
  * @Author Visors
  * @Date 2020/4/25 9:14
  * @Version 1.0
  * @Description 螺旋矩阵
  **/

#include &amp;lt;iostream&amp;gt;

using namespace std;

int n, m, r, c;

int calc(int row, int col, int i, int j) {
    //如果在当前矩阵最外圈，直接公式求解
    if (i == 1)
        return j;
    if (j == col)
        return col + i - 1;
    if (i == row)
        return row + 2 * col - 2 - j + 1;
    if (j == 1)
        return 2 * (row + col) - 4 - i + 2;
    //带着数字进入子矩阵求解
    return calc(row - 2, col - 2, i - 1, j - 1) + 2 * (row + col) - 4;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c;
    cout &amp;lt;&amp;lt; calc(n, m, r, c) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;摆动序列&#34;&gt;摆动序列&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-7&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]&amp;lt;a[2i-1], a[2i+1]&amp;gt;a[2i]。&lt;/p&gt;
&lt;p&gt;小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。&lt;/p&gt;
&lt;h4 id=&#34;输入格式-3&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入一行包含两个整数 m，n。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-3&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-3&#34;&gt;样例输入&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;3 4&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例输出-3&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;14&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例说明-1&#34;&gt;样例说明&lt;/h4&gt;
&lt;p&gt;以下是符合要求的摆动序列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 1 2
2 1 3
2 1 4
3 1 2
3 1 3
3 1 4
3 2 3
3 2 4
4 1 2
4 1 3
4 1 4
4 2 3
4 2 4
4 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;评测用例规模与约定-3&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于 20% 的评测用例，1 &amp;lt;= n, m &amp;lt;= 5；&lt;/p&gt;
&lt;p&gt;对于 50% 的评测用例，1 &amp;lt;= n, m &amp;lt;= 10；&lt;/p&gt;
&lt;p&gt;对于 80% 的评测用例，1 &amp;lt;= n, m &amp;lt;= 100；&lt;/p&gt;
&lt;p&gt;对于所有评测用例，1 &amp;lt;= n, m &amp;lt;= 1000。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码-3&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;这题很多人都说是DP，其实也算不上是DP吧，因为递推就可以了，没有什么“决策”可言。&lt;/p&gt;
&lt;p&gt;若令$f[m][n]$为长度为$m$，以$n$结尾的方案数，那么有&lt;/p&gt;
&lt;p&gt;$f[i][j]=\sum{f[i-1][t]},(t&amp;lt;j)$&lt;/p&gt;
&lt;p&gt;对这个式子不理解？看下后面的代码应该就明白了。&lt;/p&gt;
&lt;p&gt;很明显我们需要枚举$i$和$j$，并且还要计算$\sum$值，这样做的时间复杂度是$O(mn^2)$，显然超出的范围限制（终于？？）。但无需惊慌，对于连续求和，我们可以用前缀和优化一下，时间复杂度即降到$O(mn)$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 8
  * @Author Visors
  * @Date 2020/4/25 9:27
  * @Version 1.0
  * @Description 摆动序列
  **/

#include&amp;lt;iostream&amp;gt;

using namespace std;
const int N = 1000 + 5, MOD = 10000;
int m, n, ans = 0;
int f[N][N]; //f[i][j]为长度为i，以j结尾的方案数

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; i++) f[1][i] = 1; //长度为1，以谁结尾都是一种方案，递推起点
    for (int i = 2; i &amp;lt;= m; i++) {
        int sum = 0;
        if (i &amp;amp; 1) { //奇数与1得1
            //奇数项，从前开始
            for (int j = 1; j &amp;lt;= n; j++) {
                //前缀和优化
                f[i][j] += sum;
                f[i][j] %= MOD;
                sum += f[i - 1][j];
                sum %= MOD;
            }
        } else {
            //偶数项，从后开始
            for (int j = n; j &amp;gt;= 1; j--) {
                //前缀和优化
                f[i][j] += sum;
                f[i][j] %= MOD;
                sum += f[i - 1][j];
                sum %= MOD;
            }
        }
    }
    for (int i = 1; i &amp;lt;= n; i++) {
        ans += f[m][i];
        ans %= MOD;
    }
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;户户通电&#34;&gt;户户通电&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-8&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。&lt;/p&gt;
&lt;p&gt;这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。&lt;/p&gt;
&lt;p&gt;现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。&lt;/p&gt;
&lt;p&gt;小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为&lt;/p&gt;
&lt;p&gt;sqrt((x_1-x_2)&lt;em&gt;(x_1-x_2)+(y_1-y_2)&lt;/em&gt;(y_1-y_2))+(h_1-h_2)*(h_1-h_2)。&lt;/p&gt;
&lt;p&gt;在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。&lt;/p&gt;
&lt;p&gt;由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。&lt;/p&gt;
&lt;h4 id=&#34;输入格式-4&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行包含一个整数 n ，表示村庄的数量。&lt;/p&gt;
&lt;p&gt;接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-4&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-4&#34;&gt;样例输入&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;4&lt;/code&gt;
&lt;code&gt;1 1 3&lt;/code&gt;
&lt;code&gt;9 9 7&lt;/code&gt;
&lt;code&gt;8 8 6&lt;/code&gt;
&lt;code&gt;4 5 4&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例输出-4&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;17.41&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;评测用例规模与约定-4&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于 30% 的评测用例，1 &amp;lt;= n &amp;lt;= 10；&lt;/p&gt;
&lt;p&gt;对于 60% 的评测用例，1 &amp;lt;= n &amp;lt;= 100；&lt;/p&gt;
&lt;p&gt;对于所有评测用例，1 &amp;lt;= n &amp;lt;= 1000，0 &amp;lt;= x, y, h &amp;lt;= 10000。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码-4&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;吐槽：这是什么&lt;del&gt;魔怔&lt;/del&gt;距离计算公式？&lt;/p&gt;
&lt;p&gt;不过好在题目“好心”提示了一下，所以问题不大。&lt;/p&gt;
&lt;p&gt;读完题目，发现这是一道最小生成树板子题目。你只需，根据&lt;del&gt;魔怔&lt;/del&gt;距离公式建出完全图，然后套上最小生成树算法得板子即可。值得注意的是，由于本题是完全图，总共有$\frac{n(n-1)}{2}$条边，属于稠密图&lt;del&gt;确信&lt;/del&gt;，由于$prim$算法在稠密图上表现由于$Kruskal$算法，所以我们采用堆优化得$prim$算法（如果不知道为啥要堆优化，可以查阅一下相关资料，这两个算法应该是离散数学里面讲过的）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 9
  * @Author Visors
  * @Date 2020/4/25 9:47
  * @Version 1.0
  * @Description 户户通电
  **/

#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;
const int N = 1000 + 5;
const double oo = sqrt(10000 * 10000 + 10000 * 10000) + 10000 * 10000 + 5;
int n;
double G[N][N], lowCost[N];
bool book[N];

struct Node {
    double x, y, h;

    Node() : x(0), y(0), h(0) {}

    Node(double x, double y, double h) : x(x), y(y), h(h) {}
} node[N];

struct Elem {
    int num;
    double dist;

    Elem() {}

    Elem(int num, double dist) : num(num), dist(dist) {}

    //重载&amp;lt;使优先队列为最小堆
    bool operator&amp;lt;(const Elem &amp;amp;x) const {
        return dist &amp;gt; x.dist;
    }
};

priority_queue&amp;lt;Elem&amp;gt; pq;

double prim() {
    //初始化
    for (int i = 1; i &amp;lt;= n; i++) {
        lowCost[i] = G[1][i];
        pq.push(Elem(i,lowCost[i]));
    }
    lowCost[1] = -oo;
    double tot = 0.0;
    int count = 1;
    Elem tmp;
    while (1) {
        if (count == n) break;
        //取有效堆顶，即为最近顶点
        while (!pq.empty()) {
            tmp = pq.top();
            pq.pop();
            if (lowCost[tmp.num] != -oo) break;
        }
        tot += tmp.dist;
        lowCost[tmp.num] = -oo;
        for (int i = 1; i &amp;lt;= n; i++) {
            if (lowCost[i] != -oo &amp;amp;&amp;amp; G[tmp.num][i] &amp;lt; lowCost[i]) {
                lowCost[i] = G[tmp.num][i];
                pq.push(Elem(i,lowCost[i]));
            }
        }
        count++;
    }
    return tot;
}

int main() {
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    double x, y, h;
    for (int i = 1; i &amp;lt;= n; i++) {
        scanf(&amp;quot;%lf%lf%lf&amp;quot;, &amp;amp;x, &amp;amp;y, &amp;amp;h);
        node[i] = Node(x, y, h);
    }
    //建图
    for (int i = 1; i &amp;lt;= n; i++)
        for (int j = 1; j &amp;lt;= i; j++) {
            if (i == j) G[i][j] = 0;
            else {
                x = (node[i].x - node[j].x) * (node[i].x - node[j].x);
                y = (node[i].y - node[j].y) * (node[i].y - node[j].y);
                h = (node[i].h - node[j].h) * (node[i].h - node[j].h);
                G[i][j] = G[j][i] = sqrt(x + y) + h;
            }
        }
    printf(&amp;quot;%.2lf\n&amp;quot;,prim());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为这是我临场拼的板子，所以可能写的有点过长。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;郊外植树&#34;&gt;郊外植树&lt;/h3&gt;
&lt;h4 id=&#34;问题描述-9&#34;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。&lt;/p&gt;
&lt;p&gt;小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。&lt;/p&gt;
&lt;p&gt;然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。&lt;/p&gt;
&lt;p&gt;他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。&lt;/p&gt;
&lt;p&gt;小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。&lt;/p&gt;
&lt;h4 id=&#34;输入格式-5&#34;&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。&lt;/p&gt;
&lt;p&gt;接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。&lt;/p&gt;
&lt;h4 id=&#34;输出格式-5&#34;&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。&lt;/p&gt;
&lt;h4 id=&#34;样例输入-5&#34;&gt;样例输入&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;6&lt;/code&gt;
&lt;code&gt;1 1 2&lt;/code&gt;
&lt;code&gt;1 4 2&lt;/code&gt;
&lt;code&gt;1 7 2&lt;/code&gt;
&lt;code&gt;4 1 2&lt;/code&gt;
&lt;code&gt;4 4 2&lt;/code&gt;
&lt;code&gt;4 7 2&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;样例输出-5&#34;&gt;样例输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;12&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;评测用例规模与约定-5&#34;&gt;评测用例规模与约定&lt;/h4&gt;
&lt;p&gt;对于 30% 的评测用例，1 &amp;lt;= n &amp;lt;= 10；&lt;/p&gt;
&lt;p&gt;对于 60% 的评测用例，1 &amp;lt;= n &amp;lt;= 20；&lt;/p&gt;
&lt;p&gt;对于所有评测用例，1 &amp;lt;= n &amp;lt;= 30，0 &amp;lt;= x, y &amp;lt;= 1000，1 &amp;lt;= r &amp;lt;= 1000。&lt;/p&gt;
&lt;h3 id=&#34;思路与代码-5&#34;&gt;思路与代码&lt;/h3&gt;
&lt;p&gt;如何判断两棵树是否干涉，其实就是利用高中学过的圆与圆间位置关系来判断即可，也就是两圆心（种树的位置）间距离小于两圆半径之和即为相交。&lt;/p&gt;
&lt;p&gt;这题树很少，直接暴力即可，但纯暴力还是有点吃紧，我们可以稍作剪枝。前面已经说了判断两棵树是否干涉的方法，我们可以考虑预处理任意两树是否发生干涉的数组，在搜索时，一旦出现干涉，立刻返回，即采用可行性剪枝（听说也叫左剪枝，这是根据搜索树形态的变化命名的）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project lanqiao_provincial_simulation
  * @Filename 10
  * @Author Visors
  * @Date 2020/4/25 10:24
  * @Version 1.0
  * @Description 郊外植树
  **/

#include&amp;lt;iostream&amp;gt;

using namespace std;
const int N = 35;
int n, ans;
int x[N], y[N], r[N];
bool book[N], isIntersect[N][N];

void dfs(int step) {
    if (step &amp;gt; n) {
        int sum = 0;
        for (int i = 1; i &amp;lt;= n; i++)
            if (book[i]) sum += (r[i] * r[i]); //PI*r*r/PI
        ans = max(sum, ans);
        return;
    }
    book[step] = false;
    dfs(step + 1); //不种该树搜
    for (int i = 1; i &amp;lt; step; i++)
        if (book[i] &amp;amp;&amp;amp; isIntersect[i][step]) return; //可行性剪枝
    book[step] = true;
    dfs(step + 1); //种该树搜
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; i++) cin &amp;gt;&amp;gt; x[i] &amp;gt;&amp;gt; y[i] &amp;gt;&amp;gt; r[i];
    //判断圆与圆间位置关系
    for (int i = 1; i &amp;lt;= n; i++)
        for (int j = i + 1; j &amp;lt;= n; j++)
            isIntersect[i][j] = isIntersect[j][i] = ((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) &amp;lt;
                                                     (r[i] + r[j]) * (r[i] + r[j]));
    dfs(1);
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;之前以为校赛模拟赛会比较简单，省赛模拟赛会难一些，事实上好像难度接近，甚至这场难度还低于前面某场（之前看星星的题目我线下没写出满分）？所以我估计省赛时也就是这样的难度。也就是说，更多的考察一些数学基础与思维，再带上一些常用算法。&lt;/p&gt;
&lt;p&gt;由于蓝桥不能带板子，所以从练习时就要理解所有的算法，以便自己在赛场上能思路清晰的独立敲出来，背代码是吃力不讨好的。推荐备战蓝桥的同学多刷刷蓝桥题库，如果对算法题有进一步兴趣，也可以刷刷leetcode、Codeforces等网站的题目，对以后求职会有很大帮助。&lt;del&gt;也欢迎来参加我们实验室组织的各项比赛XD&lt;/del&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces Round 637 Div.2</title>
      <link>https://visors.github.io/post/codeforces-round-637-div.2/</link>
      <pubDate>Fri, 24 Apr 2020 09:57:45 +0800</pubDate>
      <guid>https://visors.github.io/post/codeforces-round-637-div.2/</guid>
      <description>&lt;h2 id=&#34;碎碎念&#34;&gt;碎碎念&lt;/h2&gt;
&lt;p&gt;终于上分了真的，感觉可以冲到一两千名的（C代码出的时候提交还不多），结果C沉了，最终只有六千名。毕竟这次手稍微快hhh。本来以为我C的代码够简洁了，没想到正解好像更简洁……&lt;/p&gt;
&lt;p&gt;这次真的是非常遗憾，C和D都接近想到正解，却没有最终AC。另外吐槽一下本场的题面，是真的难读……不过题目质量还是在线的。&lt;/p&gt;
&lt;h2 id=&#34;解题报告&#34;&gt;解题报告&lt;/h2&gt;
&lt;h3 id=&#34;c---nastya-and-strange-generatorhttpscodeforcescomcontest1341problemc&#34;&gt;
&lt;a href=&#34;https://codeforces.com/contest/1341/problem/C&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;C - Nastya and Strange Generator&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;C的题目很难读，直接把LYH读崩了，所以这里我先简要翻译一下。&lt;/p&gt;
&lt;p&gt;本题需要我们按照规则检查题目给出的排列能否被生成。开始时排列$p$为空，然后我们按照以下规则依次将$1\sim n$填入排列，一开始$i=1$：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算$r$数组，$r[j]=min(t\in [j,n])$，其中$p[t]~is~empty$即没有被填过，如果不存在这样一个$j$，我们可以用$0$之类的特殊数表示&lt;/li&gt;
&lt;li&gt;计算$count$数组，$count[j]$为$r[]$中$j$的数目&lt;/li&gt;
&lt;li&gt;$count$数组中值最大的下标为$i$的可放置点&lt;/li&gt;
&lt;li&gt;将$i$放入排列，$i++$，转到1.，直到$n$个数被填完&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据这个规则，再结合样例解释，就能够理解了：&lt;/p&gt;
&lt;p&gt;![](C Note.png)&lt;/p&gt;
&lt;p&gt;如果暴力，显然$O(n^2)$超时，这两个$n$分别是枚举每位数的时间和检查每个数能不能填的时间。我们可以考虑优化其中之一，枚举每位数显然很难优化，就看能否优化检查每个数的时间，只要降到$O(logn)$以下，本题就可解决。&lt;/p&gt;
&lt;p&gt;于是乎我们可以研究一下$r$和$count$的生成方法，很容易发现这两个数组在填$i$和$i+1$时是有一定的转移规律的。然后我想到的规律是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上一个数填在最右边，那么前面的$r$数组不会受影响，进而$count$数组也不会受影响，所以当前数可以填在任意空余位置。&lt;/li&gt;
&lt;li&gt;上一个数不在最右边，那么它只会直接影响它自己的$r$，使得其对应下标$r$变为其右边没填的最近的位置，进而打破$count$数组的平衡，使那个位置的count突然比别的多，这时候这个数必须填在那。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project Codeforces_Round__637__Div__2_
  * @Filename Nastya_and_Strange_Generator
  * @Author Visors
  * @Date 2020/4/23 23:56
  * @Version 1.0
  * @Description TODO
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;
const int N = 1e5 + 5;
int T, n;
int pos[N];
bool book[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; T;
    while (T--) {
        memset(book, 0, sizeof(book));
        cin &amp;gt;&amp;gt; n;
        for (int i = 1, t; i &amp;lt;= n; i++) {
            cin &amp;gt;&amp;gt; t;
            pos[t] = i;
        }
        int r = n;
        bool flag = true;
        book[pos[1]] = true;
        for (int i = 2; i &amp;lt;= n; i++) {
            if (pos[i - 1] != r) {
                int tmp = pos[i - 1];
                while (book[tmp]) tmp++;
                if (tmp != pos[i]) {
                    flag = false;
                    break;
                } else book[tmp] = true;
            }
            if (pos[i - 1] == r) {
                book[pos[i]] = true;
                r--;
            }
        }
        if (flag) cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
        else cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是在第二个测试点错了，希望有读者能帮我指出一下问题在哪里。&lt;/p&gt;
&lt;p&gt;正解是判断有没有$p[i]-p[i-1]&amp;gt;1$，如果有那么不能生成。感觉跟我的比较像，不知道差异点是在哪里……&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/*
  * @Filename Nastya_and_Strange_Generator.cpp
  * @Author Visors
  * @Date 2020/4/24 11:07
  * @Version 1.0
  * @Description TODO
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;
int T, n;
vector&amp;lt;int&amp;gt; p;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; T;
    while (T--) {
        cin &amp;gt;&amp;gt; n;
        p = vector&amp;lt;int&amp;gt;(n);
        cin &amp;gt;&amp;gt; p[0];
        bool flag = true;
        for (int i = 1; i &amp;lt; n; i++) {
            cin &amp;gt;&amp;gt; p[i];
            if (p[i] - p[i - 1] &amp;gt; 1) flag = false;
        }
        if (flag) cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
        else cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;cf77872094.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;to be continue……&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我们为何不能轻信评论</title>
      <link>https://visors.github.io/post/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E8%BD%BB%E4%BF%A1%E8%AF%84%E8%AE%BA/</link>
      <pubDate>Thu, 23 Apr 2020 14:08:02 +0800</pubDate>
      <guid>https://visors.github.io/post/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E8%BD%BB%E4%BF%A1%E8%AF%84%E8%AE%BA/</guid>
      <description>&lt;p&gt;近期我常常因为国内外社交媒体下的评论而感到十分恼火，一方面，推特如同催眠般向我推荐反华言论——尽管我关注的人中没有反华分子，反倒是有马云先生、华春莹女士等——另一方面国内媒体如微博、看点下的无脑节奏也让我愤愤不平。但反观我周围，即便我并非处于什么文化人之行列，却仍鲜少有言论无脑之人。于是我陷入了既因为网络无脑节奏之多而怀疑整体网民素质，又因为周围人并没有参与其中而一定程度否定前者的矛盾当中。不过今天饭桌的闲谈中，我似乎突然明白了些什么。&lt;/p&gt;
&lt;p&gt;当今社交媒体评论显示几乎都是基于热度，我们可以思考热评究竟是如何诞生的。只有在热评尚未诞生之时，我们所看见的热评才几乎等同于最新评论，这时第一批围观者或发表他们的看法，或进行点评赞踩，于是一些言论被顶上前排，成了真正的热评。如果你是后来者，你直接看到的就是他人的热评，大多数人不会有翻看最新评论的习惯，所以往往你发送的迟来的评论并不会引人关注。而事实往往是后来者更倾向于理性看待问题，冲在前面的人往往评论还没经过深度思考，便草草发布，甚至为上热评，刻意带起节奏，而只有这部分的人更容易成为热评，真正理性的评论，却大多数被节奏所淹没，隐藏在了最新评论，或者介于最新评论和热门评论之间的“看不见的地带”。&lt;/p&gt;
&lt;p&gt;诚然互联网给每个人都带来了网络时代的红利，但目前以热度为基础的网络环境，却实实在在诱导了一些网民的内心，而这种言论一经热度放大，带起的节奏却不是一般人能理性看待的，类似的还有流量热度至上的无良自媒体。尽管热度害人，能让毫无营养的评论走上热评，网民的不理性仍是关键一环，而想让每个人都能从感性认识快速走向理性认识，几乎是不可能完成的事情，如此一想，我不必轻易为评论所左右，我有我自己的理性思考，我也不必为评论所生气，因为它们往往代表着的是所有声音中最不理智的那一些。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces Round 636 Div.3</title>
      <link>https://visors.github.io/post/codeforces-round-636-div.3/</link>
      <pubDate>Wed, 22 Apr 2020 21:13:22 +0800</pubDate>
      <guid>https://visors.github.io/post/codeforces-round-636-div.3/</guid>
      <description>&lt;h2 id=&#34;碎碎念&#34;&gt;碎碎念&lt;/h2&gt;
&lt;p&gt;最近开始参加Codeforces Round——注册四五年，才打四五场比赛。&lt;/p&gt;
&lt;p&gt;不打打CF还不知道自己竟然这么菜，打个div3先是手速过慢被一众巨巨甩掉，后面偏难题目又A不掉不能实现弯道超车，菜的真实，后面还得加大力度，早日冲上1900分。&lt;/p&gt;
&lt;h2 id=&#34;解题报告&#34;&gt;解题报告&lt;/h2&gt;
&lt;h3 id=&#34;d---constant-palindrome-sumhttpscodeforcescomcontest1343problemd&#34;&gt;
&lt;a href=&#34;https://codeforces.com/contest/1343/problem/D&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;D - Constant Palindrome Sum&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这题看上去好想二分一波，但实际上并没有什么好的局部转移的规则。由于这场基本都是数学思维题，所以感觉这题也是这个方向。一开始被题面迷惑了一波，以为minimum是要每次改变最小的数，然后YY半天发现其实是最少次改变数……&lt;/p&gt;
&lt;p&gt;思考的时候已经发现了Tutorial中的三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We don&amp;rsquo;t need to change anything in this pair;&lt;/li&gt;
&lt;li&gt;we can replace one element to fix this pair;&lt;/li&gt;
&lt;li&gt;we need to replace both elements to fix this pair.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也想到要hash各个pair对应的x值，不过因为题意读错的原因老是把两个时期的思维过程搞混，导致本Round直线下分，冷静想想自己已经找到近似解了，比赛的时候还是有点不太理智。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;其实思路非常简单，题目只考虑$a[i]+a[n-i+1]$，所以我们可以把$a[i]$和$a[n-i+1]$视为一对$pair$。&lt;/p&gt;
&lt;p&gt;首先我们读入所有的$pair$，然后对于每对$pair$，我们可以考虑将其三种分类下的作用范围转化为区间涂色问题。线段树可以解决区间涂色问题，但是在这里前缀和更优，参考color the ball那道题目。&lt;/p&gt;
&lt;p&gt;怎么将其转化为区间涂色问题呢？&lt;/p&gt;
&lt;p&gt;对于第一种分类，该$pair$和就为其简单相加。&lt;/p&gt;
&lt;p&gt;对于第二种分类，我们可以考虑固定$pair$的任意元素，改变另外一个元素。例如对于$pair&amp;lt;a,b&amp;gt;$，我们固定$a$，那么由于$b$的改动范围是$[1,k]$，所以整个$pair$的取值范围就是$[a+1,a+k]$，同理也可以固定$b$，改动$a$.&lt;/p&gt;
&lt;p&gt;对于第三种分类，若设全局$U=[2,2k]$，那么两种都需要改动的范围就是$U-([a+1,a+k]\cup [b+1,b+k]\cup {a+b })$啦&lt;/p&gt;
&lt;p&gt;从上述情况来看，我们可以声明两个数组，一个数组$pref$用来做前缀和，一个数组$cnt$来统计第一种分类出现的次数，这样就能知道取任意$x$时需要修改的次数，即$pref[x]-cnt[x]+2*(n/2-pref[x])$（第二种分类减去前缀和中多统计的第一种分类，再加上第三种分类）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project Codeforces_Round__636__Div__3_
  * @Filename Constant_Palindrome_Sum
  * @Author Visors
  * @Date 2020/4/22 22:23
  * @Version 1.0
  * @Description TODO
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;
int T, n, k, ans;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; T;
    while (T--) {
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
        vector&amp;lt;int&amp;gt; a(n), cnt(2 * k + 1), pref(2 * k + 2); //cnt pref多留一个空间避免超界，pref本身有可能操作2*k+1，所以这里+2
        for (auto &amp;amp;it:a) cin &amp;gt;&amp;gt; it; //Editor这么写的，我也学一波
        for (int i = 0; i &amp;lt; n / 2; i++) cnt[a[i] + a[n - i - 1]]++; //下标0开始，n-i+1变成n-i-1
        for (int i = 0; i &amp;lt; n / 2; i++) {
            int l1 = a[i] + 1, r1 = a[i] + k; //固定左边
            int l2 = a[n - i - 1] + 1, r2 = a[n - i - 1] + k; //固定右边
            pref[min(l1, l2)]++;
            pref[max(r1, r2) + 1]--;
        }
        for (int i = 1; i &amp;lt;= 2 * k + 1; i++) pref[i] += pref[i - 1];
        ans = 1e9;
        for (int x = 2; x &amp;lt;= 2 * k; x++) ans = min(ans, (pref[x] - cnt[x]) + 2 * (n / 2 - pref[x]));
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;cf77661481.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;e---weights-distributinghttpscodeforcescomcontest1343probleme&#34;&gt;
&lt;a href=&#34;https://codeforces.com/contest/1343/problem/E&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;E - Weights Distributing&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这题虽然是2400分，但我觉得我是可写的，只是比赛连看都没看一眼，前面还需压缩时间。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这道题题面比较长，但其实核心问题比较简单：&lt;/p&gt;
&lt;p&gt;给定$n$个点$m$条边的无向联通图，先给定$m$个边权$p_i$，问如何分配边权，能使从点$a$到点$b$，再从点$b$到点$c$走过的权值最小。&lt;/p&gt;
&lt;p&gt;初读题目，可能会觉得这题过水——跑一遍从$a$到$b$的最短路，再跑一遍从$b$到$c$的最短路，然后贪心从小到大取边权，如果两个最短路中间有重复路段就优先取重复的部分。&lt;/p&gt;
&lt;p&gt;这种想法有可取之处，即把最终选取的路径分为了两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两段路有重合部分&lt;/li&gt;
&lt;li&gt;两段路没有重复部分&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但却忽视了关键问题，即求得的最短路很可能有多条，而选择其中的不同条，会产生不一样的分组结果。其实我们希望重复部分尽量多，但沿用上一方法很难处理。这时候如果把路径的选取看成这样：设两段路的交点为$x$，那么上面的两类可以被描述为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$a$-&amp;gt;$x$-&amp;gt;$b$-&amp;gt;$x$-&amp;gt;$c$&lt;/li&gt;
&lt;li&gt;$a$-&amp;gt;$b(x)$-&amp;gt;$c$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种情况对应下图：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
	subgraph situation1
	a((a))--&amp;gt;x((x));
	x((x))--&amp;gt;b((b));
	b((b))--&amp;gt;x((x));
	x((x))--&amp;gt;c((c));
	end
	subgraph situation2
	A((a))--&amp;gt;B((b=x));
	B((b=x))--&amp;gt;C((c));
	end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是我们很容易想到求出$a,b,c$到各点的最短路，枚举$x$，找到最小的$dist(a,x)+2*dist(b,x)+dist(c,x)$即为题目要求的答案。&lt;/p&gt;
&lt;p&gt;因为我们一开始只需要求边数即边权为$1$的最短路径的长度，所以用BFS就可以处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
  * @Project Codeforces_Round__636__Div__3_
  * @Filename Weights_Distributing
  * @Author Visors
  * @Date 2020/4/23 21:03
  * @Version 1.0
  * @Description TODO
  **/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;
const int oo = 1e9 + 7;

int T, n, m, a, b, c;

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; G; //内存占用大的声明在全局

void bfs(int v, vector&amp;lt;int&amp;gt; &amp;amp;dist) { //这里传的是引用，不会爆栈
    dist[v] = 0;
    queue&amp;lt;int&amp;gt; q;
    q.push(v);
    while (!q.empty()) {
        int t = q.front();
        q.pop();
        for (auto it:G[t]) {
            if (dist[it] == oo) {
                dist[it] = dist[t] + 1;
                q.push(it);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &amp;gt;&amp;gt; T;
    while (T--) {
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        vector&amp;lt;int&amp;gt; p(m + 1);
        for (int i = 1; i &amp;lt;= m; i++) cin &amp;gt;&amp;gt; p[i];
        sort(p.begin() + 1, p.end()); //从大到小排序
        vector&amp;lt;long long&amp;gt; pref(m + 1); //求前缀和，方便后面快速取最小的路径
        for (int i = 1; i &amp;lt;= m; i++) pref[i] = pref[i - 1] + p[i];
        G = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(n + 1);
        for (int i = 1, s, t; i &amp;lt;= m; i++) {
            cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
            G[s].push_back(t);
            G[t].push_back(s);
        }
        vector&amp;lt;int&amp;gt; distA(n + 1, oo), distB(n + 1, oo), distC(n + 1, oo);
        bfs(a, distA);
        bfs(b, distB);
        bfs(c, distC);
        long long ans = 1e18;
        for (int x = 1; x &amp;lt;= n; x++) {
            if (distA[x] + distB[x] + distC[x] &amp;gt; m) continue; //分不了直接跳过
            ans = min(ans, pref[distB[x]] + pref[distA[x] + distB[x] + distC[x]]);
            // = 2 * pref[distB[x]] + (pref[distA[x] + distB[x] + distC[x]] - pref[distB[x]])
        }
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;cf77762497.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
