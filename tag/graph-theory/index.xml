<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graph Theory | Visors的个人主页</title>
    <link>https://visors.github.io/tag/graph-theory/</link>
      <atom:link href="https://visors.github.io/tag/graph-theory/index.xml" rel="self" type="application/rss+xml" />
    <description>Graph Theory</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>©2020 万祚全 All rights reserved</copyright><lastBuildDate>Tue, 27 Oct 2020 19:54:43 +0800</lastBuildDate>
    <image>
      <url>https://visors.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Graph Theory</title>
      <link>https://visors.github.io/tag/graph-theory/</link>
    </image>
    
    <item>
      <title>Tarjan求无向图割边</title>
      <link>https://visors.github.io/post/tarjan%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E8%BE%B9/</link>
      <pubDate>Tue, 27 Oct 2020 19:54:43 +0800</pubDate>
      <guid>https://visors.github.io/post/tarjan%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E8%BE%B9/</guid>
      <description>&lt;link href=&#34;https://fonts.googleapis.com/css2?family=Marck+Script&amp;display=swap&#34; rel=&#34;stylesheet&#34;&gt;
&lt;div style=&#34;font-family:&#39;Marck Script&#39;&#34;&gt;&lt;center&gt;There&#39;s nothing in your eyes&lt;/center&gt;
&lt;center&gt;That marks where you cried&lt;/center&gt;
&lt;center&gt;All is blank all is blind&lt;/center&gt;
&lt;center&gt;Dead inside the inner mind&lt;/center&gt;
    &lt;p align=&#34;right&#34; font-style&gt;&lt;i&gt;——YMO《Behind The Mask》&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&#34;tarjan算法&#34;&gt;Tarjan算法&lt;/h2&gt;
&lt;p&gt;不得不说Robert Tarjan真的是大师，发个网站感受一下&lt;a href=&#34;https://dblp.dagstuhl.de/pid/t/RobertEndreTarjan.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里要说的Tarjan算法用于解决无向图的连通性，学习之前，先了解两个概念。&lt;/p&gt;
&lt;h3 id=&#34;无向连通图的搜索树&#34;&gt;无向连通图的搜索树&lt;/h3&gt;
&lt;p&gt;当我们遍历一个无向连通图时，显然一个点只会被访问一次，而访问一个点的方法是从一个当前已访问的点$u$，沿着它的邻边走向未访问过的点$v$，则对于任意非遍历起点，其都唯一对应一条边$(u,v)$，这些边恰巧构成一棵树（深究其证明，可考虑将$(u,v)$视为有向边，则非起点入度为$1$，起点入度为$0$），我们称之为&lt;strong&gt;无向连通图的搜索树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于DFS序不唯一，所以搜索树也不唯一。若按节点编号顺序遍历图，则搜索树如下图中加粗部分：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((A))
B((B))
C((C))
D((D))
E((E))
A === B
A --- C
B === C
B --- D
C === D
C === E
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;时间戳dfn&#34;&gt;时间戳dfn&lt;/h3&gt;
&lt;p&gt;按照DFS的先后顺序，我们可以为每个节点定义一个访问时间，其为该点在DFS序中的下标，我们称之为&lt;strong&gt;时间戳&lt;/strong&gt;。对于上图，DFS序为$ABCDE$，则若从$1$开始标记时间，则各点时间戳为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((1))
B((2))
C((3))
D((4))
E((5))
A === B
A --- C
B === C
B --- D
C === D
C === E
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;追溯值low&#34;&gt;追溯值low&lt;/h3&gt;
&lt;p&gt;当DFS序不同时，我们对节点标记的$dfn$也不尽相同，例如上图稍加改变，即可得到：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((1))
B((2))
C((4))
D((3))
E((5))
A === B
A --- C
B --- C
B === D
C === D
C === E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以单纯考虑dfn似乎没什么意义。&lt;/p&gt;
&lt;p&gt;我们考虑这样一个事实：若一个点$u$存在非搜索树上的邻边$(u,v)$，且$dfn(u)&amp;gt;dfn(v)$，则显然遍历到点$v$（先于$u$）时，如果我们先走$(u,v)$，那么$dfn(u)$将减小为$dfn(v)+1$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更准确地说，若一个点$u$存在不在搜索树上的邻边$(u,v)$，则必然有$dfn(u)&amp;gt;dfn(v)$，读者可以思考下为什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，对任一点而言，我们将所有可优化的边枚举出来，则其中存在一个最小的优化值，但这个值是我们可以优化到的最小时间戳吗？并非如此，我们对上图稍作改动：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((1))
B((3))
C((5))
D((4))
E((6))
F((2))
A === F
F === B
A --- E
B --- C
B === D
C === D
C === E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以发现，当我们DFS到$6$时，我们有非搜索树上的邻边指向$1$，则$6$的$dfn$事实上可以被优化为$2$，当回溯到$5$时，我们发现$5$有非搜索树上的邻边指向$3$，则$5$的$dfn$可被优化为$4$。但由于我们是从$6$开始回溯的，既然$6$能被优化为$2$，那么$5$肯定能被优化到$3$。&lt;/p&gt;
&lt;p&gt;但这样还是无法避免因为DFS序不同产生的不唯一性问题，不过上述思考给我们指明了一个方向——我们不妨试着找到任意点能回溯到的最早的点的时间戳。与上面过程类似，对于任意点$u$，我们只需考虑这样的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在非搜索树上的边$(u,v)$的$v$点&lt;/li&gt;
&lt;li&gt;在回溯前访问的点，即搜索树中以$u$为根的点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;找出这些点中的最小的时间戳，即为我们能追溯到的最早节点，我们称之为&lt;strong&gt;追溯值&lt;/strong&gt;$low$。则依上述定义，我们可求得上图追溯值（A/B表示时间戳为A，追溯值为B）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((1/1))
B((3/1))
C((5/1))
D((4/1))
E((6/1))
F((2/1))
A === F
F === B
A --- E
B --- C
B === D
C === D
C === E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们发现上图各点都能追溯到$1$，若变换下例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TB
1((1/1))
2((2/1))
3((3/1))
4((4/1))
5((5/1))
6((6/6))
7((7/7))
8((8/6))
9((9/6))
1 === 2
2 === 3
3 === 4
4 === 5
2 --- 5
1 --- 5
1 -.- 6
6 -.- 7
6 === 8
6 --- 9
8 === 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;无向图的割边及判定&#34;&gt;无向图的割边及判定&lt;/h2&gt;
&lt;p&gt;对于无向连通图$G(V,E)$，若删去边$e\in E$后，$G$被分为两个不连通的子图，则称$e$为&lt;strong&gt;割边&lt;/strong&gt;或&lt;strong&gt;桥&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据上面$dfn$和$low$，很容易能想出割边的方法——无向边$(u,v)$是割边，当且仅当搜索树上存在$u$的一个子节点$v$，满足：&lt;/p&gt;
&lt;p&gt;$$dfn[u]&amp;lt;low[v]$$&lt;/p&gt;
&lt;p&gt;如果不明白上式，可以想象，$dfn[u]$指代了一条从起点到$u$的搜索树链，而$low[v]$代表了一条从$v$到$low[v]$对应的点的回溯链。那么若$dfn[u]&amp;lt;low[v]$，则这两条链相连状似一条穿起来的皮带（加粗部分），那么删掉皮带多出来的那一截中的任意一条边，都能使将原图分为两个不连通的子图：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
s((s))
a((a))
b((b))
u((u))
v((v))
s --- u
u === v
v === a
a === b
b === v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若$dfn[u]=low[v]$，则状似闭环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
s((s))
a((a))
u((u))
v((v))
s --- u
u === v
v === a
a === u
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若$dfn[u]&amp;gt;low[v]$，则状似未穿起的皮带：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
s((s))
a((a))
b((b))
u((u))
v((v))
s --- u
u === v
v === a
a === b
b === s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是不是形象了很多？当然，这只是个辅助记忆的可爱的例子，因为如果从递归的最远的节点开始，存在无非搜索树上邻边的点，则上图两条链应当在某些部分重合。但在割边附近，都能形成状似上面三种情况的图形，单链除外：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
s((s))
u((u))
a((a))
b((b))
v((v))
t((t))
s --- u
u --- a
a --- b
b --- v
v --- t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上图中显然任意一条边都为割边。&lt;/p&gt;
&lt;h2 id=&#34;对重边的处理&#34;&gt;对重边的处理&lt;/h2&gt;
&lt;p&gt;显然，当图中存在重边时，我们上面的$low$值求法存在问题，若仅考虑符合条件的两种点，即使存在重边，求得的$low$也不会变化，然而显然下图并不存在割边：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
A((A))
B((B))
C((C))
D((D))
A --- B
A --- B
B --- C
C --- D
D --- B
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若不做一些处理，则会得到存在割边$(A,B)$的错误答案。&lt;/p&gt;
&lt;p&gt;一个可行的方法是——每个点的访问情况仅用于控制不重复遍历点，更新$low$值时转而考虑每条边是否访问过，如果存在未访问过的非搜索树上的边，更新其$low$即可。&lt;/p&gt;
&lt;p&gt;这里有必要对每条边做标记处理吗？显然不用。&lt;/p&gt;
&lt;p&gt;由于我们搜索时形成的是一棵树，那么我们在从节点$u$搜得邻点$v$时，纵使$(u,v)$可能不唯一，但真正访问的$(u,v)$有且仅有一条，当我们回溯时，仅需避开这条边的反向边（^1）即可。因此，我们可以在DFS函数中加一参数，用于记录走到当前节点来时的边的编号。&lt;/p&gt;
&lt;h2 id=&#34;参考实现&#34;&gt;参考实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//
// Created by Visors on 2020/10/27.
//
// 题目名：T103481 【模板】割边
// 题目来源：luogu
// 题目链接：https://www.luogu.com.cn/problem/T103481
// 算法：Tarjan
// 用途：无向图割边
// 时间复杂度：O(n+m)
//

#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

struct Tarjan {
    struct Edge {
        int to, next;

        Edge() = default;

        Edge(int to, int next) : to(to), next(next) {}
    };

    int vertexNum{}, edgeNum{};
    int cnt{};                // 当前时间戳
    vector&amp;lt;Edge&amp;gt; edges;
    vector&amp;lt;int&amp;gt; heads;
    vector&amp;lt;int&amp;gt; dfn;        // 时间戳
    vector&amp;lt;int&amp;gt; low;        // 最早追溯时间
    vector&amp;lt;int&amp;gt; bridges;     // 桥边编号集

    void init(int n, int m) {
        cnt = 0;
        vertexNum = n;
        edgeNum = m;
        heads.resize(vertexNum);
        fill(heads.begin(), heads.end(), -1);
        dfn.resize(vertexNum);
        low.resize(vertexNum);
        bridges.clear();
    }

    void addEdge(int u, int v) {
        edges.emplace_back(v, heads[u]);
        heads[u] = edges.size() - 1;
    }

    void dfs(int u, int inEdge) {
        dfn[u] = low[u] = ++cnt;
        for (int i = heads[u]; ~i; i = edges[i].next) {
            int &amp;amp;v = edges[i].to;
            if (!dfn[v]) {
                dfs(v, i);
                low[u] = min(low[u], low[v]);
                if (low[v] &amp;gt; dfn[u]) bridges.push_back(i);
            } else if (i != (inEdge ^ 1))
                low[u] = min(low[u], dfn[v]);
        }
    }

    void run() {
        for (int i = 0; i &amp;lt; vertexNum; i++)
            if (!dfn[i]) dfs(i, -1);
    }
} tarjan;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n, m;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    tarjan.init(n, m);
    for (int i = 1, u, v; i &amp;lt;= m; i++) {
        cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
        u--, v--;
        tarjan.addEdge(u, v);
        tarjan.addEdge(v, u);
    }
    tarjan.run();
    cout &amp;lt;&amp;lt; tarjan.bridges.size() &amp;lt;&amp;lt; endl;
//    for (int it:tarjan.bridges)
//        cout &amp;lt;&amp;lt; tarjan.edges[it ^ 1].to &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; tarjan.edges[it].to &amp;lt;&amp;lt; endl;
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;还是觉得Wowchemy的代码块样式好看！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>
